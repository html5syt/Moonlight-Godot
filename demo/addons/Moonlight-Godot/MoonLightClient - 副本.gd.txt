# MoonLightClient.gd
# 重构后的 Moonlight 客户端，支持自动化配对并与 GDExtension 集成

extends Node
class_name MoonlightClient

# ============ 常量 ============
const CLIENT_CERT_PATH := "res://certs/client.pem"
const CLIENT_KEY_PATH := "res://certs/client.key"

enum ConnectionState {
    DISCONNECTED,
    CONNECTING,
    CONNECTED,
    FAILED
}

enum PairingState {
    NOT_STARTED,
    IN_PROGRESS,
    PARTIAL_SUCCESS, # 已发送挑战，等待用户确认
    SUCCESS,
    FAILED
}

# ============ 导出变量 ============
@export var server_ip: String = "192.168.1.100"
@export var server_http_port: int = 47989 # 默认HTTP端口
@export var verify_server_cert: bool = true # 是否验证服务器证书
@export var pairing_timeout: float = 60.0 # 配对等待时间（秒）
@export var parent_node_path: NodePath = ".." # GDExtension 节点的父节点路径

# ============ 内部变量 ============
var connection_state: int = ConnectionState.DISCONNECTED
var pairing_state: int = PairingState.NOT_STARTED
var error_message: String = ""
var current_app_id: int = -1
var client_cert: String = ""
var client_key: String = ""
var _generated_pairing_pin: String = "" # 内部存储生成的PIN码
var pairing_progress: int = 0
var https_port: int = 47984 # 默认HTTPS端口，将从serverinfo中获取
var server_unique_id: String = ""
var pairing_server_cert: String = ""

# ============ 服务器信息类 ============
class ServerInfo:
    var hostname: String = ""
    var app_version: String = ""
    var gfe_version: String = ""
    var unique_id: String = ""
    var https_port: int = 47984

# ============ 应用信息类 ============
class AppInfo:
    var id: int = 0
    var title: String = ""
    var image_url: String = ""

# ============ 公共方法 ============

func get_server_info() -> ServerInfo:
    """获取服务器基本信息"""
    var result = ServerInfo.new()
    var http_client = HTTPClient.new()
    var err = http_client.connect_to_host(server_ip, server_http_port)
    if err != OK:
        error_message = "Failed to connect to server for server info: " + str(err)
        return result

    err = http_client.request(HTTPClient.METHOD_GET, "/serverinfo",[])
    if err != OK:
        error_message = "Failed to request server info: " + str(err)
        return result

    # 等待响应
    var timeout := 0
    while http_client.get_status() == HTTPClient.STATUS_CONNECTING or http_client.get_status() == HTTPClient.STATUS_REQUESTING:
        http_client.poll()
        await get_tree().process_frame
        timeout += 1
        if timeout > 50:
            error_message = "Server info request timeout"
            return result

    if http_client.get_status() != HTTPClient.STATUS_CONNECTED:
        error_message = "Failed to get server info response"
        return result

    # 读取完整响应体
    var response_body := ""
    while http_client.get_status() == HTTPClient.STATUS_BODY:
        var chunk = http_client.read_response_body_chunk()
        if chunk.size() == 0:
            break
        response_body += chunk.get_string_from_utf8()

    if response_body == "":
        error_message = "Empty server info response"
        return result

    # 解析XML
    var xml = XMLParser.new()
    err = xml.parse_buffer(response_body.to_utf8_buffer())
    if err != OK:
        error_message = "Failed to parse server info XML: " + str(err)
        return result

    xml.read()
    while xml.get_node_type() != XMLParser.NODE_NONE:
        if xml.get_node_type() == XMLParser.NODE_ELEMENT:
            match xml.get_node_name():
                "hostname":
                    xml.read()
                    result.hostname = xml.get_node_data()
                "appversion":
                    xml.read()
                    result.app_version = xml.get_node_data()
                "GfeVersion":
                    xml.read()
                    result.gfe_version = xml.get_node_data()
                "uniqueid":
                    xml.read()
                    result.unique_id = xml.get_node_data()
                "httpsPort":
                    xml.read()
                    result.https_port = xml.get_node_data().to_int()
        xml.read()

    server_unique_id = result.unique_id
    https_port = result.https_port
    return result

func get_app_list() -> Array[AppInfo]:
    """获取应用列表"""
    var apps: Array[AppInfo] = []
    var server_info = await get_server_info()
    if server_info.unique_id == "":
        error_message = "Cannot get app list without server info"
        return apps

    var url_path := "/applist"
    var params = "uniqueid=" + server_info.unique_id + "&uuid=" + _generate_uuid()
    var result = await _create_https_request(url_path, HTTPClient.METHOD_POST, params)
    if not result.success:
        error_message = "Failed to get app list: " + result.error
        return apps

    # 解析XML响应
    var xml = XMLParser.new()
    var err = xml.parse_buffer(result.response.to_utf8_buffer())
    if err != OK:
        error_message = "Failed to parse app list XML: " + str(err)
        return apps

    xml.read()
    var current_app: AppInfo = null
    while xml.get_node_type() != XMLParser.NODE_NONE:
        if xml.get_node_type() == XMLParser.NODE_ELEMENT:
            if xml.get_node_name() == "App":
                current_app = AppInfo.new()
            elif xml.get_node_name() == "ID" and current_app:
                xml.read()
                current_app.id = xml.get_node_data().to_int()
            elif xml.get_node_name() == "AppTitle" and current_app:
                xml.read()
                current_app.title = xml.get_node_data()
            elif xml.get_node_name() == "Image" and current_app:
                xml.read()
                current_app.image_url = xml.get_node_data()
        elif xml.get_node_type() == XMLParser.NODE_ELEMENT_END and xml.get_node_name() == "App" and current_app:
            apps.append(current_app)
            current_app = null
        xml.read()

    return apps

func get_app_image(app_id: int) -> Texture2D:
    """获取应用图标"""
    var server_info = await get_server_info()
    if server_info.unique_id == "":
        error_message = "Cannot get app image without server info"
        return null

    var url_path = "/appasset?uniqueid=" + server_info.unique_id + "&appid=" + str(app_id) + "&AssetType=2&AssetIdx=0"
    var result = await _create_https_request(url_path, HTTPClient.METHOD_GET)
    if not result.success:
        error_message = "Failed to get app image: " + result.error
        return null

    var image = Image.new()
    var error = image.load_png_from_buffer(result.response.to_utf8_buffer())
    if error != OK:
        error_message = "Failed to load image: " + str(error)
        return null

    var texture = ImageTexture.create_from_image(image)
    return texture

func launch_app(app_id: int) -> bool:
    """启动应用并创建连接"""
    if connection_state == ConnectionState.CONNECTED:
        error_message = "Already connected"
        return false

    connection_state = ConnectionState.CONNECTING
    var server_info = await get_server_info()
    if server_info.unique_id == "":
        error_message = "Failed to get server info"
        connection_state = ConnectionState.DISCONNECTED
        return false

    # 发送启动请求
    var url_path := "/launch"
    var params = "uniqueid=" + server_info.unique_id + "&uuid=" + _generate_uuid() + "&appid=" + str(app_id)
    var result = await _create_https_request(url_path, HTTPClient.METHOD_POST, params)
    if not result.success:
        error_message = "Failed to launch app: " + result.error
        connection_state = ConnectionState.DISCONNECTED
        return false

    # 解析启动响应以获取连接密钥
    var launch_info = _parse_launch_response(result.response)
    if launch_info.is_empty():
        error_message = "Failed to parse launch response"
        connection_state = ConnectionState.DISCONNECTED
        return false

    # 创建 GDExtension 节点
    var parent_node = get_node(parent_node_path)
    if not parent_node:
        error_message = "Parent node not found at path: " + str(parent_node_path)
        connection_state = ConnectionState.DISCONNECTED
        return false

    var stream_node = MoonlightStream.new()
    parent_node.add_child(stream_node)

    # 设置连接参数
    stream_node.set_host_address(server_ip)
    stream_node.set_app_id(app_id)
    stream_node.set_server_app_version(server_info.app_version)
    stream_node.set_server_codec_mode_support(0xFFFF) # 示例值，实际应从 serverinfo 获取
    stream_node.set_server_rtsp_session_url(launch_info.get("session_url", ""))
    
    # 设置从 /launch 响应中获取的加密密钥
    var rikey_bytes = launch_info.get("rikey", PackedByteArray())
    var rikeyid_bytes = launch_info.get("rikeyid", PackedByteArray())
    if rikey_bytes.size() != 16 or rikeyid_bytes.size() < 4:
        error_message = "Invalid rikey or rikeyid from server"
        stream_node.queue_free()
        connection_state = ConnectionState.DISCONNECTED
        return false
    
    stream_node.set_remote_input_aes_key(rikey_bytes)
    stream_node.set_remote_input_aes_iv(rikeyid_bytes)

    # 启动连接
    if not stream_node.start_connection():
        error_message = "Failed to start Moonlight stream connection"
        stream_node.queue_free()
        connection_state = ConnectionState.DISCONNECTED
        return false

    current_app_id = app_id
    connection_state = ConnectionState.CONNECTED
    return true

func resume_app(app_id: int) -> bool:
    """恢复应用"""
    # TODO: 实现 resume 逻辑，流程与 launch_app 类似
    # 需要调用 /resume API，并处理其响应以获取新的 rikey/rikeyid
    push_warning("resume_app not implemented yet")
    return false

func cancel_app(app_id: int) -> bool:
    """取消应用"""
    # TODO: 实现 cancel 逻辑
    # 需要调用 /cancel API
    push_warning("cancel_app not implemented yet")
    return false

# ============ 配对相关方法 ============

func _generate_pin() -> String:
    """生成6位数字PIN码"""
    var rng = RandomNumberGenerator.new()
    rng.randomize()
    return "%06d" % rng.randi_range(0, 999999)

func start_pairing() -> String:
    """
    开始配对流程。
    成功完成初始阶段后，返回自动生成的6位PIN码。
    调用方需将此PIN码展示给用户，并在服务端输入。
    之后，调用方应调用 `wait_for_pairing_confirmation` 来等待确认。
    """
    if pairing_state == PairingState.SUCCESS:
        error_message = "Already paired with server"
        return ""

    pairing_state = PairingState.IN_PROGRESS
    pairing_progress = 0
    _generated_pairing_pin = _generate_pin() # ① 在开始时立即生成PIN

    # 阶段1: 获取服务端证书
    if not await _pairing_stage_1():
        error_message = "Failed to get server certificate"
        pairing_state = PairingState.FAILED
        return ""

    # 阶段2: 发送加密挑战
    if not await _pairing_stage_2():
        error_message = "Failed to send client challenge"
        pairing_state = PairingState.FAILED
        return ""

    pairing_progress = 50
    pairing_state = PairingState.PARTIAL_SUCCESS

    # ② 立即将PIN码返回给调用方
    return _generated_pairing_pin

func wait_for_pairing_confirmation(pin: String) -> bool:
    """
    等待服务端的配对确认。
    调用方应在获取到 `start_pairing()` 返回的PIN码，
    并让用户在服务端输入后，调用此方法。
    """
    if pairing_state != PairingState.PARTIAL_SUCCESS:
        error_message = "Pairing is not in the confirmation waiting state."
        return false

    # 验证传入的 pin 是否与生成的一致（安全检查）
    if pin != _generated_pairing_pin:
        error_message = "Provided PIN does not match the generated one."
        return false

    var success = await _check_pairing_status_task()
    if success:
        pairing_state = PairingState.SUCCESS
        pairing_progress = 100
    else:
        pairing_state = PairingState.FAILED
        if error_message == "":
            error_message = "Pairing timeout or failed"

    return success

# ============ 配对阶段实现 ============

func _pairing_stage_1() -> bool:
    """阶段1: 获取服务端证书"""
    var params = "devicename=roth&updateState=1&phrase=getservercert&salt=" + _generate_salt()
    var http_client = HTTPClient.new()
    var err = http_client.connect_to_host(server_ip, server_http_port)
    if err != OK:
        error_message = "Failed to connect to server: " + str(err)
        return false

    #err = http_client.set_timeout(5000)
    #if err != OK:
        #error_message = "Failed to set timeout: " + str(err)
        #return false

    var headers = [
        "Content-Type: application/x-www-form-urlencoded",
        "Content-Length: " + str(params.length())
    ]

    err = http_client.request(HTTPClient.METHOD_POST, "/pair", headers, params)
    if err != OK:
        error_message = "Failed to send request: " + str(err)
        return false

    var timeout = 0
    while http_client.get_status() == HTTPClient.STATUS_CONNECTING or http_client.get_status() == HTTPClient.STATUS_REQUESTING:
        http_client.poll()
        await get_tree().process_frame
        timeout += 1
        if timeout > 50:
            error_message = "Request timeout"
            return false

    if http_client.get_status() != HTTPClient.STATUS_CONNECTED:
        error_message = "Failed to get response status: " + str(http_client.get_status())
        return false

    var response_body = ""
    while http_client.get_status() == HTTPClient.STATUS_BODY:
        var chunk = http_client.read_response_body_chunk()
        if chunk.size() == 0:
            break
        response_body += chunk.get_string_from_utf8()

    if response_body == "":
        error_message = "Empty response from server"
        return false

    if not _save_server_certificate(response_body):
        return false

    pairing_server_cert = response_body
    return true

func _pairing_stage_2() -> bool:
    """阶段2: 发送加密挑战 (使用HTTPS)"""
    var server_info = await get_server_info()
    if server_info.unique_id == "":
        error_message = "Failed to get server info for pairing stage 2"
        return false

    var url_path = "/pair"
    var params = "devicename=roth&updateState=1&clientchallenge=" + _generate_salt() + "&uuid=" + _generate_uuid()
    var result = await _create_https_request(url_path, HTTPClient.METHOD_POST, params)
    if not result.success:
        error_message = "Failed to send client challenge: " + result.error
        return false

    # 成功收到服务器挑战即视为阶段2完成
    return true

# ============ 辅助方法 ============

func _save_server_certificate(cert_data: String) -> bool:
    """保存服务器证书到文件"""
    var file = FileAccess.open(_get_server_cert_path(), FileAccess.WRITE)
    if file:
        file.store_string(cert_data)
        file.close()
        return true
    else:
        error_message = "Failed to save server certificate"
        return false

func _get_server_cert_path() -> String:
    """获取服务器证书存储路径"""
    return "user://" + server_ip.replace(".", "_") + "_server_cert.pem"

func _generate_salt() -> String:
    """生成随机盐"""
    var crypto = Crypto.new()
    var salt = crypto.generate_random_bytes(16)
    return Marshalls.raw_to_base64(salt)

func _generate_uuid() -> String:
    """生成UUID"""
    var crypto = Crypto.new()
    var bytes = crypto.generate_random_bytes(16)
    # 简单的 UUID v4 生成（非标准，但足够用于此目的）
    bytes[6] = (bytes[6] & 0x0F) | 0x40
    bytes[8] = (bytes[8] & 0x3F) | 0x80
    var hex_str = bytes.hex_encode()
    return (
        hex_str.substr(0, 8) + "-" +
        hex_str.substr(8, 4) + "-" +
        hex_str.substr(12, 4) + "-" +
        hex_str.substr(16, 4) + "-" +
        hex_str.substr(20, 12)
    )

func _create_https_request(url_path: String, method: int = HTTPClient.METHOD_GET, body: String = "") -> Dictionary:
    """创建HTTPS请求"""
    var result = {"success": false, "response": "", "error": ""}

    var client_cert_obj = X509Certificate.new()
    var client_key_obj = CryptoKey.new()
    var cert_error = client_cert_obj.load(CLIENT_CERT_PATH)
    var key_error = client_key_obj.load(CLIENT_KEY_PATH)
    if cert_error != OK or key_error != OK:
        result.error = "Failed to load client certificate or key"
        return result

    var tls_options = TLSOptions.client()
    if verify_server_cert:
        var cert_path = _get_server_cert_path()
        var server_cert = X509Certificate.new()
        var cert_load_error = server_cert.load(cert_path)
        if cert_load_error == OK:
            tls_options = TLSOptions.client(server_cert)
        else:
            result.error = "Failed to load server certificate for verification: " + str(cert_load_error)
            return result

    var http_client = HTTPClient.new()
    var err = http_client.connect_to_host(server_ip, https_port, tls_options)
    if err != OK:
        result.error = "Failed to connect to server: " + str(err)
        return result

    http_client.set_timeout(10000)

    var headers = []
    if method == HTTPClient.METHOD_POST and body != "":
        headers.append("Content-Type: application/x-www-form-urlencoded")
        headers.append("Content-Length: " + str(body.length()))

    err = http_client.request(method, url_path, headers, body)
    if err != OK:
        result.error = "Failed to send request: " + str(err)
        return result

    var timeout = 0
    while http_client.get_status() == HTTPClient.STATUS_CONNECTING or http_client.get_status() == HTTPClient.STATUS_REQUESTING:
        http_client.poll()
        await get_tree().process_frame
        timeout += 1
        if timeout > 100:
            result.error = "Request timeout"
            return result

    if http_client.get_status() != HTTPClient.STATUS_CONNECTED:
        result.error = "Failed to get response status: " + str(http_client.get_status())
        return result

    var response_body = ""
    while http_client.get_status() == HTTPClient.STATUS_BODY:
        var chunk = http_client.read_response_body_chunk()
        if chunk.size() == 0:
            break
        response_body += chunk.get_string_from_utf8()

    result.response = response_body
    result.success = true
    return result

func _parse_launch_response(response: String) -> Dictionary:
    """解析 /launch 响应，提取 rikey, rikeyid, sessionUrl0 等信息"""
    var info = {}
    if not response.begins_with("<root"):
        return info

    var xml = XMLParser.new()
    var err = xml.parse_buffer(response.to_utf8_buffer())
    if err != OK:
        return info

    xml.read()
    while xml.get_node_type() != XMLParser.NODE_NONE:
        if xml.get_node_type() == XMLParser.NODE_ELEMENT:
            match xml.get_node_name():
                "rikey":
                    xml.read()
                    if xml.get_node_type() == XMLParser.NODE_TEXT:
                        # rikey 是 base64 编码的 16 字节 AES 密钥
                        var decoded = Marshalls.base64_to_raw(xml.get_node_data())
                        info["rikey"] = decoded
                "rikeyid":
                    xml.read()
                    if xml.get_node_type() == XMLParser.NODE_TEXT:
                        # rikeyid 是 base64 编码的 4 字节 IV (key ID)
                        var decoded = Marshalls.base64_to_raw(xml.get_node_data())
                        info["rikeyid"] = decoded
                "sessionUrl0":
                    xml.read()
                    if xml.get_node_type() == XMLParser.NODE_TEXT:
                        info["session_url"] = xml.get_node_data()
        xml.read()

    return info

# ============ 私有轮询任务 ============

func _check_pairing_status_task() -> bool:
    """后台任务：轮询配对状态，返回是否成功"""
    var start_time = Time.get_unix_time_from_system()

    while Time.get_unix_time_from_system() - start_time < pairing_timeout:
        if await _check_pairing_status():
            return true
        await get_tree().create_timer(1.0).timeout # 每隔1秒查询一次

    return false

func _check_pairing_status() -> bool:
    """向服务器查询当前配对状态"""
    var server_info = await get_server_info()
    if server_info.unique_id == "":
        return false

    var url_path := "/pair"
    var params := "devicename=roth&updateState=1&phrase=pairchallenge&uuid=" + _generate_uuid()
    var result = await _create_https_request(url_path, HTTPClient.METHOD_POST, params)
    if not result.success:
        return false

    # 解析响应，检查是否成功
    if result.response.begins_with("<root"):
        var xml = XMLParser.new()
        var err = xml.parse_buffer(result.response.to_utf8_buffer())
        if err == OK:
            xml.read()
            while xml.get_node_type() != XMLParser.NODE_NONE:
                if xml.get_node_type() == XMLParser.NODE_ELEMENT and xml.get_node_name() == "root":
                    var status_code = xml.get_named_attribute_value("status_code")
                    return status_code == "200"
                xml.read()
    return false
