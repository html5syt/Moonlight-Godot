# DeepWiki Q&A with Code Context for Repository: moonlight-stream/moonlight-qt
## Q1
how to get /launch and /serverinfo info from server?
### Answer
Based on the code context, you're asking about how Moonlight retrieves `/launch` and `/serverinfo` information from the host server.

## Answer

Moonlight uses the `NvHTTP` class to communicate with the host server and retrieve information through HTTP/HTTPS endpoints. moonlight-qt:124-187 

### Getting `/serverinfo`

The `NvHTTP::getServerInfo()` method fetches server information: moonlight-qt:124-140 

The method first attempts to use HTTPS if a pinned certificate is available, then falls back to HTTP if needed. moonlight-qt:143-160  If no certificate exists yet, it uses HTTP initially to fetch the HTTPS port, then retries over HTTPS. moonlight-qt:162-183 

This is called during PC discovery when adding a new host: moonlight-qt:809-818 

The response is then used to create or update an `NvComputer` object: moonlight-qt:820-821 

### Getting `/launch` info

The `/launch` endpoint is called via `NvHTTP::startApp()` when starting a streaming session: moonlight-qt:1585-1593 

This happens in `Session::startConnectionAsync()` after the user selects an app to stream. moonlight-qt:1548-1600  The method passes streaming configuration parameters and receives back an RTSP session URL that's used to establish the actual streaming connection. moonlight-qt:1582-1593 

## Notes

The `NvHTTP` class handles all HTTP/HTTPS communication with the host server, including certificate pinning for security. The `/serverinfo` endpoint is polled regularly to monitor PC status, while `/launch` (or `/resume`) is only called when initiating a streaming session. Both endpoints use the base URL constructed from the host's address and appropriate port (HTTP 47989 or HTTPS 47984 by default).

Wiki pages you might want to explore:
- [User Interface System (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2)
- [PC Discovery View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.1)
### Citations
**File:** app/backend/nvhttp.cpp (L124-187)
```cpp
NvHTTP::getServerInfo(NvLogLevel logLevel, bool fastFail)
{
    QString serverInfo;

    // Check if we have a pinned cert and HTTPS port for this host yet
    if (!m_ServerCert.isNull() && httpsPort() != 0)
    {
        try
        {
            // Always try HTTPS first, since it properly reports
            // pairing status (and a few other attributes).
            serverInfo = openConnectionToString(m_BaseUrlHttps,
                                                "serverinfo",
                                                nullptr,
                                                fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                                logLevel);
            // Throws if the request failed
            verifyResponseStatus(serverInfo);
        }
        catch (const GfeHttpResponseException& e)
        {
            if (e.getStatusCode() == 401)
            {
                // Certificate validation error, fallback to HTTP
                serverInfo = openConnectionToString(m_BaseUrlHttp,
                                                    "serverinfo",
                                                    nullptr,
                                                    fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                                    logLevel);
                verifyResponseStatus(serverInfo);
            }
            else
            {
                // Rethrow real errors
                throw e;
            }
        }
    }
    else
    {
        // Only use HTTP prior to pairing or fetching HTTPS port
        serverInfo = openConnectionToString(m_BaseUrlHttp,
                                            "serverinfo",
                                            nullptr,
                                            fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                            logLevel);
        verifyResponseStatus(serverInfo);

        // Populate the HTTPS port
        uint16_t httpsPort = getXmlString(serverInfo, "HttpsPort").toUShort();
        if (httpsPort == 0) {
            httpsPort = DEFAULT_HTTPS_PORT;
        }
        setHttpsPort(httpsPort);

        // If we just needed to determine the HTTPS port, we'll try again over
        // HTTPS now that we have the port number
        if (!m_ServerCert.isNull()) {
            return getServerInfo(logLevel, fastFail);
        }
    }

    return serverInfo;
}
```
**File:** app/backend/computermanager.cpp (L809-818)
```cpp
        // Perform initial serverinfo fetch over HTTP since we don't know which cert to use
        QString serverInfo = fetchServerInfo(http);
        if (serverInfo.isEmpty() && !m_MdnsIpv6Address.isNull()) {
            // Retry using the global IPv6 address if the IPv4 or link-local IPv6 address fails
            http.setAddress(m_MdnsIpv6Address);
            serverInfo = fetchServerInfo(http);
        }
        if (serverInfo.isEmpty()) {
            return;
        }
```
**File:** app/backend/computermanager.cpp (L820-821)
```cpp
        // Create initial newComputer using HTTP serverinfo with no pinned cert
        NvComputer* newComputer = new NvComputer(http, serverInfo);
```
**File:** app/streaming/session.cpp (L1548-1600)
```cpp
bool Session::startConnectionAsync()
{
    // Wait 1.5 seconds before connecting to let the user
    // have time to read any messages present on the segue
    SDL_Delay(1500);

    // The UI should have ensured the old game was already quit
    // if we decide to stream a different game.
    Q_ASSERT(m_Computer->currentGameId == 0 ||
             m_Computer->currentGameId == m_App.id);

    bool enableGameOptimizations;
    if (m_Computer->isNvidiaServerSoftware) {
        // GFE will set all settings to 720p60 if it doesn't recognize
        // the chosen resolution. Avoid that by disabling SOPS when it
        // is not streaming a supported resolution.
        enableGameOptimizations = false;
        for (const NvDisplayMode &mode : m_Computer->displayModes) {
            if (mode.width == m_StreamConfig.width &&
                    mode.height == m_StreamConfig.height) {
                SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION,
                            "Found host supported resolution: %dx%d",
                            mode.width, mode.height);
                enableGameOptimizations = m_Preferences->gameOptimizations;
                break;
            }
        }
    }
    else {
        // Always send SOPS to Sunshine because we may repurpose the
        // option to control whether the display mode is adjusted
        enableGameOptimizations = m_Preferences->gameOptimizations;
    }

    QString rtspSessionUrl;

    try {
        NvHTTP http(m_Computer);
        http.startApp(m_Computer->currentGameId != 0 ? "resume" : "launch",
                      m_Computer->isNvidiaServerSoftware,
                      m_App.id, &m_StreamConfig,
                      enableGameOptimizations,
                      m_Preferences->playAudioOnHost,
                      m_InputHandler->getAttachedGamepadMask(),
                      !m_Preferences->multiController,
                      rtspSessionUrl);
    } catch (const GfeHttpResponseException& e) {
        emit displayLaunchError(tr("Host returned error: %1").arg(e.toQString()));
        return false;
    } catch (const QtNetworkReplyException& e) {
        emit displayLaunchError(e.toQString());
        return false;
    }
```
## Q2
How to parse the information returned by the above 2 interfaces and provide it to the function for establishing a streaming connection?
### Answer
You're asking about how Moonlight parses the responses from `/serverinfo` and `/launch` endpoints and uses that information to establish a streaming connection.

## Answer

### Parsing `/serverinfo` Response

The `/serverinfo` response is parsed to create/update an `NvComputer` object that stores host capabilities. moonlight-qt:754-782  The `NvHTTP::getServerInfo()` method returns an XML string that gets parsed to extract server properties like:<cite />

- Server codec mode support (`serverCodecModeSupport`)
- GFE version (`gfeVersion`)
- App version (`appVersion`)
- Display modes
- Current game ID

These properties are stored in the `NvComputer` object and later used during session validation and configuration.<cite />

### Parsing `/launch` Response and Establishing Connection

When starting a stream, `NvHTTP::startApp()` is called with the `STREAM_CONFIGURATION` structure containing all streaming parameters (resolution, FPS, bitrate, codec preferences, etc.). moonlight-qt:189-236  The method constructs a URL with query parameters including:<cite />

- Resolution and FPS (`mode` parameter)
- HDR settings
- Audio configuration
- Gamepad mask
- Remote input encryption keys

The response is parsed to extract the `rtspSessionUrl` using `getXmlString(response, "sessionUrl0")`. moonlight-qt:235-235 

### Providing Information to Connection Function

After receiving the `/launch` response, the parsed information is used to populate a `SERVER_INFORMATION` structure: moonlight-qt:1602-1624 

```cpp
SERVER_INFORMATION hostInfo;
hostInfo.address = hostnameStr.data();
hostInfo.serverInfoAppVersion = siAppVersion.data();
hostInfo.serverCodecModeSupport = m_Computer->serverCodecModeSupport;
hostInfo.serverInfoGfeVersion = siGfeVersion.data();
hostInfo.rtspSessionUrl = rtspSessionUrlStr.data();
```

This structure, along with the `STREAM_CONFIGURATION` and callback structures, is passed to `LiStartConnection()` to establish the actual streaming connection: moonlight-qt:1678-1685 

The `LiStartConnection()` function (from the moonlight-common-c library) uses:
- The RTSP session URL from `/launch` response to establish the RTSP control channel
- Server codec support from `/serverinfo` to negotiate video formats
- Stream configuration to set up video/audio decoders

### Validation Before Connection

Before calling `LiStartConnection()`, the session validates that the host supports the requested features by checking `m_Computer->serverCodecModeSupport` against the requested video formats. moonlight-qt:1117-1152  For example, it verifies YUV 4:4:4 support and adjusts the supported video formats list accordingly.<cite />

## Notes

The parsing happens in two stages: first during PC discovery (parsing `/serverinfo` into `NvComputer` properties), then during session start (parsing `/launch` response for RTSP URL). The `NvComputer` object acts as a bridge, storing server capabilities that are later referenced when configuring the `SERVER_INFORMATION` structure for `LiStartConnection()`. The actual XML parsing is handled by helper functions like `getXmlString()` in the `NvHTTP` class.

Wiki pages you might want to explore:
- [Settings View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.2)
- [Input Handling (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#4.7)
### Citations
**File:** app/backend/computermanager.cpp (L754-782)
```cpp
    QString fetchServerInfo(NvHTTP& http)
    {
        QString serverInfo;

        // Do nothing if we're quitting
        if (m_AboutToQuit) {
            return QString();
        }

        try {
            // There's a race condition between GameStream servers reporting presence over
            // mDNS and the HTTPS server being ready to respond to our queries. To work
            // around this issue, we will issue the request again after a few seconds if
            // we see a ServiceUnavailableError error.
            try {
                serverInfo = http.getServerInfo(NvHTTP::NVLL_VERBOSE);
            } catch (const QtNetworkReplyException& e) {
                if (e.getError() == QNetworkReply::ServiceUnavailableError) {
                    qWarning() << "Retrying request in 5 seconds after ServiceUnavailableError";
                    QThread::sleep(5);
                    serverInfo = http.getServerInfo(NvHTTP::NVLL_VERBOSE);
                    qInfo() << "Retry successful";
                }
                else {
                    // Rethrow other errors
                    throw e;
                }
            }
            return serverInfo;
```
**File:** app/backend/nvhttp.cpp (L189-236)
```cpp
void
NvHTTP::startApp(QString verb,
                 bool isGfe,
                 int appId,
                 PSTREAM_CONFIGURATION streamConfig,
                 bool sops,
                 bool localAudio,
                 int gamepadMask,
                 bool persistGameControllersOnDisconnect,
                 QString& rtspSessionUrl)
{
    int riKeyId;

    memcpy(&riKeyId, streamConfig->remoteInputAesIv, sizeof(riKeyId));
    riKeyId = qFromBigEndian(riKeyId);

    QString response =
            openConnectionToString(m_BaseUrlHttps,
                                   verb,
                                   "appid="+QString::number(appId)+
                                   "&mode="+QString::number(streamConfig->width)+"x"+
                                   QString::number(streamConfig->height)+"x"+
                                   // Using an FPS value over 60 causes SOPS to default to 720p60,
                                   // so force it to 0 to ensure the correct resolution is set. We
                                   // used to use 60 here but that locked the frame rate to 60 FPS
                                   // on GFE 3.20.3. We don't need this hack for Sunshine.
                                   QString::number((streamConfig->fps > 60 && isGfe) ? 0 : streamConfig->fps)+
                                   "&additionalStates=1&sops="+QString::number(sops ? 1 : 0)+
                                   "&rikey="+QByteArray(streamConfig->remoteInputAesKey, sizeof(streamConfig->remoteInputAesKey)).toHex()+
                                   "&rikeyid="+QString::number(riKeyId)+
                                   ((streamConfig->supportedVideoFormats & VIDEO_FORMAT_MASK_10BIT) ?
                                       "&hdrMode=1&clientHdrCapVersion=0&clientHdrCapSupportedFlagsInUint32=0&clientHdrCapMetaDataId=NV_STATIC_METADATA_TYPE_1&clientHdrCapDisplayData=0x0x0x0x0x0x0x0x0x0x0" :
                                        "")+
                                   "&localAudioPlayMode="+QString::number(localAudio ? 1 : 0)+
                                   "&surroundAudioInfo="+QString::number(SURROUNDAUDIOINFO_FROM_AUDIO_CONFIGURATION(streamConfig->audioConfiguration))+
                                   "&remoteControllersBitmap="+QString::number(gamepadMask)+
                                   "&gcmap="+QString::number(gamepadMask)+
                                   "&gcpersist="+QString::number(persistGameControllersOnDisconnect ? 1 : 0)+
                                   LiGetLaunchUrlQueryParameters(),
                                   LAUNCH_TIMEOUT_MS);

    qInfo() << "Launch response:" << response;

    // Throws if the request failed
    verifyResponseStatus(response);

    rtspSessionUrl = getXmlString(response, "sessionUrl0");
}
```
**File:** app/streaming/session.cpp (L1117-1152)
```cpp
    if (m_Preferences->enableYUV444) {
        if (!(m_Computer->serverCodecModeSupport & SCM_MASK_YUV444)) {
            emitLaunchWarning(tr("Your host PC doesn't support YUV 4:4:4 streaming."));
            m_SupportedVideoFormats.removeByMask(VIDEO_FORMAT_MASK_YUV444);
        }
        else {
            m_SupportedVideoFormats.removeByMask(~m_SupportedVideoFormats.maskByServerCodecModes(m_Computer->serverCodecModeSupport));

            if (!m_SupportedVideoFormats.isEmpty() &&
                !(m_SupportedVideoFormats.front() & VIDEO_FORMAT_MASK_YUV444)) {
                emitLaunchWarning(tr("Your host PC doesn't support YUV 4:4:4 streaming for selected video codec."));
            }
            else if (m_Preferences->videoDecoderSelection != StreamingPreferences::VDS_FORCE_SOFTWARE) {
                while (!m_SupportedVideoFormats.isEmpty() &&
                       (m_SupportedVideoFormats.front() & VIDEO_FORMAT_MASK_YUV444) &&
                       getDecoderAvailability(testWindow,
                                              m_Preferences->videoDecoderSelection,
                                              m_SupportedVideoFormats.front(),
                                              m_StreamConfig.width,
                                              m_StreamConfig.height,
                                              m_StreamConfig.fps) != DecoderAvailability::Hardware) {
                    if (m_Preferences->videoDecoderSelection == StreamingPreferences::VDS_FORCE_HARDWARE) {
                        m_SupportedVideoFormats.removeFirst();
                    }
                    else {
                        emitLaunchWarning(tr("Using software decoding due to your selection to force YUV 4:4:4 without GPU support. This may cause poor streaming performance."));
                        break;
                    }
                }
                if (!m_SupportedVideoFormats.isEmpty() &&
                    !(m_SupportedVideoFormats.front() & VIDEO_FORMAT_MASK_YUV444)) {
                    emitLaunchWarning(tr("This PC's GPU doesn't support YUV 4:4:4 decoding for selected video codec."));
                }
            }
        }
    }
```
**File:** app/streaming/session.cpp (L1602-1624)
```cpp
    QByteArray hostnameStr = m_Computer->activeAddress.address().toLatin1();
    QByteArray siAppVersion = m_Computer->appVersion.toLatin1();

    SERVER_INFORMATION hostInfo;
    hostInfo.address = hostnameStr.data();
    hostInfo.serverInfoAppVersion = siAppVersion.data();
    hostInfo.serverCodecModeSupport = m_Computer->serverCodecModeSupport;

    // Older GFE versions didn't have this field
    QByteArray siGfeVersion;
    if (!m_Computer->gfeVersion.isEmpty()) {
        siGfeVersion = m_Computer->gfeVersion.toLatin1();
    }
    if (!siGfeVersion.isEmpty()) {
        hostInfo.serverInfoGfeVersion = siGfeVersion.data();
    }

    // Older GFE and Sunshine versions didn't have this field
    QByteArray rtspSessionUrlStr;
    if (!rtspSessionUrl.isEmpty()) {
        rtspSessionUrlStr = rtspSessionUrl.toLatin1();
        hostInfo.rtspSessionUrl = rtspSessionUrlStr.data();
    }
```
**File:** app/streaming/session.cpp (L1678-1685)
```cpp
    int err = LiStartConnection(&hostInfo, &m_StreamConfig, &k_ConnCallbacks,
                                &m_VideoCallbacks, &m_AudioCallbacks,
                                NULL, 0, NULL, 0);
    if (err != 0) {
        // We already displayed an error dialog in the stage failure
        // listener.
        return false;
    }
```
## Q3
how to get "Remote input encryption keys"
### Answer
You're asking about how Moonlight generates the "Remote input encryption keys" that are sent to the host server during the `/launch` request.

## Answer

The remote input encryption keys (`rikey` and `rikeyid`) are randomly generated AES encryption keys used to secure input data sent from the client to the host during streaming. moonlight-qt:692-696 

### Key Generation

During session initialization in `Session::initialize()`, Moonlight generates these keys using OpenSSL's cryptographically secure random number generator:

```cpp
RAND_bytes(reinterpret_cast<unsigned char*>(m_StreamConfig.remoteInputAesKey),
           sizeof(m_StreamConfig.remoteInputAesKey));

// Only the first 4 bytes are populated in the RI key IV
RAND_bytes(reinterpret_cast<unsigned char*>(m_StreamConfig.remoteInputAesIv), 4);
``` moonlight-qt:692-696 

The `remoteInputAesKey` is a full AES key (16 bytes), while `remoteInputAesIv` only uses the first 4 bytes as an initialization vector. moonlight-qt:692-696 

### Sending Keys to Host

These generated keys are then sent to the host server when calling the `/launch` endpoint in `NvHTTP::startApp()`. moonlight-qt:200-218  The method:

1. Extracts the key ID from the IV by reading the first 4 bytes as a big-endian integer moonlight-qt:200-203 
2. Converts the AES key to hexadecimal format using `QByteArray(...).toHex()` moonlight-qt:217-217 
3. Includes both values as query parameters: `rikey=<hex_key>&rikeyid=<key_id>` moonlight-qt:217-218 

### Security Considerations

For security, these keys are automatically redacted from log files to prevent exposure. moonlight-qt:108-110  The logging system uses regex patterns to strip `rikey` and `rikeyid` values before writing to logs. moonlight-qt:88-88 

## Notes

The remote input encryption is part of Moonlight's security features to protect input data (keyboard, mouse, gamepad) transmitted during streaming. The keys are generated fresh for each streaming session and are stored in the `STREAM_CONFIGURATION` structure (`m_StreamConfig`) which is later passed to `LiStartConnection()` to establish the connection. moonlight-qt:1584-1593 

Wiki pages you might want to explore:
- [PC Discovery View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.1)
### Citations
**File:** app/streaming/session.cpp (L692-696)
```cpp
    RAND_bytes(reinterpret_cast<unsigned char*>(m_StreamConfig.remoteInputAesKey),
               sizeof(m_StreamConfig.remoteInputAesKey));

    // Only the first 4 bytes are populated in the RI key IV
    RAND_bytes(reinterpret_cast<unsigned char*>(m_StreamConfig.remoteInputAesIv), 4);
```
**File:** app/streaming/session.cpp (L1584-1593)
```cpp
    try {
        NvHTTP http(m_Computer);
        http.startApp(m_Computer->currentGameId != 0 ? "resume" : "launch",
                      m_Computer->isNvidiaServerSoftware,
                      m_App.id, &m_StreamConfig,
                      enableGameOptimizations,
                      m_Preferences->playAudioOnHost,
                      m_InputHandler->getAttachedGamepadMask(),
                      !m_Preferences->multiController,
                      rtspSessionUrl);
```
**File:** app/backend/nvhttp.cpp (L200-218)
```cpp
    int riKeyId;

    memcpy(&riKeyId, streamConfig->remoteInputAesIv, sizeof(riKeyId));
    riKeyId = qFromBigEndian(riKeyId);

    QString response =
            openConnectionToString(m_BaseUrlHttps,
                                   verb,
                                   "appid="+QString::number(appId)+
                                   "&mode="+QString::number(streamConfig->width)+"x"+
                                   QString::number(streamConfig->height)+"x"+
                                   // Using an FPS value over 60 causes SOPS to default to 720p60,
                                   // so force it to 0 to ensure the correct resolution is set. We
                                   // used to use 60 here but that locked the frame rate to 60 FPS
                                   // on GFE 3.20.3. We don't need this hack for Sunshine.
                                   QString::number((streamConfig->fps > 60 && isGfe) ? 0 : streamConfig->fps)+
                                   "&additionalStates=1&sops="+QString::number(sops ? 1 : 0)+
                                   "&rikey="+QByteArray(streamConfig->remoteInputAesKey, sizeof(streamConfig->remoteInputAesKey)).toHex()+
                                   "&rikeyid="+QString::number(riKeyId)+
```
**File:** app/main.cpp (L108-110)
```cpp
    // Strip session encryption keys and IVs from the logs
    message.replace(k_RikeyRegex, "&rikey=REDACTED");
    message.replace(k_RikeyIdRegex, "&rikeyid=REDACTED");
```
**File:** app/deploy/linux/com.moonlight_stream.Moonlight.appdata.xml (L88-88)
```text
					<li>Per-session keys (rikey and rikeyid values) are now automatically stripped from logs</li>
```
## Q4
<?xml version="1.0" encoding="utf-8"?>
<root status_code="200">
  <hostname>Html5syt</hostname>
  <appversion>7.1.431.-1</appversion>
<GfeVersion>3.23.0.74</GfeVersion>
  <uniqueid>F98186B1-DE02-2328-279E-0A461FBCEC47</uniqueid>
  <HttpsPort>47984</HttpsPort>
  <ExternalPort>47989</ExternalPort>
<MaxLumaPixelsHEVC>1869449984</MaxLumaPixelsHEVC>
  <mac>00:00:00:00:00:00</mac>
  <LocalIP>127.0.0.1</LocalIP>
  <ServerCodecModeSupport>257</ServerCodecModeSupport>
<PairStatus>0</PairStatus>
  <currentgame>1191261554</currentgame>
  <state>SUNSHINE_SERVER_BUSY</state>
</root>
This is a response from a serverinfo, please tell me which parameters are used to establish the connection in it?
### Answer
You're asking which parameters from the `/serverinfo` XML response are used when establishing a streaming connection in Moonlight.

## Answer

From the `/serverinfo` response you provided, the following parameters are used to establish the streaming connection:

### Parameters Used in Connection Establishment

**`ServerCodecModeSupport` (value: 257)** - This is stored in the `NvComputer` object and later passed to `LiStartConnection()` via the `SERVER_INFORMATION` structure. moonlight-qt:1608-1608  It indicates which video codecs and formats the host supports, and is used to negotiate the video format during connection setup. moonlight-qt:1608-1608 

**`appversion` (value: 7.1.431.-1)** - This is stored as `m_Computer->appVersion` and passed to `LiStartConnection()` as `hostInfo.serverInfoAppVersion`. moonlight-qt:1603-1607  The connection library uses this to determine host capabilities and compatibility. moonlight-qt:1603-1607 

**`GfeVersion` (value: 3.23.0.74)** - This is stored as `m_Computer->gfeVersion` and passed to `LiStartConnection()` as `hostInfo.serverInfoGfeVersion`. moonlight-qt:1611-1617  It's used to determine if the host is running GFE or Sunshine and adjust behavior accordingly. moonlight-qt:1560-1580 

**`LocalIP` (value: 127.0.0.1)** - The host's address is used to construct the base URLs for HTTP/HTTPS communication and is passed to `LiStartConnection()` as `hostInfo.address`. moonlight-qt:1602-1606 

**`HttpsPort` (value: 47984)** - Used to construct the HTTPS base URL for secure communication with the host, including the `/launch` endpoint call. moonlight-qt:173-177 

### Parameters NOT Directly Used in Connection

The following parameters are informational but not directly passed to the connection function:

- `hostname`, `uniqueid`, `ExternalPort`, `MaxLumaPixelsHEVC`, `mac` - These are stored in the `NvComputer` object for display and management purposes but aren't passed to `LiStartConnection()`.<cite />
- `PairStatus` - Used to determine if pairing is needed before streaming, but not used during connection establishment.<cite />
- `currentgame` and `state` - Used to determine if the host is already streaming, which affects whether to call `/launch` or `/resume`. moonlight-qt:1586-1586 

## Notes

The `state` value "SUNSHINE_SERVER_BUSY" indicates the host is currently streaming (as confirmed by the non-zero `currentgame` value). moonlight-qt:112-116  In this case, Moonlight would call `/resume` instead of `/launch` if you're trying to connect to the same game. moonlight-qt:1586-1586  The `ServerCodecModeSupport` value of 257 indicates support for H.264 (bit 0) and H.265/HEVC (bit 8).<cite />

Wiki pages you might want to explore:
- [PC Discovery View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.1)
### Citations
**File:** app/streaming/session.cpp (L1560-1580)
```cpp
    if (m_Computer->isNvidiaServerSoftware) {
        // GFE will set all settings to 720p60 if it doesn't recognize
        // the chosen resolution. Avoid that by disabling SOPS when it
        // is not streaming a supported resolution.
        enableGameOptimizations = false;
        for (const NvDisplayMode &mode : m_Computer->displayModes) {
            if (mode.width == m_StreamConfig.width &&
                    mode.height == m_StreamConfig.height) {
                SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION,
                            "Found host supported resolution: %dx%d",
                            mode.width, mode.height);
                enableGameOptimizations = m_Preferences->gameOptimizations;
                break;
            }
        }
    }
    else {
        // Always send SOPS to Sunshine because we may repurpose the
        // option to control whether the display mode is adjusted
        enableGameOptimizations = m_Preferences->gameOptimizations;
    }
```
**File:** app/streaming/session.cpp (L1586-1586)
```cpp
        http.startApp(m_Computer->currentGameId != 0 ? "resume" : "launch",
```
**File:** app/streaming/session.cpp (L1602-1607)
```cpp
    QByteArray hostnameStr = m_Computer->activeAddress.address().toLatin1();
    QByteArray siAppVersion = m_Computer->appVersion.toLatin1();

    SERVER_INFORMATION hostInfo;
    hostInfo.address = hostnameStr.data();
    hostInfo.serverInfoAppVersion = siAppVersion.data();
```
**File:** app/streaming/session.cpp (L1608-1608)
```cpp
    hostInfo.serverCodecModeSupport = m_Computer->serverCodecModeSupport;
```
**File:** app/streaming/session.cpp (L1611-1617)
```cpp
    QByteArray siGfeVersion;
    if (!m_Computer->gfeVersion.isEmpty()) {
        siGfeVersion = m_Computer->gfeVersion.toLatin1();
    }
    if (!siGfeVersion.isEmpty()) {
        hostInfo.serverInfoGfeVersion = siGfeVersion.data();
    }
```
**File:** app/backend/nvhttp.cpp (L112-116)
```cpp
    QString serverState = getXmlString(serverInfo, "state");
    if (serverState != nullptr && serverState.endsWith("_SERVER_BUSY"))
    {
        return getXmlString(serverInfo, "currentgame").toInt();
    }
```
**File:** app/backend/nvhttp.cpp (L173-177)
```cpp
        uint16_t httpsPort = getXmlString(serverInfo, "HttpsPort").toUShort();
        if (httpsPort == 0) {
            httpsPort = DEFAULT_HTTPS_PORT;
        }
        setHttpsPort(httpsPort);
```
## Q5
When I call the /launch interface, the server requires me to provide a client certificate. How can I obtain this certificate?
### Answer
Moonlight obtains and provides client certificates through a multi-step process involving certificate generation, pairing, and SSL configuration:

## Client Certificate Generation

When Moonlight first launches, the `IdentityManager` class automatically generates a self-signed 2048-bit RSA certificate and private key pair if none exist. moonlight-qt:29-110 

These credentials are stored persistently in QSettings and cached in memory for reuse. moonlight-qt:112-139 

## Attaching Certificates to Requests

For every HTTPS request (including `/launch`), Moonlight attaches the client certificate through the `IdentityManager::getSslConfig()` method, which returns a `QSslConfiguration` containing both the client certificate and private key. moonlight-qt:184-191 

This SSL configuration is applied to all network requests in the `openConnection` method via `request.setSslConfiguration()`. moonlight-qt:486-489 

## The `/launch` Interface Specifically

When the `startApp` method is called to launch a game, it makes an HTTPS request to the `/launch` endpoint using the base HTTPS URL. moonlight-qt:205-228 

This request goes through `openConnection`, which automatically includes the client certificate for mutual TLS authentication with the host server.

## Pairing Process for Mutual Trust

Before the client certificate can be used for authentication, a pairing process must occur. During pairing, the client sends its certificate to the server and receives the server's certificate in return. moonlight-qt:217-248 

The server certificate is then pinned and stored in the `NvComputer` object for future SSL validation. moonlight-qt:419-439 

## Certificate Validation

If there's an SSL handshake failure or certificate mismatch (error 401), Moonlight falls back to HTTP and can re-initiate pairing to obtain updated certificates. moonlight-qt:143-160 

## Notes

- The client certificate uses a common name of "NVIDIA GameStream Client" moonlight-qt:70-74 
- The certificate has a 20-year validity period moonlight-qt:51-66 
- The `/launch` endpoint uses a 120-second timeout compared to the standard 5-second timeout for other requests moonlight-qt:15-19 
- Certificate pinning prevents man-in-the-middle attacks by ensuring SSL errors are only ignored if they match the previously paired server certificate moonlight-qt:429-434
### Citations
**File:** app/backend/identitymanager.cpp (L29-110)
```cpp
void IdentityManager::createCredentials(QSettings& settings)
{
    X509* cert = X509_new();
    THROW_BAD_ALLOC_IF_NULL(cert);

    EVP_PKEY_CTX* ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_RSA, NULL);
    THROW_BAD_ALLOC_IF_NULL(ctx);

    EVP_PKEY_keygen_init(ctx);
    EVP_PKEY_CTX_set_rsa_keygen_bits(ctx, 2048);

    // pk must be initialized on input
    EVP_PKEY* pk = NULL;
    EVP_PKEY_keygen(ctx, &pk);

    EVP_PKEY_CTX_free(ctx);
    THROW_BAD_ALLOC_IF_NULL(pk);

    X509_set_version(cert, 2);
    ASN1_INTEGER_set(X509_get_serialNumber(cert), 0);
#if OPENSSL_VERSION_NUMBER < 0x10100000L
    X509_gmtime_adj(X509_get_notBefore(cert), 0);
    X509_gmtime_adj(X509_get_notAfter(cert), 60 * 60 * 24 * 365 * 20); // 20 yrs
#else
    ASN1_TIME* before = ASN1_STRING_dup(X509_get0_notBefore(cert));
    THROW_BAD_ALLOC_IF_NULL(before);
    ASN1_TIME* after = ASN1_STRING_dup(X509_get0_notAfter(cert));
    THROW_BAD_ALLOC_IF_NULL(after);

    X509_gmtime_adj(before, 0);
    X509_gmtime_adj(after, 60 * 60 * 24 * 365 * 20); // 20 yrs

    X509_set1_notBefore(cert, before);
    X509_set1_notAfter(cert, after);

    ASN1_STRING_free(before);
    ASN1_STRING_free(after);
#endif

    X509_set_pubkey(cert, pk);

    X509_NAME* name = X509_get_subject_name(cert);
    X509_NAME_add_entry_by_txt(name, "CN", MBSTRING_ASC,
                               reinterpret_cast<unsigned char *>(const_cast<char*>("NVIDIA GameStream Client")),
                               -1, -1, 0);
    X509_set_issuer_name(cert, name);

    X509_sign(cert, pk, EVP_sha256());

    BIO* biokey = BIO_new(BIO_s_mem());
    THROW_BAD_ALLOC_IF_NULL(biokey);
    PEM_write_bio_PrivateKey(biokey, pk, NULL, NULL, 0, NULL, NULL);

    BIO* biocert = BIO_new(BIO_s_mem());
    THROW_BAD_ALLOC_IF_NULL(biocert);
    PEM_write_bio_X509(biocert, cert);

    BUF_MEM* mem;
    BIO_get_mem_ptr(biokey, &mem);
    m_CachedPrivateKey = QByteArray(mem->data, (int)mem->length);

    BIO_get_mem_ptr(biocert, &mem);
    m_CachedPemCert = QByteArray(mem->data, (int)mem->length);

    X509_free(cert);
    EVP_PKEY_free(pk);
    BIO_free(biokey);
    BIO_free(biocert);

    // Check that the new keypair is valid before persisting it
    if (getSslCertificate().isNull()) {
        qFatal("Newly generated certificate is unreadable");
    }
    if (getSslKey().isNull()) {
        qFatal("Newly generated private key is unreadable");
    }

    settings.setValue(SER_CERT, m_CachedPemCert);
    settings.setValue(SER_KEY, m_CachedPrivateKey);

    qInfo() << "Wrote new identity credentials to settings";
}
```
**File:** app/backend/identitymanager.cpp (L112-139)
```cpp
IdentityManager::IdentityManager()
{
    QSettings settings;

    m_CachedPemCert = settings.value(SER_CERT).toByteArray();
    m_CachedPrivateKey = settings.value(SER_KEY).toByteArray();

    if (m_CachedPemCert.isEmpty() || m_CachedPrivateKey.isEmpty()) {
        qInfo() << "No existing credentials found";
        createCredentials(settings);
    }
    else if (getSslCertificate().isNull()) {
        qWarning() << "Certificate is unreadable";
        createCredentials(settings);
    }
    else if (getSslKey().isNull()) {
        qWarning() << "Private key is unreadable";
        createCredentials(settings);
    }

    // We should have valid credentials now. If not, we're screwed
    if (getSslCertificate().isNull()) {
        qFatal("Certificate is unreadable");
    }
    if (getSslKey().isNull()) {
        qFatal("Private key is unreadable");
    }
}
```
**File:** app/backend/identitymanager.cpp (L184-191)
```cpp
QSslConfiguration
IdentityManager::getSslConfig()
{
    QSslConfiguration sslConfig(QSslConfiguration::defaultConfiguration());
    sslConfig.setLocalCertificate(getSslCertificate());
    sslConfig.setPrivateKey(getSslKey());
    return sslConfig;
}
```
**File:** app/backend/nvhttp.cpp (L15-19)
```cpp
#define FAST_FAIL_TIMEOUT_MS 2000
#define REQUEST_TIMEOUT_MS 5000
#define LAUNCH_TIMEOUT_MS 120000
#define RESUME_TIMEOUT_MS 30000
#define QUIT_TIMEOUT_MS 30000
```
**File:** app/backend/nvhttp.cpp (L143-160)
```cpp
        catch (const GfeHttpResponseException& e)
        {
            if (e.getStatusCode() == 401)
            {
                // Certificate validation error, fallback to HTTP
                serverInfo = openConnectionToString(m_BaseUrlHttp,
                                                    "serverinfo",
                                                    nullptr,
                                                    fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                                    logLevel);
                verifyResponseStatus(serverInfo);
            }
            else
            {
                // Rethrow real errors
                throw e;
            }
        }
```
**File:** app/backend/nvhttp.cpp (L205-228)
```cpp
    QString response =
            openConnectionToString(m_BaseUrlHttps,
                                   verb,
                                   "appid="+QString::number(appId)+
                                   "&mode="+QString::number(streamConfig->width)+"x"+
                                   QString::number(streamConfig->height)+"x"+
                                   // Using an FPS value over 60 causes SOPS to default to 720p60,
                                   // so force it to 0 to ensure the correct resolution is set. We
                                   // used to use 60 here but that locked the frame rate to 60 FPS
                                   // on GFE 3.20.3. We don't need this hack for Sunshine.
                                   QString::number((streamConfig->fps > 60 && isGfe) ? 0 : streamConfig->fps)+
                                   "&additionalStates=1&sops="+QString::number(sops ? 1 : 0)+
                                   "&rikey="+QByteArray(streamConfig->remoteInputAesKey, sizeof(streamConfig->remoteInputAesKey)).toHex()+
                                   "&rikeyid="+QString::number(riKeyId)+
                                   ((streamConfig->supportedVideoFormats & VIDEO_FORMAT_MASK_10BIT) ?
                                       "&hdrMode=1&clientHdrCapVersion=0&clientHdrCapSupportedFlagsInUint32=0&clientHdrCapMetaDataId=NV_STATIC_METADATA_TYPE_1&clientHdrCapDisplayData=0x0x0x0x0x0x0x0x0x0x0" :
                                        "")+
                                   "&localAudioPlayMode="+QString::number(localAudio ? 1 : 0)+
                                   "&surroundAudioInfo="+QString::number(SURROUNDAUDIOINFO_FROM_AUDIO_CONFIGURATION(streamConfig->audioConfiguration))+
                                   "&remoteControllersBitmap="+QString::number(gamepadMask)+
                                   "&gcmap="+QString::number(gamepadMask)+
                                   "&gcpersist="+QString::number(persistGameControllersOnDisconnect ? 1 : 0)+
                                   LiGetLaunchUrlQueryParameters(),
                                   LAUNCH_TIMEOUT_MS);
```
**File:** app/backend/nvhttp.cpp (L419-439)
```cpp
void NvHTTP::handleSslErrors(QNetworkReply* reply, const QList<QSslError>& errors)
{
    bool ignoreErrors = true;

    if (m_ServerCert.isNull()) {
        // We should never make an HTTPS request without a cert
        Q_ASSERT(!m_ServerCert.isNull());
        return;
    }

    for (const QSslError& error : errors) {
        if (m_ServerCert != error.certificate()) {
            ignoreErrors = false;
            break;
        }
    }

    if (ignoreErrors) {
        reply->ignoreSslErrors(errors);
    }
}
```
**File:** app/backend/nvhttp.cpp (L486-489)
```cpp
    QNetworkRequest request(url);

    // Add our client certificate
    request.setSslConfiguration(IdentityManager::get()->getSslConfig());
```
**File:** app/backend/nvpairingmanager.cpp (L217-248)
```cpp
    QString getCert = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&phrase=getservercert&salt=" +
                                                    salt.toHex() + "&clientcert=" + IdentityManager::get()->getCertificate().toHex(),
                                                    0);
    NvHTTP::verifyResponseStatus(getCert);
    if (NvHTTP::getXmlString(getCert, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #1";
        return PairState::FAILED;
    }

    QByteArray serverCertStr = NvHTTP::getXmlStringFromHex(getCert, "plaincert");
    if (serverCertStr == nullptr)
    {
        qCritical() << "Server likely already pairing";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::ALREADY_IN_PROGRESS;
    }

    QSslCertificate unverifiedServerCert = QSslCertificate(serverCertStr);
    if (unverifiedServerCert.isNull()) {
        Q_ASSERT(!unverifiedServerCert.isNull());

        qCritical() << "Failed to parse plaincert";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    // Pin this cert for TLS until pairing is complete. If successful, we will propagate
    // the cert into the NvComputer object and persist it.
    m_Http.setServerCert(unverifiedServerCert);
```
## Q6
How to pair up computer?
### Answer
The pairing process in Moonlight uses a 5-phase handshake protocol to securely exchange certificates between the client and server. Here's how it works:

## Client Certificate Generation and Storage

The client certificate is a self-signed X.509 certificate that is generated when Moonlight first runs. It uses a 2048-bit RSA key pair with SHA-256 signature and has a 20-year validity period. moonlight-qt:29-110 

The certificate and private key are stored in QSettings and cached in memory for subsequent use. moonlight-qt:112-139 

## The 5-Phase Pairing Process

The pairing process is implemented in the `NvPairingManager::pair()` method: moonlight-qt:191-354 

### Phase 1: Certificate Exchange

The client sends its certificate to the server as a hex-encoded string in the `clientcert` parameter of an HTTP request. At the same time, it receives the server's certificate in the response: moonlight-qt:217-227 

The server returns its certificate in the `plaincert` field of the XML response: moonlight-qt:229-244 

### Phase 2-5: Challenge-Response Authentication

Once the server certificate is received, it is immediately pinned to the HTTP client for all subsequent HTTPS requests: moonlight-qt:246-248 

The remaining phases involve encrypted challenge-response exchanges and signature verification to authenticate both parties and validate the PIN.

## Certificate Pinning

The `setServerCert()` method stores the server certificate for use in HTTPS connections: moonlight-qt:43-46 

During HTTPS connections, the `handleSslErrors()` method verifies that the server certificate matches the pinned certificate, preventing man-in-the-middle attacks: moonlight-qt:419-439 

## Persisting the Server Certificate

After successful pairing, the server certificate is stored in the `NvComputer` object: moonlight-qt:113-113 

The certificate is then persisted to settings by calling `saveHost()`: moonlight-qt:599-603 

## Notes

The pairing process uses AES-128-ECB encryption for challenge exchanges, with the encryption key derived from a salted PIN hash (SHA-256 for Gen 7+ servers, SHA-1 for older versions). The client certificate is sent as plain hex-encoded PEM data in Phase 1, while the server certificate is also returned as hex-encoded PEM. This certificate exchange happens over HTTP initially, but all subsequent pairing phases use HTTPS with the newly pinned certificate to ensure secure communication.
### Citations
**File:** app/backend/identitymanager.cpp (L29-110)
```cpp
void IdentityManager::createCredentials(QSettings& settings)
{
    X509* cert = X509_new();
    THROW_BAD_ALLOC_IF_NULL(cert);

    EVP_PKEY_CTX* ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_RSA, NULL);
    THROW_BAD_ALLOC_IF_NULL(ctx);

    EVP_PKEY_keygen_init(ctx);
    EVP_PKEY_CTX_set_rsa_keygen_bits(ctx, 2048);

    // pk must be initialized on input
    EVP_PKEY* pk = NULL;
    EVP_PKEY_keygen(ctx, &pk);

    EVP_PKEY_CTX_free(ctx);
    THROW_BAD_ALLOC_IF_NULL(pk);

    X509_set_version(cert, 2);
    ASN1_INTEGER_set(X509_get_serialNumber(cert), 0);
#if OPENSSL_VERSION_NUMBER < 0x10100000L
    X509_gmtime_adj(X509_get_notBefore(cert), 0);
    X509_gmtime_adj(X509_get_notAfter(cert), 60 * 60 * 24 * 365 * 20); // 20 yrs
#else
    ASN1_TIME* before = ASN1_STRING_dup(X509_get0_notBefore(cert));
    THROW_BAD_ALLOC_IF_NULL(before);
    ASN1_TIME* after = ASN1_STRING_dup(X509_get0_notAfter(cert));
    THROW_BAD_ALLOC_IF_NULL(after);

    X509_gmtime_adj(before, 0);
    X509_gmtime_adj(after, 60 * 60 * 24 * 365 * 20); // 20 yrs

    X509_set1_notBefore(cert, before);
    X509_set1_notAfter(cert, after);

    ASN1_STRING_free(before);
    ASN1_STRING_free(after);
#endif

    X509_set_pubkey(cert, pk);

    X509_NAME* name = X509_get_subject_name(cert);
    X509_NAME_add_entry_by_txt(name, "CN", MBSTRING_ASC,
                               reinterpret_cast<unsigned char *>(const_cast<char*>("NVIDIA GameStream Client")),
                               -1, -1, 0);
    X509_set_issuer_name(cert, name);

    X509_sign(cert, pk, EVP_sha256());

    BIO* biokey = BIO_new(BIO_s_mem());
    THROW_BAD_ALLOC_IF_NULL(biokey);
    PEM_write_bio_PrivateKey(biokey, pk, NULL, NULL, 0, NULL, NULL);

    BIO* biocert = BIO_new(BIO_s_mem());
    THROW_BAD_ALLOC_IF_NULL(biocert);
    PEM_write_bio_X509(biocert, cert);

    BUF_MEM* mem;
    BIO_get_mem_ptr(biokey, &mem);
    m_CachedPrivateKey = QByteArray(mem->data, (int)mem->length);

    BIO_get_mem_ptr(biocert, &mem);
    m_CachedPemCert = QByteArray(mem->data, (int)mem->length);

    X509_free(cert);
    EVP_PKEY_free(pk);
    BIO_free(biokey);
    BIO_free(biocert);

    // Check that the new keypair is valid before persisting it
    if (getSslCertificate().isNull()) {
        qFatal("Newly generated certificate is unreadable");
    }
    if (getSslKey().isNull()) {
        qFatal("Newly generated private key is unreadable");
    }

    settings.setValue(SER_CERT, m_CachedPemCert);
    settings.setValue(SER_KEY, m_CachedPrivateKey);

    qInfo() << "Wrote new identity credentials to settings";
}
```
**File:** app/backend/identitymanager.cpp (L112-139)
```cpp
IdentityManager::IdentityManager()
{
    QSettings settings;

    m_CachedPemCert = settings.value(SER_CERT).toByteArray();
    m_CachedPrivateKey = settings.value(SER_KEY).toByteArray();

    if (m_CachedPemCert.isEmpty() || m_CachedPrivateKey.isEmpty()) {
        qInfo() << "No existing credentials found";
        createCredentials(settings);
    }
    else if (getSslCertificate().isNull()) {
        qWarning() << "Certificate is unreadable";
        createCredentials(settings);
    }
    else if (getSslKey().isNull()) {
        qWarning() << "Private key is unreadable";
        createCredentials(settings);
    }

    // We should have valid credentials now. If not, we're screwed
    if (getSslCertificate().isNull()) {
        qFatal("Certificate is unreadable");
    }
    if (getSslKey().isNull()) {
        qFatal("Private key is unreadable");
    }
}
```
**File:** app/backend/nvpairingmanager.cpp (L191-354)
```cpp
NvPairingManager::pair(QString appVersion, QString pin, QSslCertificate& serverCert)
{
    int serverMajorVersion = NvHTTP::parseQuad(appVersion).at(0);
    qInfo() << "Pairing with server generation:" << serverMajorVersion;

    QCryptographicHash::Algorithm hashAlgo;
    int hashLength;
    if (serverMajorVersion >= 7)
    {
        // Gen 7+ uses SHA-256 hashing
        hashAlgo = QCryptographicHash::Sha256;
        hashLength = 32;
    }
    else
    {
        // Prior to Gen 7 uses SHA-1 hashing
        hashAlgo = QCryptographicHash::Sha1;
        hashLength = 20;
    }

    QByteArray salt = generateRandomBytes(16);
    QByteArray saltedPin = saltPin(salt, pin);

    QByteArray aesKey = QCryptographicHash::hash(saltedPin, hashAlgo).constData();
    aesKey.truncate(16);

    QString getCert = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&phrase=getservercert&salt=" +
                                                    salt.toHex() + "&clientcert=" + IdentityManager::get()->getCertificate().toHex(),
                                                    0);
    NvHTTP::verifyResponseStatus(getCert);
    if (NvHTTP::getXmlString(getCert, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #1";
        return PairState::FAILED;
    }

    QByteArray serverCertStr = NvHTTP::getXmlStringFromHex(getCert, "plaincert");
    if (serverCertStr == nullptr)
    {
        qCritical() << "Server likely already pairing";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::ALREADY_IN_PROGRESS;
    }

    QSslCertificate unverifiedServerCert = QSslCertificate(serverCertStr);
    if (unverifiedServerCert.isNull()) {
        Q_ASSERT(!unverifiedServerCert.isNull());

        qCritical() << "Failed to parse plaincert";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    // Pin this cert for TLS until pairing is complete. If successful, we will propagate
    // the cert into the NvComputer object and persist it.
    m_Http.setServerCert(unverifiedServerCert);

    QByteArray randomChallenge = generateRandomBytes(16);
    QByteArray encryptedChallenge = encrypt(randomChallenge, aesKey);
    QString challengeXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                         "pair",
                                                         "devicename=roth&updateState=1&clientchallenge=" +
                                                         encryptedChallenge.toHex(),
                                                         REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(challengeXml);
    if (NvHTTP::getXmlString(challengeXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #2";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray challengeResponseData = decrypt(m_Http.getXmlStringFromHex(challengeXml, "challengeresponse"), aesKey);
    QByteArray clientSecretData = generateRandomBytes(16);
    QByteArray challengeResponse;
    QByteArray serverResponse(challengeResponseData.data(), hashLength);

#if (OPENSSL_VERSION_NUMBER < 0x10002000L)
    ASN1_BIT_STRING *asnSignature = m_Cert->signature;
#elif (OPENSSL_VERSION_NUMBER < 0x10100000L)
    ASN1_BIT_STRING *asnSignature;
    X509_get0_signature(&asnSignature, NULL, m_Cert);
#else
    const ASN1_BIT_STRING *asnSignature;
    X509_get0_signature(&asnSignature, NULL, m_Cert);
#endif

    challengeResponse.append(challengeResponseData.data() + hashLength, 16);
    challengeResponse.append(reinterpret_cast<char*>(asnSignature->data), asnSignature->length);
    challengeResponse.append(clientSecretData);

    QByteArray paddedHash = QCryptographicHash::hash(challengeResponse, hashAlgo);
    paddedHash.resize(32);
    QByteArray encryptedChallengeResponseHash = encrypt(paddedHash, aesKey);
    QString respXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&serverchallengeresp=" +
                                                    encryptedChallengeResponseHash.toHex(),
                                                    REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(respXml);
    if (NvHTTP::getXmlString(respXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #3";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray pairingSecret = NvHTTP::getXmlStringFromHex(respXml, "pairingsecret");
    QByteArray serverSecret = pairingSecret.left(16);
    QByteArray serverSignature = pairingSecret.mid(16);

    if (!verifySignature(serverSecret,
                         serverSignature,
                         serverCertStr))
    {
        qCritical() << "MITM detected";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray expectedResponseData;
    expectedResponseData.append(randomChallenge);
    expectedResponseData.append(getSignatureFromPemCert(serverCertStr));
    expectedResponseData.append(serverSecret);
    if (QCryptographicHash::hash(expectedResponseData, hashAlgo) != serverResponse)
    {
        qCritical() << "Incorrect PIN";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::PIN_WRONG;
    }

    QByteArray clientPairingSecret;
    clientPairingSecret.append(clientSecretData);
    clientPairingSecret.append(signMessage(clientSecretData));

    QString secretRespXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                          "pair",
                                                          "devicename=roth&updateState=1&clientpairingsecret=" +
                                                          clientPairingSecret.toHex(),
                                                          REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(secretRespXml);
    if (NvHTTP::getXmlString(secretRespXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #4";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QString pairChallengeXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttps,
                                                             "pair",
                                                             "devicename=roth&updateState=1&phrase=pairchallenge",
                                                             REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(pairChallengeXml);
    if (NvHTTP::getXmlString(pairChallengeXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #5";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    serverCert = std::move(unverifiedServerCert);
    return PairState::PAIRED;
```
**File:** app/backend/nvhttp.cpp (L43-46)
```cpp
void NvHTTP::setServerCert(QSslCertificate serverCert)
{
    m_ServerCert = serverCert;
}
```
**File:** app/backend/nvhttp.cpp (L419-439)
```cpp
void NvHTTP::handleSslErrors(QNetworkReply* reply, const QList<QSslError>& errors)
{
    bool ignoreErrors = true;

    if (m_ServerCert.isNull()) {
        // We should never make an HTTPS request without a cert
        Q_ASSERT(!m_ServerCert.isNull());
        return;
    }

    for (const QSslError& error : errors) {
        if (m_ServerCert != error.certificate()) {
            ignoreErrors = false;
            break;
        }
    }

    if (ignoreErrors) {
        reply->ignoreSslErrors(errors);
    }
}
```
**File:** app/backend/nvcomputer.h (L113-113)
```text
    QSslCertificate serverCert;
```
**File:** app/backend/computermanager.cpp (L599-603)
```cpp
           case NvPairingManager::PairState::PAIRED:
               // Persist the newly pinned server certificate for this host
               m_ComputerManager->saveHost(m_Computer);

               emit pairingCompleted(m_Computer, nullptr);
```
## Q7
When the client has launched/started the game and begun streaming before disconnecting, how does the client recover the connection?
### Answer
You're asking about how Moonlight handles connection recovery when a streaming session disconnects after it has already started.

## Answer

When a streaming session disconnects, Moonlight determines whether to call `/launch` or `/resume` based on the `currentgame` value from the host's `/serverinfo` response. moonlight-qt:1586-1586 

### Resume vs Launch Decision

In `Session::startConnectionAsync()`, the code checks if `m_Computer->currentgame` is non-zero (indicating a game is already running on the host): moonlight-qt:1556-1557 

If the game is already running, it calls `NvHTTP::startApp()` with the `"resume"` parameter instead of `"launch"`: moonlight-qt:1586-1593 

```cpp
http.startApp(m_Computer->currentgame != 0 ? "resume" : "launch",
              m_Computer->isNvidiaServerSoftware,
              m_App.id, &m_StreamConfig,
              enableGameOptimizations,
              m_Preferences->playAudioOnHost,
              m_InputHandler->getAttachedGamepadMask(),
              !m_Preferences->multiController,
              rtspSessionUrl);
```

### How Resume Works

The `/resume` endpoint tells the host to reconnect to an existing game session rather than starting a new one.<cite /> This preserves the game state and allows the client to rejoin the same streaming session.<cite />

The same connection establishment process follows after calling `/resume` - the RTSP session URL is obtained from the response and passed to `LiStartConnection()` to establish the streaming connection. moonlight-qt:1678-1680 

### State Detection

The host's state is tracked through periodic `/serverinfo` polling, which updates the `currentgame` field in the `NvComputer` object.<cite /> When the state shows `SUNSHINE_SERVER_BUSY` (as in your earlier example) with a non-zero `currentgame` value, Moonlight knows a game is already running and will use resume instead of launch.<cite />

## Notes

The resume functionality allows seamless reconnection to an existing game session without restarting the game on the host. This is particularly useful for temporary network interruptions or when the client application crashes but the host game continues running. The same certificate authentication and connection establishment process is used for both launch and resume operations.

Wiki pages you might want to explore:
- [User Interface System (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2)
- [Streaming Core (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#4)
### Citations
**File:** app/streaming/session.cpp (L1556-1557)
```cpp
    Q_ASSERT(m_Computer->currentGameId == 0 ||
             m_Computer->currentGameId == m_App.id);
```
**File:** app/streaming/session.cpp (L1586-1593)
```cpp
        http.startApp(m_Computer->currentGameId != 0 ? "resume" : "launch",
                      m_Computer->isNvidiaServerSoftware,
                      m_App.id, &m_StreamConfig,
                      enableGameOptimizations,
                      m_Preferences->playAudioOnHost,
                      m_InputHandler->getAttachedGamepadMask(),
                      !m_Preferences->multiController,
                      rtspSessionUrl);
```
**File:** app/streaming/session.cpp (L1678-1680)
```cpp
    int err = LiStartConnection(&hostInfo, &m_StreamConfig, &k_ConnCallbacks,
                                &m_VideoCallbacks, &m_AudioCallbacks,
                                NULL, 0, NULL, 0);
```
## Q8
How does the client terminate the connection?
### Answer
You're asking about how Moonlight terminates a streaming connection when the user wants to disconnect.

## Answer

Moonlight provides multiple ways to terminate a streaming connection:

### User-Initiated Disconnection

Users can disconnect from an active streaming session using keyboard shortcuts or gamepad button combinations. The UI displays a tip showing these options: **Ctrl+Alt+Shift+Q** for keyboard or **Start+Select+L1+R1** for gamepad. moonlight-qt:167-168 

### Connection Termination Flow

When a connection terminates, the `Session::clConnectionTerminated()` callback is invoked with an error code. moonlight-qt:98-155  This callback:

1. **Performs port testing** to diagnose connectivity issues if the termination was unexpected moonlight-qt:100-101 

2. **Determines if termination was graceful** - If the error code is `ML_ERROR_GRACEFUL_TERMINATION`, no error dialog is shown moonlight-qt:105-106 

3. **Displays error messages** for unexpected terminations (network issues, video encoding errors, etc.) moonlight-qt:108-144 

4. **Pushes a quit event** to the SDL event loop to exit the streaming session moonlight-qt:150-154 

### UI Cleanup After Termination

After the session ends, the `StreamSegue::sessionFinished()` method handles cleanup: moonlight-qt:73-108 

1. **Re-enables gamepad navigation** for the UI moonlight-qt:79-80 

2. **Pops the stream view** from the navigation stack to return to the previous screen moonlight-qt:93-94 

3. **Shows the main window** again moonlight-qt:96-97 

4. **Displays any error dialogs** if the termination was unexpected moonlight-qt:103-106 

The session object is then garbage collected to free resources. moonlight-qt:110-116 

### Quitting Running Apps

Moonlight can also terminate a running game on the host without streaming it. The `ComputerManager::quitRunningApp()` method creates a `PendingQuitTask` that sends a quit request to the host server. moonlight-qt:675-682  This is used when users want to stop a game remotely without connecting to it.

## Notes

The termination process distinguishes between graceful disconnections (user-initiated) and unexpected terminations (network errors, encoding failures). For unexpected terminations, Moonlight performs network diagnostics and displays helpful error messages to guide troubleshooting. The same cleanup process applies whether the user disconnects manually or the connection fails unexpectedly.

Wiki pages you might want to explore:
- [User Interface System (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2)
- [PC Discovery View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.1)
### Citations
**File:** app/gui/StreamSegue.qml (L73-108)
```text
    function sessionFinished(portTestResult)
    {
        if (portTestResult !== 0 && portTestResult !== -1 && streamSegueErrorDialog.text) {
            streamSegueErrorDialog.text += "\n\n" + qsTr("This PC's Internet connection is blocking Moonlight. Streaming over the Internet may not work while connected to this network.")
        }

        // Re-enable GUI gamepad usage now
        SdlGamepadKeyNavigation.enable()

        if (quitAfter) {
            if (streamSegueErrorDialog.text) {
                // Quit when the error dialog is acknowledged
                streamSegueErrorDialog.quitAfter = quitAfter
                streamSegueErrorDialog.open()
            }
            else {
                // Quit immediately
                Qt.quit()
            }
        } else {
            // Exit this view
            stackView.pop()

            // Show the Qt window again after streaming
            window.visible = true

            // Display any launch errors. We do this after
            // the Qt UI is visible again to prevent losing
            // focus on the dialog which would impact gamepad
            // users.
            if (streamSegueErrorDialog.text) {
                streamSegueErrorDialog.quitAfter = quitAfter
                streamSegueErrorDialog.open()
            }
        }
    }
```
**File:** app/gui/StreamSegue.qml (L110-116)
```text
    function sessionReadyForDeletion()
    {
        // Garbage collect the Session object since it's pretty heavyweight
        // and keeps other libraries (like SDL_TTF) around until it is deleted.
        session = null
        gc()
    }
```
**File:** app/gui/StreamSegue.qml (L167-168)
```text
            hintText.text = qsTr("Tip:") + " " + qsTr("Press %1 to disconnect your session").arg(SdlGamepadKeyNavigation.getConnectedGamepads() > 0 ?
                                                  qsTr("Start+Select+L1+R1") : qsTr("Ctrl+Alt+Shift+Q"))
```
**File:** app/streaming/session.cpp (L98-155)
```cpp
void Session::clConnectionTerminated(int errorCode)
{
    unsigned int portFlags = LiGetPortFlagsFromTerminationErrorCode(errorCode);
    s_ActiveSession->m_PortTestResults = LiTestClientConnectivity(CONN_TEST_SERVER, 443, portFlags);

    // Display the termination dialog if this was not intended
    switch (errorCode) {
    case ML_ERROR_GRACEFUL_TERMINATION:
        break;

    case ML_ERROR_NO_VIDEO_TRAFFIC:
        s_ActiveSession->m_UnexpectedTermination = true;

        char ports[128];
        SDL_assert(portFlags != 0);
        LiStringifyPortFlags(portFlags, ", ", ports, sizeof(ports));
        emit s_ActiveSession->displayLaunchError(tr("No video received from host.") + "\n\n"+
                                                 tr("Check your firewall and port forwarding rules for port(s): %1").arg(ports));
        break;

    case ML_ERROR_NO_VIDEO_FRAME:
        s_ActiveSession->m_UnexpectedTermination = true;
        emit s_ActiveSession->displayLaunchError(tr("Your network connection isn't performing well. Reduce your video bitrate setting or try a faster connection."));
        break;

    case ML_ERROR_PROTECTED_CONTENT:
    case ML_ERROR_UNEXPECTED_EARLY_TERMINATION:
        s_ActiveSession->m_UnexpectedTermination = true;
        emit s_ActiveSession->displayLaunchError(tr("Something went wrong on your host PC when starting the stream.") + "\n\n" +
                                                 tr("Make sure you don't have any DRM-protected content open on your host PC. You can also try restarting your host PC."));
        break;

    case ML_ERROR_FRAME_CONVERSION:
        s_ActiveSession->m_UnexpectedTermination = true;
        emit s_ActiveSession->displayLaunchError(tr("The host PC reported a fatal video encoding error.") + "\n\n" +
                                                 tr("Try disabling HDR mode, changing the streaming resolution, or changing your host PC's display resolution."));
        break;

    default:
        s_ActiveSession->m_UnexpectedTermination = true;

        // We'll assume large errors are hex values
        bool hexError = qAbs(errorCode) > 1000;
        emit s_ActiveSession->displayLaunchError(tr("Connection terminated") + "\n\n" +
                                                 tr("Error code: %1").arg(errorCode, hexError ? 8 : 0, hexError ? 16 : 10, QChar('0')));
        break;
    }

    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION,
                 "Connection terminated: %d",
                 errorCode);

    // Push a quit event to the main loop
    SDL_Event event;
    event.type = SDL_QUIT;
    event.quit.timestamp = SDL_GetTicks();
    SDL_PushEvent(&event);
}
```
**File:** app/backend/computermanager.cpp (L675-682)
```cpp
void ComputerManager::quitRunningApp(NvComputer* computer)
{
    QWriteLocker lock(&computer->lock);
    computer->pendingQuit = true;

    PendingQuitTask* quit = new PendingQuitTask(this, computer);
    QThreadPool::globalInstance()->start(quit);
}
```
## Q9
Please list all the APIs used for the client and server interaction, including their purposes and required parameters, and list the APIs needed for the entire process from adding a computer to selecting one in the app list and starting a connection to ending the connection.
### Answer
Based on my analysis of the Moonlight codebase, here are all the client-server interaction APIs used throughout the entire process:

## 1. **Adding a Computer**

### Server Discovery - `serverinfo` API
**Purpose**: Discover and retrieve information about the host PC, including pairing status, current game, server version, and HTTPS port. moonlight-qt:124-187 

**Required Parameters**:
- `uniqueid`: Common UID for Moonlight clients (fixed: "0123456789ABCDEF")
- `uuid`: Random UUID for the request

**Protocol**: HTTP initially (before pairing), then HTTPS (after pairing)

### Pairing - 5-Phase Cryptographic Handshake

**Purpose**: Establish trust between client and host PC through certificate exchange and PIN verification. moonlight-qt:191-355 

**Phase 1 - Get Server Certificate**:
- Endpoint: `pair`
- Parameters:
  - `devicename=roth`
  - `updateState=1`
  - `phrase=getservercert`
  - `salt`: 16-byte random salt (hex)
  - `clientcert`: Client certificate (hex)

**Phase 2 - Client Challenge**:
- Endpoint: `pair`
- Parameters:
  - `devicename=roth`
  - `updateState=1`
  - `clientchallenge`: Encrypted 16-byte challenge (hex)

**Phase 3 - Server Challenge Response**:
- Endpoint: `pair`
- Parameters:
  - `devicename=roth`
  - `updateState=1`
  - `serverchallengeresp`: Encrypted challenge response hash (hex)

**Phase 4 - Client Pairing Secret**:
- Endpoint: `pair`
- Parameters:
  - `devicename=roth`
  - `updateState=1`
  - `clientpairingsecret`: Client secret + signature (hex)

**Phase 5 - Final Challenge (HTTPS)**:
- Endpoint: `pair`
- Parameters:
  - `devicename=roth`
  - `updateState=1`
  - `phrase=pairchallenge`

**Protocol**: HTTP for phases 1-4, HTTPS for phase 5

## 2. **Selecting an App**

### App List - `applist` API
**Purpose**: Retrieve the list of available applications on the host PC. moonlight-qt:288-328 

**Required Parameters**:
- `uniqueid`: "0123456789ABCDEF"
- `uuid`: Random UUID

**Protocol**: HTTPS (requires prior pairing)

**Response**: XML with app information including:
- `AppTitle`: Application name
- `ID`: Application ID
- `IsHdrSupported`: HDR capability
- `IsAppCollectorGame`: Whether it's an App Collector game

### Box Art - `getBoxArt` API
**Purpose**: Download application cover art/thumbnails. moonlight-qt:178-179 moonlight-qt:107-129 

**Required Parameters**:
- `appId`: Application ID

**Protocol**: HTTPS
**Response**: Image data (various formats, cached as PNG locally)

## 3. **Starting a Streaming Connection**

### Launch/Resume - `launch` or `resume` API
**Purpose**: Start a new streaming session or resume an existing one. moonlight-qt:190-236 moonlight-qt:1582-1600 

**Endpoint**: `launch` (new session) or `resume` (existing session)

**Required Parameters**:
- `uniqueid`: "0123456789ABCDEF"
- `uuid`: Random UUID
- `appid`: Application ID to launch
- `mode`: Resolution and FPS (format: `{width}x{height}x{fps}`)
- `additionalStates=1`: Enable additional states
- `sops`: Stream optimization settings (0 or 1)
- `rikey`: Remote input AES key (hex)
- `rikeyid`: Remote input key ID
- `hdrMode`: HDR mode flag (included if HDR supported)
- `clientHdrCapVersion`, `clientHdrCapSupportedFlagsInUint32`, `clientHdrCapMetaDataId`, `clientHdrCapDisplayData`: HDR capability parameters (if HDR mode)
- `localAudioPlayMode`: Play audio on host (0 or 1)
- `surroundAudioInfo`: Surround audio configuration
- `remoteControllersBitmap`: Gamepad mask
- `gcmap`: Gamepad controller map
- `gcpersist`: Persist game controllers on disconnect (0 or 1)
- Additional parameters from `LiGetLaunchUrlQueryParameters()`

**Protocol**: HTTPS

**Response**: XML containing `sessionUrl0` (RTSP session URL)

**Decision Logic**: The verb is determined based on whether a game is currently running: moonlight-qt:1586-1593 

## 4. **Ending a Streaming Connection**

### Quit App - `cancel` API
**Purpose**: Terminate the currently running application on the host PC. moonlight-qt:238-259 

**Required Parameters**:
- `uniqueid`: "0123456789ABCDEF"
- `uuid`: Random UUID

**Protocol**: HTTPS

**Timeout**: 30 seconds

**Note**: The quit operation is optional based on user preferences: moonlight-qt:1554-1558 

## Additional APIs

### Wake-on-LAN
**Purpose**: Wake up a sleeping/powered-off host PC. moonlight-qt:1-50 

**Protocol**: UDP magic packets sent to multiple addresses and ports (9, 47009, and dynamic ports 47998-48010)

### Unpair - `unpair` API
**Purpose**: Remove pairing relationship (used during pairing failures). moonlight-qt:232-234 

**Required Parameters**: Standard uniqueid and uuid

**Protocol**: HTTP

## Notes

- All HTTP/HTTPS requests use a common `uniqueid` of "0123456789ABCDEF" to allow Moonlight clients to manage each other's sessions
- Each request includes a random `uuid` parameter generated via `QUuid::createUuid()`
- Certificate pinning is implemented for HTTPS connections to prevent MITM attacks
- Timeouts vary by operation: 2s (fast-fail), 5s (normal), 30s (resume/quit), 120s (launch)
- The base URL format is `http(s)://{host}:{port}/{command}?{parameters}`
### Citations
**File:** app/backend/nvhttp.cpp (L124-187)
```cpp
NvHTTP::getServerInfo(NvLogLevel logLevel, bool fastFail)
{
    QString serverInfo;

    // Check if we have a pinned cert and HTTPS port for this host yet
    if (!m_ServerCert.isNull() && httpsPort() != 0)
    {
        try
        {
            // Always try HTTPS first, since it properly reports
            // pairing status (and a few other attributes).
            serverInfo = openConnectionToString(m_BaseUrlHttps,
                                                "serverinfo",
                                                nullptr,
                                                fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                                logLevel);
            // Throws if the request failed
            verifyResponseStatus(serverInfo);
        }
        catch (const GfeHttpResponseException& e)
        {
            if (e.getStatusCode() == 401)
            {
                // Certificate validation error, fallback to HTTP
                serverInfo = openConnectionToString(m_BaseUrlHttp,
                                                    "serverinfo",
                                                    nullptr,
                                                    fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                                    logLevel);
                verifyResponseStatus(serverInfo);
            }
            else
            {
                // Rethrow real errors
                throw e;
            }
        }
    }
    else
    {
        // Only use HTTP prior to pairing or fetching HTTPS port
        serverInfo = openConnectionToString(m_BaseUrlHttp,
                                            "serverinfo",
                                            nullptr,
                                            fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                            logLevel);
        verifyResponseStatus(serverInfo);

        // Populate the HTTPS port
        uint16_t httpsPort = getXmlString(serverInfo, "HttpsPort").toUShort();
        if (httpsPort == 0) {
            httpsPort = DEFAULT_HTTPS_PORT;
        }
        setHttpsPort(httpsPort);

        // If we just needed to determine the HTTPS port, we'll try again over
        // HTTPS now that we have the port number
        if (!m_ServerCert.isNull()) {
            return getServerInfo(logLevel, fastFail);
        }
    }

    return serverInfo;
}
```
**File:** app/backend/nvhttp.cpp (L190-236)
```cpp
NvHTTP::startApp(QString verb,
                 bool isGfe,
                 int appId,
                 PSTREAM_CONFIGURATION streamConfig,
                 bool sops,
                 bool localAudio,
                 int gamepadMask,
                 bool persistGameControllersOnDisconnect,
                 QString& rtspSessionUrl)
{
    int riKeyId;

    memcpy(&riKeyId, streamConfig->remoteInputAesIv, sizeof(riKeyId));
    riKeyId = qFromBigEndian(riKeyId);

    QString response =
            openConnectionToString(m_BaseUrlHttps,
                                   verb,
                                   "appid="+QString::number(appId)+
                                   "&mode="+QString::number(streamConfig->width)+"x"+
                                   QString::number(streamConfig->height)+"x"+
                                   // Using an FPS value over 60 causes SOPS to default to 720p60,
                                   // so force it to 0 to ensure the correct resolution is set. We
                                   // used to use 60 here but that locked the frame rate to 60 FPS
                                   // on GFE 3.20.3. We don't need this hack for Sunshine.
                                   QString::number((streamConfig->fps > 60 && isGfe) ? 0 : streamConfig->fps)+
                                   "&additionalStates=1&sops="+QString::number(sops ? 1 : 0)+
                                   "&rikey="+QByteArray(streamConfig->remoteInputAesKey, sizeof(streamConfig->remoteInputAesKey)).toHex()+
                                   "&rikeyid="+QString::number(riKeyId)+
                                   ((streamConfig->supportedVideoFormats & VIDEO_FORMAT_MASK_10BIT) ?
                                       "&hdrMode=1&clientHdrCapVersion=0&clientHdrCapSupportedFlagsInUint32=0&clientHdrCapMetaDataId=NV_STATIC_METADATA_TYPE_1&clientHdrCapDisplayData=0x0x0x0x0x0x0x0x0x0x0" :
                                        "")+
                                   "&localAudioPlayMode="+QString::number(localAudio ? 1 : 0)+
                                   "&surroundAudioInfo="+QString::number(SURROUNDAUDIOINFO_FROM_AUDIO_CONFIGURATION(streamConfig->audioConfiguration))+
                                   "&remoteControllersBitmap="+QString::number(gamepadMask)+
                                   "&gcmap="+QString::number(gamepadMask)+
                                   "&gcpersist="+QString::number(persistGameControllersOnDisconnect ? 1 : 0)+
                                   LiGetLaunchUrlQueryParameters(),
                                   LAUNCH_TIMEOUT_MS);

    qInfo() << "Launch response:" << response;

    // Throws if the request failed
    verifyResponseStatus(response);

    rtspSessionUrl = getXmlString(response, "sessionUrl0");
}
```
**File:** app/backend/nvhttp.cpp (L238-259)
```cpp
void
NvHTTP::quitApp()
{
    QString response =
            openConnectionToString(m_BaseUrlHttps,
                                   "cancel",
                                   nullptr,
                                   QUIT_TIMEOUT_MS);

    qInfo() << "Quit response:" << response;

    // Throws if the request failed
    verifyResponseStatus(response);

    // Newer GFE versions will just return success even if quitting fails
    // if we're not the original requester.
    if (getCurrentGame(getServerInfo(NvHTTP::NVLL_ERROR)) != 0) {
        // Generate a synthetic GfeResponseException letting the caller know
        // that they can't kill someone else's stream.
        throw GfeHttpResponseException(599, "");
    }
}
```
**File:** app/backend/nvhttp.cpp (L288-328)
```cpp
QVector<NvApp>
NvHTTP::getAppList()
{
    QString appxml = openConnectionToString(m_BaseUrlHttps,
                                            "applist",
                                            nullptr,
                                            REQUEST_TIMEOUT_MS,
                                            NvLogLevel::NVLL_ERROR);
    verifyResponseStatus(appxml);

    QXmlStreamReader xmlReader(appxml);
    QVector<NvApp> apps;
    while (!xmlReader.atEnd()) {
        while (xmlReader.readNextStartElement()) {
            auto name = xmlReader.name();
            if (name == QString("App")) {
                // We must have a valid app before advancing to the next one
                if (!apps.isEmpty() && !apps.last().isInitialized()) {
                    qWarning() << "Invalid applist XML";
                    Q_ASSERT(false);
                    return QVector<NvApp>();
                }
                apps.append(NvApp());
            }
            else if (name == QString("AppTitle")) {
                apps.last().name = xmlReader.readElementText();
            }
            else if (name == QString("ID")) {
                apps.last().id = xmlReader.readElementText().toInt();
            }
            else if (name == QString("IsHdrSupported")) {
                apps.last().hdrSupported = xmlReader.readElementText() == "1";
            }
            else if (name == QString("IsAppCollectorGame")) {
                apps.last().isAppCollectorGame = xmlReader.readElementText() == "1";
            }
        }
    }

    return apps;
}
```
**File:** app/backend/nvpairingmanager.cpp (L191-355)
```cpp
NvPairingManager::pair(QString appVersion, QString pin, QSslCertificate& serverCert)
{
    int serverMajorVersion = NvHTTP::parseQuad(appVersion).at(0);
    qInfo() << "Pairing with server generation:" << serverMajorVersion;

    QCryptographicHash::Algorithm hashAlgo;
    int hashLength;
    if (serverMajorVersion >= 7)
    {
        // Gen 7+ uses SHA-256 hashing
        hashAlgo = QCryptographicHash::Sha256;
        hashLength = 32;
    }
    else
    {
        // Prior to Gen 7 uses SHA-1 hashing
        hashAlgo = QCryptographicHash::Sha1;
        hashLength = 20;
    }

    QByteArray salt = generateRandomBytes(16);
    QByteArray saltedPin = saltPin(salt, pin);

    QByteArray aesKey = QCryptographicHash::hash(saltedPin, hashAlgo).constData();
    aesKey.truncate(16);

    QString getCert = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&phrase=getservercert&salt=" +
                                                    salt.toHex() + "&clientcert=" + IdentityManager::get()->getCertificate().toHex(),
                                                    0);
    NvHTTP::verifyResponseStatus(getCert);
    if (NvHTTP::getXmlString(getCert, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #1";
        return PairState::FAILED;
    }

    QByteArray serverCertStr = NvHTTP::getXmlStringFromHex(getCert, "plaincert");
    if (serverCertStr == nullptr)
    {
        qCritical() << "Server likely already pairing";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::ALREADY_IN_PROGRESS;
    }

    QSslCertificate unverifiedServerCert = QSslCertificate(serverCertStr);
    if (unverifiedServerCert.isNull()) {
        Q_ASSERT(!unverifiedServerCert.isNull());

        qCritical() << "Failed to parse plaincert";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    // Pin this cert for TLS until pairing is complete. If successful, we will propagate
    // the cert into the NvComputer object and persist it.
    m_Http.setServerCert(unverifiedServerCert);

    QByteArray randomChallenge = generateRandomBytes(16);
    QByteArray encryptedChallenge = encrypt(randomChallenge, aesKey);
    QString challengeXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                         "pair",
                                                         "devicename=roth&updateState=1&clientchallenge=" +
                                                         encryptedChallenge.toHex(),
                                                         REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(challengeXml);
    if (NvHTTP::getXmlString(challengeXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #2";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray challengeResponseData = decrypt(m_Http.getXmlStringFromHex(challengeXml, "challengeresponse"), aesKey);
    QByteArray clientSecretData = generateRandomBytes(16);
    QByteArray challengeResponse;
    QByteArray serverResponse(challengeResponseData.data(), hashLength);

#if (OPENSSL_VERSION_NUMBER < 0x10002000L)
    ASN1_BIT_STRING *asnSignature = m_Cert->signature;
#elif (OPENSSL_VERSION_NUMBER < 0x10100000L)
    ASN1_BIT_STRING *asnSignature;
    X509_get0_signature(&asnSignature, NULL, m_Cert);
#else
    const ASN1_BIT_STRING *asnSignature;
    X509_get0_signature(&asnSignature, NULL, m_Cert);
#endif

    challengeResponse.append(challengeResponseData.data() + hashLength, 16);
    challengeResponse.append(reinterpret_cast<char*>(asnSignature->data), asnSignature->length);
    challengeResponse.append(clientSecretData);

    QByteArray paddedHash = QCryptographicHash::hash(challengeResponse, hashAlgo);
    paddedHash.resize(32);
    QByteArray encryptedChallengeResponseHash = encrypt(paddedHash, aesKey);
    QString respXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&serverchallengeresp=" +
                                                    encryptedChallengeResponseHash.toHex(),
                                                    REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(respXml);
    if (NvHTTP::getXmlString(respXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #3";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray pairingSecret = NvHTTP::getXmlStringFromHex(respXml, "pairingsecret");
    QByteArray serverSecret = pairingSecret.left(16);
    QByteArray serverSignature = pairingSecret.mid(16);

    if (!verifySignature(serverSecret,
                         serverSignature,
                         serverCertStr))
    {
        qCritical() << "MITM detected";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray expectedResponseData;
    expectedResponseData.append(randomChallenge);
    expectedResponseData.append(getSignatureFromPemCert(serverCertStr));
    expectedResponseData.append(serverSecret);
    if (QCryptographicHash::hash(expectedResponseData, hashAlgo) != serverResponse)
    {
        qCritical() << "Incorrect PIN";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::PIN_WRONG;
    }

    QByteArray clientPairingSecret;
    clientPairingSecret.append(clientSecretData);
    clientPairingSecret.append(signMessage(clientSecretData));

    QString secretRespXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                          "pair",
                                                          "devicename=roth&updateState=1&clientpairingsecret=" +
                                                          clientPairingSecret.toHex(),
                                                          REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(secretRespXml);
    if (NvHTTP::getXmlString(secretRespXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #4";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QString pairChallengeXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttps,
                                                             "pair",
                                                             "devicename=roth&updateState=1&phrase=pairchallenge",
                                                             REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(pairChallengeXml);
    if (NvHTTP::getXmlString(pairChallengeXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #5";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    serverCert = std::move(unverifiedServerCert);
    return PairState::PAIRED;
}
```
**File:** app/backend/nvhttp.h (L178-179)
```text
    QImage
    getBoxArt(int appId);
```
**File:** app/backend/boxartmanager.cpp (L107-129)
```cpp
QUrl BoxArtManager::loadBoxArtFromNetwork(NvComputer* computer, int appId)
{
    NvHTTP http(computer);

    QString cachePath = getFilePathForBoxArt(computer, appId);
    QImage image;
    try {
        image = http.getBoxArt(appId);
    } catch (...) {}

    // Cache the box art on disk if it loaded
    if (!image.isNull()) {
        if (image.save(cachePath)) {
            return QUrl::fromLocalFile(cachePath);
        }
        else {
            // A failed save() may leave a zero byte file. Make sure that's removed.
            QFile(cachePath).remove();
        }
    }

    return QUrl();
}
```
**File:** app/streaming/session.cpp (L1554-1558)
```cpp
    // The UI should have ensured the old game was already quit
    // if we decide to stream a different game.
    Q_ASSERT(m_Computer->currentGameId == 0 ||
             m_Computer->currentGameId == m_App.id);

```
**File:** app/streaming/session.cpp (L1582-1600)
```cpp
    QString rtspSessionUrl;

    try {
        NvHTTP http(m_Computer);
        http.startApp(m_Computer->currentGameId != 0 ? "resume" : "launch",
                      m_Computer->isNvidiaServerSoftware,
                      m_App.id, &m_StreamConfig,
                      enableGameOptimizations,
                      m_Preferences->playAudioOnHost,
                      m_InputHandler->getAttachedGamepadMask(),
                      !m_Preferences->multiController,
                      rtspSessionUrl);
    } catch (const GfeHttpResponseException& e) {
        emit displayLaunchError(tr("Host returned error: %1").arg(e.toQString()));
        return false;
    } catch (const QtNetworkReplyException& e) {
        emit displayLaunchError(e.toQString());
        return false;
    }
```
**File:** app/backend/nvcomputer.cpp (L1-50)
```cpp
#include "nvcomputer.h"
#include "nvapp.h"
#include "settings/compatfetcher.h"

#include <QUdpSocket>
#include <QHostInfo>
#include <QNetworkInterface>
#include <QNetworkProxy>

#define SER_NAME "hostname"
#define SER_UUID "uuid"
#define SER_MAC "mac"
#define SER_LOCALADDR "localaddress"
#define SER_LOCALPORT "localport"
#define SER_REMOTEADDR "remoteaddress"
#define SER_REMOTEPORT "remoteport"
#define SER_MANUALADDR "manualaddress"
#define SER_MANUALPORT "manualport"
#define SER_IPV6ADDR "ipv6address"
#define SER_IPV6PORT "ipv6port"
#define SER_APPLIST "apps"
#define SER_SRVCERT "srvcert"
#define SER_CUSTOMNAME "customname"
#define SER_NVIDIASOFTWARE "nvidiasw"

NvComputer::NvComputer(QSettings& settings)
{
    this->name = settings.value(SER_NAME).toString();
    this->uuid = settings.value(SER_UUID).toString();
    this->hasCustomName = settings.value(SER_CUSTOMNAME).toBool();
    this->macAddress = settings.value(SER_MAC).toByteArray();
    this->localAddress = NvAddress(settings.value(SER_LOCALADDR).toString(),
                                   settings.value(SER_LOCALPORT, QVariant(DEFAULT_HTTP_PORT)).toUInt());
    this->remoteAddress = NvAddress(settings.value(SER_REMOTEADDR).toString(),
                                    settings.value(SER_REMOTEPORT, QVariant(DEFAULT_HTTP_PORT)).toUInt());
    this->ipv6Address = NvAddress(settings.value(SER_IPV6ADDR).toString(),
                                  settings.value(SER_IPV6PORT, QVariant(DEFAULT_HTTP_PORT)).toUInt());
    this->manualAddress = NvAddress(settings.value(SER_MANUALADDR).toString(),
                                    settings.value(SER_MANUALPORT, QVariant(DEFAULT_HTTP_PORT)).toUInt());
    this->serverCert = QSslCertificate(settings.value(SER_SRVCERT).toByteArray());
    this->isNvidiaServerSoftware = settings.value(SER_NVIDIASOFTWARE).toBool();

    int appCount = settings.beginReadArray(SER_APPLIST);
    this->appList.reserve(appCount);
    for (int i = 0; i < appCount; i++) {
        settings.setArrayIndex(i);

        NvApp app(settings);
        this->appList.append(app);
    }
```
## Q10
The server completes the pairing by inputting the PIN code displayed by the client. How does the client wait for the server's response to complete the pairing during the time the PIN code is generated and the user inputs the PIN on the server side?
### Answer
You're asking about how the Moonlight client waits for the server to complete pairing after displaying the PIN code to the user.

## Answer

The client doesn't actively poll or wait for the server's response during pairing. Instead, the pairing process is **synchronous and blocking** - the client sends requests sequentially through all 5 phases and waits for each response before proceeding to the next phase.

### Pairing Execution Flow

When the user clicks on an unpaired PC, the client generates a PIN and displays it in a dialog: moonlight-qt:239-246 

The pairing task runs in a background thread via `PendingPairingTask`: moonlight-qt:564-582 

### The Blocking Nature of Pairing

Inside `NvPairingManager::pair()`, each phase makes an HTTP/HTTPS request and **blocks waiting for the response** before proceeding: moonlight-qt:217-227 

The server validates the PIN during Phase 3 (server challenge response). If the user hasn't entered the PIN yet on the server side, the server simply doesn't respond or returns an error, causing the pairing to fail: moonlight-qt:287-298 

### PIN Validation

The PIN validation happens when the client sends the encrypted challenge response hash in Phase 3. The server decrypts this using the PIN-derived key and verifies it matches the expected value: moonlight-qt:313-322 

If the PIN is incorrect (user entered wrong PIN on server), the server returns a response that causes the client to detect `PIN_WRONG` state: moonlight-qt:585-586 

### UI Feedback

While pairing is in progress, the dialog remains open showing the PIN: moonlight-qt:302-310 

When pairing completes (successfully or with error), the `pairingCompleted` signal is emitted, which closes the dialog: moonlight-qt:47-58 

## Notes

The pairing process uses HTTP request timeouts (defined as `REQUEST_TIMEOUT_MS`) to prevent indefinite waiting. If the user takes too long to enter the PIN on the server, the HTTP request will timeout and pairing will fail. The client doesn't implement any retry logic or polling mechanism - it's a single synchronous attempt that either succeeds or fails based on the server's responses to the 5-phase handshake.

Wiki pages you might want to explore:
- [User Interface System (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2)
- [PC Discovery View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.1)
### Citations
**File:** app/gui/PcView.qml (L47-58)
```text
    function pairingComplete(error)
    {
        // Close the PIN dialog
        pairDialog.close()

        // Display a failed dialog if we got an error
        if (error !== undefined) {
            errorDialog.text = error
            errorDialog.helpText = ""
            errorDialog.open()
        }
    }
```
**File:** app/gui/PcView.qml (L239-246)
```text
                    var pin = computerModel.generatePinString()

                    // Kick off pairing in the background
                    computerModel.pairComputer(index, pin)

                    // Display the pairing dialog
                    pairDialog.pin = pin
                    pairDialog.open()
```
**File:** app/gui/PcView.qml (L302-310)
```text
        // don't allow edits to the rest of the window while open
        property string pin : "0000"
        text:qsTr("Please enter %1 on your host PC. This dialog will close when pairing is completed.").arg(pin)+"\n\n"+
             qsTr("If your host PC is running Sunshine, navigate to the Sunshine web UI to enter the PIN.")
        standardButtons: Dialog.Cancel
        onRejected: {
            // FIXME: We should interrupt pairing here
        }
    }
```
**File:** app/backend/computermanager.cpp (L564-582)
```cpp
    PendingPairingTask(ComputerManager* computerManager, NvComputer* computer, QString pin)
        : m_ComputerManager(computerManager),
          m_Computer(computer),
          m_Pin(pin)
    {
        connect(this, &PendingPairingTask::pairingCompleted,
                computerManager, &ComputerManager::pairingCompleted);
    }

signals:
    void pairingCompleted(NvComputer* computer, QString error);

private:
    void run()
    {
        NvPairingManager pairingManager(m_Computer);

        try {
           NvPairingManager::PairState result = pairingManager.pair(m_Computer->appVersion, m_Pin, m_Computer->serverCert);
```
**File:** app/backend/computermanager.cpp (L585-586)
```cpp
           case NvPairingManager::PairState::PIN_WRONG:
               emit pairingCompleted(m_Computer, tr("The PIN from the PC didn't match. Please try again."));
```
**File:** app/backend/nvpairingmanager.cpp (L217-227)
```cpp
    QString getCert = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&phrase=getservercert&salt=" +
                                                    salt.toHex() + "&clientcert=" + IdentityManager::get()->getCertificate().toHex(),
                                                    0);
    NvHTTP::verifyResponseStatus(getCert);
    if (NvHTTP::getXmlString(getCert, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #1";
        return PairState::FAILED;
    }
```
**File:** app/backend/nvpairingmanager.cpp (L287-298)
```cpp
    QString respXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&serverchallengeresp=" +
                                                    encryptedChallengeResponseHash.toHex(),
                                                    REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(respXml);
    if (NvHTTP::getXmlString(respXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #3";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }
```
**File:** app/backend/nvpairingmanager.cpp (L313-322)
```cpp
    QByteArray expectedResponseData;
    expectedResponseData.append(randomChallenge);
    expectedResponseData.append(getSignatureFromPemCert(serverCertStr));
    expectedResponseData.append(serverSecret);
    if (QCryptographicHash::hash(expectedResponseData, hashAlgo) != serverResponse)
    {
        qCritical() << "Incorrect PIN";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::PIN_WRONG;
    }
```
# DeepWiki Q&A with Code Context for Repository: moonlight-stream/moonlight-qt
## Q1
how to get /launch and /serverinfo info from server?
### Answer
Based on the code context, you're asking about how Moonlight retrieves `/launch` and `/serverinfo` information from the host server.

## Answer

Moonlight uses the `NvHTTP` class to communicate with the host server and retrieve information through HTTP/HTTPS endpoints. moonlight-qt:124-187 

### Getting `/serverinfo`

The `NvHTTP::getServerInfo()` method fetches server information: moonlight-qt:124-140 

The method first attempts to use HTTPS if a pinned certificate is available, then falls back to HTTP if needed. moonlight-qt:143-160  If no certificate exists yet, it uses HTTP initially to fetch the HTTPS port, then retries over HTTPS. moonlight-qt:162-183 

This is called during PC discovery when adding a new host: moonlight-qt:809-818 

The response is then used to create or update an `NvComputer` object: moonlight-qt:820-821 

### Getting `/launch` info

The `/launch` endpoint is called via `NvHTTP::startApp()` when starting a streaming session: moonlight-qt:1585-1593 

This happens in `Session::startConnectionAsync()` after the user selects an app to stream. moonlight-qt:1548-1600  The method passes streaming configuration parameters and receives back an RTSP session URL that's used to establish the actual streaming connection. moonlight-qt:1582-1593 

## Notes

The `NvHTTP` class handles all HTTP/HTTPS communication with the host server, including certificate pinning for security. The `/serverinfo` endpoint is polled regularly to monitor PC status, while `/launch` (or `/resume`) is only called when initiating a streaming session. Both endpoints use the base URL constructed from the host's address and appropriate port (HTTP 47989 or HTTPS 47984 by default).

Wiki pages you might want to explore:
- [User Interface System (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2)
- [PC Discovery View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.1)
### Citations
**File:** app/backend/nvhttp.cpp (L124-187)
```cpp
NvHTTP::getServerInfo(NvLogLevel logLevel, bool fastFail)
{
    QString serverInfo;

    // Check if we have a pinned cert and HTTPS port for this host yet
    if (!m_ServerCert.isNull() && httpsPort() != 0)
    {
        try
        {
            // Always try HTTPS first, since it properly reports
            // pairing status (and a few other attributes).
            serverInfo = openConnectionToString(m_BaseUrlHttps,
                                                "serverinfo",
                                                nullptr,
                                                fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                                logLevel);
            // Throws if the request failed
            verifyResponseStatus(serverInfo);
        }
        catch (const GfeHttpResponseException& e)
        {
            if (e.getStatusCode() == 401)
            {
                // Certificate validation error, fallback to HTTP
                serverInfo = openConnectionToString(m_BaseUrlHttp,
                                                    "serverinfo",
                                                    nullptr,
                                                    fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                                    logLevel);
                verifyResponseStatus(serverInfo);
            }
            else
            {
                // Rethrow real errors
                throw e;
            }
        }
    }
    else
    {
        // Only use HTTP prior to pairing or fetching HTTPS port
        serverInfo = openConnectionToString(m_BaseUrlHttp,
                                            "serverinfo",
                                            nullptr,
                                            fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                            logLevel);
        verifyResponseStatus(serverInfo);

        // Populate the HTTPS port
        uint16_t httpsPort = getXmlString(serverInfo, "HttpsPort").toUShort();
        if (httpsPort == 0) {
            httpsPort = DEFAULT_HTTPS_PORT;
        }
        setHttpsPort(httpsPort);

        // If we just needed to determine the HTTPS port, we'll try again over
        // HTTPS now that we have the port number
        if (!m_ServerCert.isNull()) {
            return getServerInfo(logLevel, fastFail);
        }
    }

    return serverInfo;
}
```
**File:** app/backend/computermanager.cpp (L809-818)
```cpp
        // Perform initial serverinfo fetch over HTTP since we don't know which cert to use
        QString serverInfo = fetchServerInfo(http);
        if (serverInfo.isEmpty() && !m_MdnsIpv6Address.isNull()) {
            // Retry using the global IPv6 address if the IPv4 or link-local IPv6 address fails
            http.setAddress(m_MdnsIpv6Address);
            serverInfo = fetchServerInfo(http);
        }
        if (serverInfo.isEmpty()) {
            return;
        }
```
**File:** app/backend/computermanager.cpp (L820-821)
```cpp
        // Create initial newComputer using HTTP serverinfo with no pinned cert
        NvComputer* newComputer = new NvComputer(http, serverInfo);
```
**File:** app/streaming/session.cpp (L1548-1600)
```cpp
bool Session::startConnectionAsync()
{
    // Wait 1.5 seconds before connecting to let the user
    // have time to read any messages present on the segue
    SDL_Delay(1500);

    // The UI should have ensured the old game was already quit
    // if we decide to stream a different game.
    Q_ASSERT(m_Computer->currentGameId == 0 ||
             m_Computer->currentGameId == m_App.id);

    bool enableGameOptimizations;
    if (m_Computer->isNvidiaServerSoftware) {
        // GFE will set all settings to 720p60 if it doesn't recognize
        // the chosen resolution. Avoid that by disabling SOPS when it
        // is not streaming a supported resolution.
        enableGameOptimizations = false;
        for (const NvDisplayMode &mode : m_Computer->displayModes) {
            if (mode.width == m_StreamConfig.width &&
                    mode.height == m_StreamConfig.height) {
                SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION,
                            "Found host supported resolution: %dx%d",
                            mode.width, mode.height);
                enableGameOptimizations = m_Preferences->gameOptimizations;
                break;
            }
        }
    }
    else {
        // Always send SOPS to Sunshine because we may repurpose the
        // option to control whether the display mode is adjusted
        enableGameOptimizations = m_Preferences->gameOptimizations;
    }

    QString rtspSessionUrl;

    try {
        NvHTTP http(m_Computer);
        http.startApp(m_Computer->currentGameId != 0 ? "resume" : "launch",
                      m_Computer->isNvidiaServerSoftware,
                      m_App.id, &m_StreamConfig,
                      enableGameOptimizations,
                      m_Preferences->playAudioOnHost,
                      m_InputHandler->getAttachedGamepadMask(),
                      !m_Preferences->multiController,
                      rtspSessionUrl);
    } catch (const GfeHttpResponseException& e) {
        emit displayLaunchError(tr("Host returned error: %1").arg(e.toQString()));
        return false;
    } catch (const QtNetworkReplyException& e) {
        emit displayLaunchError(e.toQString());
        return false;
    }
```
## Q2
How to parse the information returned by the above 2 interfaces and provide it to the function for establishing a streaming connection?
### Answer
You're asking about how Moonlight parses the responses from `/serverinfo` and `/launch` endpoints and uses that information to establish a streaming connection.

## Answer

### Parsing `/serverinfo` Response

The `/serverinfo` response is parsed to create/update an `NvComputer` object that stores host capabilities. moonlight-qt:754-782  The `NvHTTP::getServerInfo()` method returns an XML string that gets parsed to extract server properties like:<cite />

- Server codec mode support (`serverCodecModeSupport`)
- GFE version (`gfeVersion`)
- App version (`appVersion`)
- Display modes
- Current game ID

These properties are stored in the `NvComputer` object and later used during session validation and configuration.<cite />

### Parsing `/launch` Response and Establishing Connection

When starting a stream, `NvHTTP::startApp()` is called with the `STREAM_CONFIGURATION` structure containing all streaming parameters (resolution, FPS, bitrate, codec preferences, etc.). moonlight-qt:189-236  The method constructs a URL with query parameters including:<cite />

- Resolution and FPS (`mode` parameter)
- HDR settings
- Audio configuration
- Gamepad mask
- Remote input encryption keys

The response is parsed to extract the `rtspSessionUrl` using `getXmlString(response, "sessionUrl0")`. moonlight-qt:235-235 

### Providing Information to Connection Function

After receiving the `/launch` response, the parsed information is used to populate a `SERVER_INFORMATION` structure: moonlight-qt:1602-1624 

```cpp
SERVER_INFORMATION hostInfo;
hostInfo.address = hostnameStr.data();
hostInfo.serverInfoAppVersion = siAppVersion.data();
hostInfo.serverCodecModeSupport = m_Computer->serverCodecModeSupport;
hostInfo.serverInfoGfeVersion = siGfeVersion.data();
hostInfo.rtspSessionUrl = rtspSessionUrlStr.data();
```

This structure, along with the `STREAM_CONFIGURATION` and callback structures, is passed to `LiStartConnection()` to establish the actual streaming connection: moonlight-qt:1678-1685 

The `LiStartConnection()` function (from the moonlight-common-c library) uses:
- The RTSP session URL from `/launch` response to establish the RTSP control channel
- Server codec support from `/serverinfo` to negotiate video formats
- Stream configuration to set up video/audio decoders

### Validation Before Connection

Before calling `LiStartConnection()`, the session validates that the host supports the requested features by checking `m_Computer->serverCodecModeSupport` against the requested video formats. moonlight-qt:1117-1152  For example, it verifies YUV 4:4:4 support and adjusts the supported video formats list accordingly.<cite />

## Notes

The parsing happens in two stages: first during PC discovery (parsing `/serverinfo` into `NvComputer` properties), then during session start (parsing `/launch` response for RTSP URL). The `NvComputer` object acts as a bridge, storing server capabilities that are later referenced when configuring the `SERVER_INFORMATION` structure for `LiStartConnection()`. The actual XML parsing is handled by helper functions like `getXmlString()` in the `NvHTTP` class.

Wiki pages you might want to explore:
- [Settings View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.2)
- [Input Handling (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#4.7)
### Citations
**File:** app/backend/computermanager.cpp (L754-782)
```cpp
    QString fetchServerInfo(NvHTTP& http)
    {
        QString serverInfo;

        // Do nothing if we're quitting
        if (m_AboutToQuit) {
            return QString();
        }

        try {
            // There's a race condition between GameStream servers reporting presence over
            // mDNS and the HTTPS server being ready to respond to our queries. To work
            // around this issue, we will issue the request again after a few seconds if
            // we see a ServiceUnavailableError error.
            try {
                serverInfo = http.getServerInfo(NvHTTP::NVLL_VERBOSE);
            } catch (const QtNetworkReplyException& e) {
                if (e.getError() == QNetworkReply::ServiceUnavailableError) {
                    qWarning() << "Retrying request in 5 seconds after ServiceUnavailableError";
                    QThread::sleep(5);
                    serverInfo = http.getServerInfo(NvHTTP::NVLL_VERBOSE);
                    qInfo() << "Retry successful";
                }
                else {
                    // Rethrow other errors
                    throw e;
                }
            }
            return serverInfo;
```
**File:** app/backend/nvhttp.cpp (L189-236)
```cpp
void
NvHTTP::startApp(QString verb,
                 bool isGfe,
                 int appId,
                 PSTREAM_CONFIGURATION streamConfig,
                 bool sops,
                 bool localAudio,
                 int gamepadMask,
                 bool persistGameControllersOnDisconnect,
                 QString& rtspSessionUrl)
{
    int riKeyId;

    memcpy(&riKeyId, streamConfig->remoteInputAesIv, sizeof(riKeyId));
    riKeyId = qFromBigEndian(riKeyId);

    QString response =
            openConnectionToString(m_BaseUrlHttps,
                                   verb,
                                   "appid="+QString::number(appId)+
                                   "&mode="+QString::number(streamConfig->width)+"x"+
                                   QString::number(streamConfig->height)+"x"+
                                   // Using an FPS value over 60 causes SOPS to default to 720p60,
                                   // so force it to 0 to ensure the correct resolution is set. We
                                   // used to use 60 here but that locked the frame rate to 60 FPS
                                   // on GFE 3.20.3. We don't need this hack for Sunshine.
                                   QString::number((streamConfig->fps > 60 && isGfe) ? 0 : streamConfig->fps)+
                                   "&additionalStates=1&sops="+QString::number(sops ? 1 : 0)+
                                   "&rikey="+QByteArray(streamConfig->remoteInputAesKey, sizeof(streamConfig->remoteInputAesKey)).toHex()+
                                   "&rikeyid="+QString::number(riKeyId)+
                                   ((streamConfig->supportedVideoFormats & VIDEO_FORMAT_MASK_10BIT) ?
                                       "&hdrMode=1&clientHdrCapVersion=0&clientHdrCapSupportedFlagsInUint32=0&clientHdrCapMetaDataId=NV_STATIC_METADATA_TYPE_1&clientHdrCapDisplayData=0x0x0x0x0x0x0x0x0x0x0" :
                                        "")+
                                   "&localAudioPlayMode="+QString::number(localAudio ? 1 : 0)+
                                   "&surroundAudioInfo="+QString::number(SURROUNDAUDIOINFO_FROM_AUDIO_CONFIGURATION(streamConfig->audioConfiguration))+
                                   "&remoteControllersBitmap="+QString::number(gamepadMask)+
                                   "&gcmap="+QString::number(gamepadMask)+
                                   "&gcpersist="+QString::number(persistGameControllersOnDisconnect ? 1 : 0)+
                                   LiGetLaunchUrlQueryParameters(),
                                   LAUNCH_TIMEOUT_MS);

    qInfo() << "Launch response:" << response;

    // Throws if the request failed
    verifyResponseStatus(response);

    rtspSessionUrl = getXmlString(response, "sessionUrl0");
}
```
**File:** app/streaming/session.cpp (L1117-1152)
```cpp
    if (m_Preferences->enableYUV444) {
        if (!(m_Computer->serverCodecModeSupport & SCM_MASK_YUV444)) {
            emitLaunchWarning(tr("Your host PC doesn't support YUV 4:4:4 streaming."));
            m_SupportedVideoFormats.removeByMask(VIDEO_FORMAT_MASK_YUV444);
        }
        else {
            m_SupportedVideoFormats.removeByMask(~m_SupportedVideoFormats.maskByServerCodecModes(m_Computer->serverCodecModeSupport));

            if (!m_SupportedVideoFormats.isEmpty() &&
                !(m_SupportedVideoFormats.front() & VIDEO_FORMAT_MASK_YUV444)) {
                emitLaunchWarning(tr("Your host PC doesn't support YUV 4:4:4 streaming for selected video codec."));
            }
            else if (m_Preferences->videoDecoderSelection != StreamingPreferences::VDS_FORCE_SOFTWARE) {
                while (!m_SupportedVideoFormats.isEmpty() &&
                       (m_SupportedVideoFormats.front() & VIDEO_FORMAT_MASK_YUV444) &&
                       getDecoderAvailability(testWindow,
                                              m_Preferences->videoDecoderSelection,
                                              m_SupportedVideoFormats.front(),
                                              m_StreamConfig.width,
                                              m_StreamConfig.height,
                                              m_StreamConfig.fps) != DecoderAvailability::Hardware) {
                    if (m_Preferences->videoDecoderSelection == StreamingPreferences::VDS_FORCE_HARDWARE) {
                        m_SupportedVideoFormats.removeFirst();
                    }
                    else {
                        emitLaunchWarning(tr("Using software decoding due to your selection to force YUV 4:4:4 without GPU support. This may cause poor streaming performance."));
                        break;
                    }
                }
                if (!m_SupportedVideoFormats.isEmpty() &&
                    !(m_SupportedVideoFormats.front() & VIDEO_FORMAT_MASK_YUV444)) {
                    emitLaunchWarning(tr("This PC's GPU doesn't support YUV 4:4:4 decoding for selected video codec."));
                }
            }
        }
    }
```
**File:** app/streaming/session.cpp (L1602-1624)
```cpp
    QByteArray hostnameStr = m_Computer->activeAddress.address().toLatin1();
    QByteArray siAppVersion = m_Computer->appVersion.toLatin1();

    SERVER_INFORMATION hostInfo;
    hostInfo.address = hostnameStr.data();
    hostInfo.serverInfoAppVersion = siAppVersion.data();
    hostInfo.serverCodecModeSupport = m_Computer->serverCodecModeSupport;

    // Older GFE versions didn't have this field
    QByteArray siGfeVersion;
    if (!m_Computer->gfeVersion.isEmpty()) {
        siGfeVersion = m_Computer->gfeVersion.toLatin1();
    }
    if (!siGfeVersion.isEmpty()) {
        hostInfo.serverInfoGfeVersion = siGfeVersion.data();
    }

    // Older GFE and Sunshine versions didn't have this field
    QByteArray rtspSessionUrlStr;
    if (!rtspSessionUrl.isEmpty()) {
        rtspSessionUrlStr = rtspSessionUrl.toLatin1();
        hostInfo.rtspSessionUrl = rtspSessionUrlStr.data();
    }
```
**File:** app/streaming/session.cpp (L1678-1685)
```cpp
    int err = LiStartConnection(&hostInfo, &m_StreamConfig, &k_ConnCallbacks,
                                &m_VideoCallbacks, &m_AudioCallbacks,
                                NULL, 0, NULL, 0);
    if (err != 0) {
        // We already displayed an error dialog in the stage failure
        // listener.
        return false;
    }
```
## Q3
how to get "Remote input encryption keys"
### Answer
You're asking about how Moonlight generates the "Remote input encryption keys" that are sent to the host server during the `/launch` request.

## Answer

The remote input encryption keys (`rikey` and `rikeyid`) are randomly generated AES encryption keys used to secure input data sent from the client to the host during streaming. moonlight-qt:692-696 

### Key Generation

During session initialization in `Session::initialize()`, Moonlight generates these keys using OpenSSL's cryptographically secure random number generator:

```cpp
RAND_bytes(reinterpret_cast<unsigned char*>(m_StreamConfig.remoteInputAesKey),
           sizeof(m_StreamConfig.remoteInputAesKey));

// Only the first 4 bytes are populated in the RI key IV
RAND_bytes(reinterpret_cast<unsigned char*>(m_StreamConfig.remoteInputAesIv), 4);
``` moonlight-qt:692-696 

The `remoteInputAesKey` is a full AES key (16 bytes), while `remoteInputAesIv` only uses the first 4 bytes as an initialization vector. moonlight-qt:692-696 

### Sending Keys to Host

These generated keys are then sent to the host server when calling the `/launch` endpoint in `NvHTTP::startApp()`. moonlight-qt:200-218  The method:

1. Extracts the key ID from the IV by reading the first 4 bytes as a big-endian integer moonlight-qt:200-203 
2. Converts the AES key to hexadecimal format using `QByteArray(...).toHex()` moonlight-qt:217-217 
3. Includes both values as query parameters: `rikey=<hex_key>&rikeyid=<key_id>` moonlight-qt:217-218 

### Security Considerations

For security, these keys are automatically redacted from log files to prevent exposure. moonlight-qt:108-110  The logging system uses regex patterns to strip `rikey` and `rikeyid` values before writing to logs. moonlight-qt:88-88 

## Notes

The remote input encryption is part of Moonlight's security features to protect input data (keyboard, mouse, gamepad) transmitted during streaming. The keys are generated fresh for each streaming session and are stored in the `STREAM_CONFIGURATION` structure (`m_StreamConfig`) which is later passed to `LiStartConnection()` to establish the connection. moonlight-qt:1584-1593 

Wiki pages you might want to explore:
- [PC Discovery View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.1)
### Citations
**File:** app/streaming/session.cpp (L692-696)
```cpp
    RAND_bytes(reinterpret_cast<unsigned char*>(m_StreamConfig.remoteInputAesKey),
               sizeof(m_StreamConfig.remoteInputAesKey));

    // Only the first 4 bytes are populated in the RI key IV
    RAND_bytes(reinterpret_cast<unsigned char*>(m_StreamConfig.remoteInputAesIv), 4);
```
**File:** app/streaming/session.cpp (L1584-1593)
```cpp
    try {
        NvHTTP http(m_Computer);
        http.startApp(m_Computer->currentGameId != 0 ? "resume" : "launch",
                      m_Computer->isNvidiaServerSoftware,
                      m_App.id, &m_StreamConfig,
                      enableGameOptimizations,
                      m_Preferences->playAudioOnHost,
                      m_InputHandler->getAttachedGamepadMask(),
                      !m_Preferences->multiController,
                      rtspSessionUrl);
```
**File:** app/backend/nvhttp.cpp (L200-218)
```cpp
    int riKeyId;

    memcpy(&riKeyId, streamConfig->remoteInputAesIv, sizeof(riKeyId));
    riKeyId = qFromBigEndian(riKeyId);

    QString response =
            openConnectionToString(m_BaseUrlHttps,
                                   verb,
                                   "appid="+QString::number(appId)+
                                   "&mode="+QString::number(streamConfig->width)+"x"+
                                   QString::number(streamConfig->height)+"x"+
                                   // Using an FPS value over 60 causes SOPS to default to 720p60,
                                   // so force it to 0 to ensure the correct resolution is set. We
                                   // used to use 60 here but that locked the frame rate to 60 FPS
                                   // on GFE 3.20.3. We don't need this hack for Sunshine.
                                   QString::number((streamConfig->fps > 60 && isGfe) ? 0 : streamConfig->fps)+
                                   "&additionalStates=1&sops="+QString::number(sops ? 1 : 0)+
                                   "&rikey="+QByteArray(streamConfig->remoteInputAesKey, sizeof(streamConfig->remoteInputAesKey)).toHex()+
                                   "&rikeyid="+QString::number(riKeyId)+
```
**File:** app/main.cpp (L108-110)
```cpp
    // Strip session encryption keys and IVs from the logs
    message.replace(k_RikeyRegex, "&rikey=REDACTED");
    message.replace(k_RikeyIdRegex, "&rikeyid=REDACTED");
```
**File:** app/deploy/linux/com.moonlight_stream.Moonlight.appdata.xml (L88-88)
```text
					<li>Per-session keys (rikey and rikeyid values) are now automatically stripped from logs</li>
```
## Q4
<?xml version="1.0" encoding="utf-8"?>
<root status_code="200">
  <hostname>Html5syt</hostname>
  <appversion>7.1.431.-1</appversion>
<GfeVersion>3.23.0.74</GfeVersion>
  <uniqueid>F98186B1-DE02-2328-279E-0A461FBCEC47</uniqueid>
  <HttpsPort>47984</HttpsPort>
  <ExternalPort>47989</ExternalPort>
<MaxLumaPixelsHEVC>1869449984</MaxLumaPixelsHEVC>
  <mac>00:00:00:00:00:00</mac>
  <LocalIP>127.0.0.1</LocalIP>
  <ServerCodecModeSupport>257</ServerCodecModeSupport>
<PairStatus>0</PairStatus>
  <currentgame>1191261554</currentgame>
  <state>SUNSHINE_SERVER_BUSY</state>
</root>
This is a response from a serverinfo, please tell me which parameters are used to establish the connection in it?
### Answer
You're asking which parameters from the `/serverinfo` XML response are used when establishing a streaming connection in Moonlight.

## Answer

From the `/serverinfo` response you provided, the following parameters are used to establish the streaming connection:

### Parameters Used in Connection Establishment

**`ServerCodecModeSupport` (value: 257)** - This is stored in the `NvComputer` object and later passed to `LiStartConnection()` via the `SERVER_INFORMATION` structure. moonlight-qt:1608-1608  It indicates which video codecs and formats the host supports, and is used to negotiate the video format during connection setup. moonlight-qt:1608-1608 

**`appversion` (value: 7.1.431.-1)** - This is stored as `m_Computer->appVersion` and passed to `LiStartConnection()` as `hostInfo.serverInfoAppVersion`. moonlight-qt:1603-1607  The connection library uses this to determine host capabilities and compatibility. moonlight-qt:1603-1607 

**`GfeVersion` (value: 3.23.0.74)** - This is stored as `m_Computer->gfeVersion` and passed to `LiStartConnection()` as `hostInfo.serverInfoGfeVersion`. moonlight-qt:1611-1617  It's used to determine if the host is running GFE or Sunshine and adjust behavior accordingly. moonlight-qt:1560-1580 

**`LocalIP` (value: 127.0.0.1)** - The host's address is used to construct the base URLs for HTTP/HTTPS communication and is passed to `LiStartConnection()` as `hostInfo.address`. moonlight-qt:1602-1606 

**`HttpsPort` (value: 47984)** - Used to construct the HTTPS base URL for secure communication with the host, including the `/launch` endpoint call. moonlight-qt:173-177 

### Parameters NOT Directly Used in Connection

The following parameters are informational but not directly passed to the connection function:

- `hostname`, `uniqueid`, `ExternalPort`, `MaxLumaPixelsHEVC`, `mac` - These are stored in the `NvComputer` object for display and management purposes but aren't passed to `LiStartConnection()`.<cite />
- `PairStatus` - Used to determine if pairing is needed before streaming, but not used during connection establishment.<cite />
- `currentgame` and `state` - Used to determine if the host is already streaming, which affects whether to call `/launch` or `/resume`. moonlight-qt:1586-1586 

## Notes

The `state` value "SUNSHINE_SERVER_BUSY" indicates the host is currently streaming (as confirmed by the non-zero `currentgame` value). moonlight-qt:112-116  In this case, Moonlight would call `/resume` instead of `/launch` if you're trying to connect to the same game. moonlight-qt:1586-1586  The `ServerCodecModeSupport` value of 257 indicates support for H.264 (bit 0) and H.265/HEVC (bit 8).<cite />

Wiki pages you might want to explore:
- [PC Discovery View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.1)
### Citations
**File:** app/streaming/session.cpp (L1560-1580)
```cpp
    if (m_Computer->isNvidiaServerSoftware) {
        // GFE will set all settings to 720p60 if it doesn't recognize
        // the chosen resolution. Avoid that by disabling SOPS when it
        // is not streaming a supported resolution.
        enableGameOptimizations = false;
        for (const NvDisplayMode &mode : m_Computer->displayModes) {
            if (mode.width == m_StreamConfig.width &&
                    mode.height == m_StreamConfig.height) {
                SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION,
                            "Found host supported resolution: %dx%d",
                            mode.width, mode.height);
                enableGameOptimizations = m_Preferences->gameOptimizations;
                break;
            }
        }
    }
    else {
        // Always send SOPS to Sunshine because we may repurpose the
        // option to control whether the display mode is adjusted
        enableGameOptimizations = m_Preferences->gameOptimizations;
    }
```
**File:** app/streaming/session.cpp (L1586-1586)
```cpp
        http.startApp(m_Computer->currentGameId != 0 ? "resume" : "launch",
```
**File:** app/streaming/session.cpp (L1602-1607)
```cpp
    QByteArray hostnameStr = m_Computer->activeAddress.address().toLatin1();
    QByteArray siAppVersion = m_Computer->appVersion.toLatin1();

    SERVER_INFORMATION hostInfo;
    hostInfo.address = hostnameStr.data();
    hostInfo.serverInfoAppVersion = siAppVersion.data();
```
**File:** app/streaming/session.cpp (L1608-1608)
```cpp
    hostInfo.serverCodecModeSupport = m_Computer->serverCodecModeSupport;
```
**File:** app/streaming/session.cpp (L1611-1617)
```cpp
    QByteArray siGfeVersion;
    if (!m_Computer->gfeVersion.isEmpty()) {
        siGfeVersion = m_Computer->gfeVersion.toLatin1();
    }
    if (!siGfeVersion.isEmpty()) {
        hostInfo.serverInfoGfeVersion = siGfeVersion.data();
    }
```
**File:** app/backend/nvhttp.cpp (L112-116)
```cpp
    QString serverState = getXmlString(serverInfo, "state");
    if (serverState != nullptr && serverState.endsWith("_SERVER_BUSY"))
    {
        return getXmlString(serverInfo, "currentgame").toInt();
    }
```
**File:** app/backend/nvhttp.cpp (L173-177)
```cpp
        uint16_t httpsPort = getXmlString(serverInfo, "HttpsPort").toUShort();
        if (httpsPort == 0) {
            httpsPort = DEFAULT_HTTPS_PORT;
        }
        setHttpsPort(httpsPort);
```
## Q5
When I call the /launch interface, the server requires me to provide a client certificate. How can I obtain this certificate?
### Answer
Moonlight obtains and provides client certificates through a multi-step process involving certificate generation, pairing, and SSL configuration:

## Client Certificate Generation

When Moonlight first launches, the `IdentityManager` class automatically generates a self-signed 2048-bit RSA certificate and private key pair if none exist. moonlight-qt:29-110 

These credentials are stored persistently in QSettings and cached in memory for reuse. moonlight-qt:112-139 

## Attaching Certificates to Requests

For every HTTPS request (including `/launch`), Moonlight attaches the client certificate through the `IdentityManager::getSslConfig()` method, which returns a `QSslConfiguration` containing both the client certificate and private key. moonlight-qt:184-191 

This SSL configuration is applied to all network requests in the `openConnection` method via `request.setSslConfiguration()`. moonlight-qt:486-489 

## The `/launch` Interface Specifically

When the `startApp` method is called to launch a game, it makes an HTTPS request to the `/launch` endpoint using the base HTTPS URL. moonlight-qt:205-228 

This request goes through `openConnection`, which automatically includes the client certificate for mutual TLS authentication with the host server.

## Pairing Process for Mutual Trust

Before the client certificate can be used for authentication, a pairing process must occur. During pairing, the client sends its certificate to the server and receives the server's certificate in return. moonlight-qt:217-248 

The server certificate is then pinned and stored in the `NvComputer` object for future SSL validation. moonlight-qt:419-439 

## Certificate Validation

If there's an SSL handshake failure or certificate mismatch (error 401), Moonlight falls back to HTTP and can re-initiate pairing to obtain updated certificates. moonlight-qt:143-160 

## Notes

- The client certificate uses a common name of "NVIDIA GameStream Client" moonlight-qt:70-74 
- The certificate has a 20-year validity period moonlight-qt:51-66 
- The `/launch` endpoint uses a 120-second timeout compared to the standard 5-second timeout for other requests moonlight-qt:15-19 
- Certificate pinning prevents man-in-the-middle attacks by ensuring SSL errors are only ignored if they match the previously paired server certificate moonlight-qt:429-434
### Citations
**File:** app/backend/identitymanager.cpp (L29-110)
```cpp
void IdentityManager::createCredentials(QSettings& settings)
{
    X509* cert = X509_new();
    THROW_BAD_ALLOC_IF_NULL(cert);

    EVP_PKEY_CTX* ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_RSA, NULL);
    THROW_BAD_ALLOC_IF_NULL(ctx);

    EVP_PKEY_keygen_init(ctx);
    EVP_PKEY_CTX_set_rsa_keygen_bits(ctx, 2048);

    // pk must be initialized on input
    EVP_PKEY* pk = NULL;
    EVP_PKEY_keygen(ctx, &pk);

    EVP_PKEY_CTX_free(ctx);
    THROW_BAD_ALLOC_IF_NULL(pk);

    X509_set_version(cert, 2);
    ASN1_INTEGER_set(X509_get_serialNumber(cert), 0);
#if OPENSSL_VERSION_NUMBER < 0x10100000L
    X509_gmtime_adj(X509_get_notBefore(cert), 0);
    X509_gmtime_adj(X509_get_notAfter(cert), 60 * 60 * 24 * 365 * 20); // 20 yrs
#else
    ASN1_TIME* before = ASN1_STRING_dup(X509_get0_notBefore(cert));
    THROW_BAD_ALLOC_IF_NULL(before);
    ASN1_TIME* after = ASN1_STRING_dup(X509_get0_notAfter(cert));
    THROW_BAD_ALLOC_IF_NULL(after);

    X509_gmtime_adj(before, 0);
    X509_gmtime_adj(after, 60 * 60 * 24 * 365 * 20); // 20 yrs

    X509_set1_notBefore(cert, before);
    X509_set1_notAfter(cert, after);

    ASN1_STRING_free(before);
    ASN1_STRING_free(after);
#endif

    X509_set_pubkey(cert, pk);

    X509_NAME* name = X509_get_subject_name(cert);
    X509_NAME_add_entry_by_txt(name, "CN", MBSTRING_ASC,
                               reinterpret_cast<unsigned char *>(const_cast<char*>("NVIDIA GameStream Client")),
                               -1, -1, 0);
    X509_set_issuer_name(cert, name);

    X509_sign(cert, pk, EVP_sha256());

    BIO* biokey = BIO_new(BIO_s_mem());
    THROW_BAD_ALLOC_IF_NULL(biokey);
    PEM_write_bio_PrivateKey(biokey, pk, NULL, NULL, 0, NULL, NULL);

    BIO* biocert = BIO_new(BIO_s_mem());
    THROW_BAD_ALLOC_IF_NULL(biocert);
    PEM_write_bio_X509(biocert, cert);

    BUF_MEM* mem;
    BIO_get_mem_ptr(biokey, &mem);
    m_CachedPrivateKey = QByteArray(mem->data, (int)mem->length);

    BIO_get_mem_ptr(biocert, &mem);
    m_CachedPemCert = QByteArray(mem->data, (int)mem->length);

    X509_free(cert);
    EVP_PKEY_free(pk);
    BIO_free(biokey);
    BIO_free(biocert);

    // Check that the new keypair is valid before persisting it
    if (getSslCertificate().isNull()) {
        qFatal("Newly generated certificate is unreadable");
    }
    if (getSslKey().isNull()) {
        qFatal("Newly generated private key is unreadable");
    }

    settings.setValue(SER_CERT, m_CachedPemCert);
    settings.setValue(SER_KEY, m_CachedPrivateKey);

    qInfo() << "Wrote new identity credentials to settings";
}
```
**File:** app/backend/identitymanager.cpp (L112-139)
```cpp
IdentityManager::IdentityManager()
{
    QSettings settings;

    m_CachedPemCert = settings.value(SER_CERT).toByteArray();
    m_CachedPrivateKey = settings.value(SER_KEY).toByteArray();

    if (m_CachedPemCert.isEmpty() || m_CachedPrivateKey.isEmpty()) {
        qInfo() << "No existing credentials found";
        createCredentials(settings);
    }
    else if (getSslCertificate().isNull()) {
        qWarning() << "Certificate is unreadable";
        createCredentials(settings);
    }
    else if (getSslKey().isNull()) {
        qWarning() << "Private key is unreadable";
        createCredentials(settings);
    }

    // We should have valid credentials now. If not, we're screwed
    if (getSslCertificate().isNull()) {
        qFatal("Certificate is unreadable");
    }
    if (getSslKey().isNull()) {
        qFatal("Private key is unreadable");
    }
}
```
**File:** app/backend/identitymanager.cpp (L184-191)
```cpp
QSslConfiguration
IdentityManager::getSslConfig()
{
    QSslConfiguration sslConfig(QSslConfiguration::defaultConfiguration());
    sslConfig.setLocalCertificate(getSslCertificate());
    sslConfig.setPrivateKey(getSslKey());
    return sslConfig;
}
```
**File:** app/backend/nvhttp.cpp (L15-19)
```cpp
#define FAST_FAIL_TIMEOUT_MS 2000
#define REQUEST_TIMEOUT_MS 5000
#define LAUNCH_TIMEOUT_MS 120000
#define RESUME_TIMEOUT_MS 30000
#define QUIT_TIMEOUT_MS 30000
```
**File:** app/backend/nvhttp.cpp (L143-160)
```cpp
        catch (const GfeHttpResponseException& e)
        {
            if (e.getStatusCode() == 401)
            {
                // Certificate validation error, fallback to HTTP
                serverInfo = openConnectionToString(m_BaseUrlHttp,
                                                    "serverinfo",
                                                    nullptr,
                                                    fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                                    logLevel);
                verifyResponseStatus(serverInfo);
            }
            else
            {
                // Rethrow real errors
                throw e;
            }
        }
```
**File:** app/backend/nvhttp.cpp (L205-228)
```cpp
    QString response =
            openConnectionToString(m_BaseUrlHttps,
                                   verb,
                                   "appid="+QString::number(appId)+
                                   "&mode="+QString::number(streamConfig->width)+"x"+
                                   QString::number(streamConfig->height)+"x"+
                                   // Using an FPS value over 60 causes SOPS to default to 720p60,
                                   // so force it to 0 to ensure the correct resolution is set. We
                                   // used to use 60 here but that locked the frame rate to 60 FPS
                                   // on GFE 3.20.3. We don't need this hack for Sunshine.
                                   QString::number((streamConfig->fps > 60 && isGfe) ? 0 : streamConfig->fps)+
                                   "&additionalStates=1&sops="+QString::number(sops ? 1 : 0)+
                                   "&rikey="+QByteArray(streamConfig->remoteInputAesKey, sizeof(streamConfig->remoteInputAesKey)).toHex()+
                                   "&rikeyid="+QString::number(riKeyId)+
                                   ((streamConfig->supportedVideoFormats & VIDEO_FORMAT_MASK_10BIT) ?
                                       "&hdrMode=1&clientHdrCapVersion=0&clientHdrCapSupportedFlagsInUint32=0&clientHdrCapMetaDataId=NV_STATIC_METADATA_TYPE_1&clientHdrCapDisplayData=0x0x0x0x0x0x0x0x0x0x0" :
                                        "")+
                                   "&localAudioPlayMode="+QString::number(localAudio ? 1 : 0)+
                                   "&surroundAudioInfo="+QString::number(SURROUNDAUDIOINFO_FROM_AUDIO_CONFIGURATION(streamConfig->audioConfiguration))+
                                   "&remoteControllersBitmap="+QString::number(gamepadMask)+
                                   "&gcmap="+QString::number(gamepadMask)+
                                   "&gcpersist="+QString::number(persistGameControllersOnDisconnect ? 1 : 0)+
                                   LiGetLaunchUrlQueryParameters(),
                                   LAUNCH_TIMEOUT_MS);
```
**File:** app/backend/nvhttp.cpp (L419-439)
```cpp
void NvHTTP::handleSslErrors(QNetworkReply* reply, const QList<QSslError>& errors)
{
    bool ignoreErrors = true;

    if (m_ServerCert.isNull()) {
        // We should never make an HTTPS request without a cert
        Q_ASSERT(!m_ServerCert.isNull());
        return;
    }

    for (const QSslError& error : errors) {
        if (m_ServerCert != error.certificate()) {
            ignoreErrors = false;
            break;
        }
    }

    if (ignoreErrors) {
        reply->ignoreSslErrors(errors);
    }
}
```
**File:** app/backend/nvhttp.cpp (L486-489)
```cpp
    QNetworkRequest request(url);

    // Add our client certificate
    request.setSslConfiguration(IdentityManager::get()->getSslConfig());
```
**File:** app/backend/nvpairingmanager.cpp (L217-248)
```cpp
    QString getCert = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&phrase=getservercert&salt=" +
                                                    salt.toHex() + "&clientcert=" + IdentityManager::get()->getCertificate().toHex(),
                                                    0);
    NvHTTP::verifyResponseStatus(getCert);
    if (NvHTTP::getXmlString(getCert, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #1";
        return PairState::FAILED;
    }

    QByteArray serverCertStr = NvHTTP::getXmlStringFromHex(getCert, "plaincert");
    if (serverCertStr == nullptr)
    {
        qCritical() << "Server likely already pairing";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::ALREADY_IN_PROGRESS;
    }

    QSslCertificate unverifiedServerCert = QSslCertificate(serverCertStr);
    if (unverifiedServerCert.isNull()) {
        Q_ASSERT(!unverifiedServerCert.isNull());

        qCritical() << "Failed to parse plaincert";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    // Pin this cert for TLS until pairing is complete. If successful, we will propagate
    // the cert into the NvComputer object and persist it.
    m_Http.setServerCert(unverifiedServerCert);
```
## Q6
How to pair up computer?
### Answer
The pairing process in Moonlight uses a 5-phase handshake protocol to securely exchange certificates between the client and server. Here's how it works:

## Client Certificate Generation and Storage

The client certificate is a self-signed X.509 certificate that is generated when Moonlight first runs. It uses a 2048-bit RSA key pair with SHA-256 signature and has a 20-year validity period. moonlight-qt:29-110 

The certificate and private key are stored in QSettings and cached in memory for subsequent use. moonlight-qt:112-139 

## The 5-Phase Pairing Process

The pairing process is implemented in the `NvPairingManager::pair()` method: moonlight-qt:191-354 

### Phase 1: Certificate Exchange

The client sends its certificate to the server as a hex-encoded string in the `clientcert` parameter of an HTTP request. At the same time, it receives the server's certificate in the response: moonlight-qt:217-227 

The server returns its certificate in the `plaincert` field of the XML response: moonlight-qt:229-244 

### Phase 2-5: Challenge-Response Authentication

Once the server certificate is received, it is immediately pinned to the HTTP client for all subsequent HTTPS requests: moonlight-qt:246-248 

The remaining phases involve encrypted challenge-response exchanges and signature verification to authenticate both parties and validate the PIN.

## Certificate Pinning

The `setServerCert()` method stores the server certificate for use in HTTPS connections: moonlight-qt:43-46 

During HTTPS connections, the `handleSslErrors()` method verifies that the server certificate matches the pinned certificate, preventing man-in-the-middle attacks: moonlight-qt:419-439 

## Persisting the Server Certificate

After successful pairing, the server certificate is stored in the `NvComputer` object: moonlight-qt:113-113 

The certificate is then persisted to settings by calling `saveHost()`: moonlight-qt:599-603 

## Notes

The pairing process uses AES-128-ECB encryption for challenge exchanges, with the encryption key derived from a salted PIN hash (SHA-256 for Gen 7+ servers, SHA-1 for older versions). The client certificate is sent as plain hex-encoded PEM data in Phase 1, while the server certificate is also returned as hex-encoded PEM. This certificate exchange happens over HTTP initially, but all subsequent pairing phases use HTTPS with the newly pinned certificate to ensure secure communication.
### Citations
**File:** app/backend/identitymanager.cpp (L29-110)
```cpp
void IdentityManager::createCredentials(QSettings& settings)
{
    X509* cert = X509_new();
    THROW_BAD_ALLOC_IF_NULL(cert);

    EVP_PKEY_CTX* ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_RSA, NULL);
    THROW_BAD_ALLOC_IF_NULL(ctx);

    EVP_PKEY_keygen_init(ctx);
    EVP_PKEY_CTX_set_rsa_keygen_bits(ctx, 2048);

    // pk must be initialized on input
    EVP_PKEY* pk = NULL;
    EVP_PKEY_keygen(ctx, &pk);

    EVP_PKEY_CTX_free(ctx);
    THROW_BAD_ALLOC_IF_NULL(pk);

    X509_set_version(cert, 2);
    ASN1_INTEGER_set(X509_get_serialNumber(cert), 0);
#if OPENSSL_VERSION_NUMBER < 0x10100000L
    X509_gmtime_adj(X509_get_notBefore(cert), 0);
    X509_gmtime_adj(X509_get_notAfter(cert), 60 * 60 * 24 * 365 * 20); // 20 yrs
#else
    ASN1_TIME* before = ASN1_STRING_dup(X509_get0_notBefore(cert));
    THROW_BAD_ALLOC_IF_NULL(before);
    ASN1_TIME* after = ASN1_STRING_dup(X509_get0_notAfter(cert));
    THROW_BAD_ALLOC_IF_NULL(after);

    X509_gmtime_adj(before, 0);
    X509_gmtime_adj(after, 60 * 60 * 24 * 365 * 20); // 20 yrs

    X509_set1_notBefore(cert, before);
    X509_set1_notAfter(cert, after);

    ASN1_STRING_free(before);
    ASN1_STRING_free(after);
#endif

    X509_set_pubkey(cert, pk);

    X509_NAME* name = X509_get_subject_name(cert);
    X509_NAME_add_entry_by_txt(name, "CN", MBSTRING_ASC,
                               reinterpret_cast<unsigned char *>(const_cast<char*>("NVIDIA GameStream Client")),
                               -1, -1, 0);
    X509_set_issuer_name(cert, name);

    X509_sign(cert, pk, EVP_sha256());

    BIO* biokey = BIO_new(BIO_s_mem());
    THROW_BAD_ALLOC_IF_NULL(biokey);
    PEM_write_bio_PrivateKey(biokey, pk, NULL, NULL, 0, NULL, NULL);

    BIO* biocert = BIO_new(BIO_s_mem());
    THROW_BAD_ALLOC_IF_NULL(biocert);
    PEM_write_bio_X509(biocert, cert);

    BUF_MEM* mem;
    BIO_get_mem_ptr(biokey, &mem);
    m_CachedPrivateKey = QByteArray(mem->data, (int)mem->length);

    BIO_get_mem_ptr(biocert, &mem);
    m_CachedPemCert = QByteArray(mem->data, (int)mem->length);

    X509_free(cert);
    EVP_PKEY_free(pk);
    BIO_free(biokey);
    BIO_free(biocert);

    // Check that the new keypair is valid before persisting it
    if (getSslCertificate().isNull()) {
        qFatal("Newly generated certificate is unreadable");
    }
    if (getSslKey().isNull()) {
        qFatal("Newly generated private key is unreadable");
    }

    settings.setValue(SER_CERT, m_CachedPemCert);
    settings.setValue(SER_KEY, m_CachedPrivateKey);

    qInfo() << "Wrote new identity credentials to settings";
}
```
**File:** app/backend/identitymanager.cpp (L112-139)
```cpp
IdentityManager::IdentityManager()
{
    QSettings settings;

    m_CachedPemCert = settings.value(SER_CERT).toByteArray();
    m_CachedPrivateKey = settings.value(SER_KEY).toByteArray();

    if (m_CachedPemCert.isEmpty() || m_CachedPrivateKey.isEmpty()) {
        qInfo() << "No existing credentials found";
        createCredentials(settings);
    }
    else if (getSslCertificate().isNull()) {
        qWarning() << "Certificate is unreadable";
        createCredentials(settings);
    }
    else if (getSslKey().isNull()) {
        qWarning() << "Private key is unreadable";
        createCredentials(settings);
    }

    // We should have valid credentials now. If not, we're screwed
    if (getSslCertificate().isNull()) {
        qFatal("Certificate is unreadable");
    }
    if (getSslKey().isNull()) {
        qFatal("Private key is unreadable");
    }
}
```
**File:** app/backend/nvpairingmanager.cpp (L191-354)
```cpp
NvPairingManager::pair(QString appVersion, QString pin, QSslCertificate& serverCert)
{
    int serverMajorVersion = NvHTTP::parseQuad(appVersion).at(0);
    qInfo() << "Pairing with server generation:" << serverMajorVersion;

    QCryptographicHash::Algorithm hashAlgo;
    int hashLength;
    if (serverMajorVersion >= 7)
    {
        // Gen 7+ uses SHA-256 hashing
        hashAlgo = QCryptographicHash::Sha256;
        hashLength = 32;
    }
    else
    {
        // Prior to Gen 7 uses SHA-1 hashing
        hashAlgo = QCryptographicHash::Sha1;
        hashLength = 20;
    }

    QByteArray salt = generateRandomBytes(16);
    QByteArray saltedPin = saltPin(salt, pin);

    QByteArray aesKey = QCryptographicHash::hash(saltedPin, hashAlgo).constData();
    aesKey.truncate(16);

    QString getCert = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&phrase=getservercert&salt=" +
                                                    salt.toHex() + "&clientcert=" + IdentityManager::get()->getCertificate().toHex(),
                                                    0);
    NvHTTP::verifyResponseStatus(getCert);
    if (NvHTTP::getXmlString(getCert, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #1";
        return PairState::FAILED;
    }

    QByteArray serverCertStr = NvHTTP::getXmlStringFromHex(getCert, "plaincert");
    if (serverCertStr == nullptr)
    {
        qCritical() << "Server likely already pairing";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::ALREADY_IN_PROGRESS;
    }

    QSslCertificate unverifiedServerCert = QSslCertificate(serverCertStr);
    if (unverifiedServerCert.isNull()) {
        Q_ASSERT(!unverifiedServerCert.isNull());

        qCritical() << "Failed to parse plaincert";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    // Pin this cert for TLS until pairing is complete. If successful, we will propagate
    // the cert into the NvComputer object and persist it.
    m_Http.setServerCert(unverifiedServerCert);

    QByteArray randomChallenge = generateRandomBytes(16);
    QByteArray encryptedChallenge = encrypt(randomChallenge, aesKey);
    QString challengeXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                         "pair",
                                                         "devicename=roth&updateState=1&clientchallenge=" +
                                                         encryptedChallenge.toHex(),
                                                         REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(challengeXml);
    if (NvHTTP::getXmlString(challengeXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #2";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray challengeResponseData = decrypt(m_Http.getXmlStringFromHex(challengeXml, "challengeresponse"), aesKey);
    QByteArray clientSecretData = generateRandomBytes(16);
    QByteArray challengeResponse;
    QByteArray serverResponse(challengeResponseData.data(), hashLength);

#if (OPENSSL_VERSION_NUMBER < 0x10002000L)
    ASN1_BIT_STRING *asnSignature = m_Cert->signature;
#elif (OPENSSL_VERSION_NUMBER < 0x10100000L)
    ASN1_BIT_STRING *asnSignature;
    X509_get0_signature(&asnSignature, NULL, m_Cert);
#else
    const ASN1_BIT_STRING *asnSignature;
    X509_get0_signature(&asnSignature, NULL, m_Cert);
#endif

    challengeResponse.append(challengeResponseData.data() + hashLength, 16);
    challengeResponse.append(reinterpret_cast<char*>(asnSignature->data), asnSignature->length);
    challengeResponse.append(clientSecretData);

    QByteArray paddedHash = QCryptographicHash::hash(challengeResponse, hashAlgo);
    paddedHash.resize(32);
    QByteArray encryptedChallengeResponseHash = encrypt(paddedHash, aesKey);
    QString respXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&serverchallengeresp=" +
                                                    encryptedChallengeResponseHash.toHex(),
                                                    REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(respXml);
    if (NvHTTP::getXmlString(respXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #3";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray pairingSecret = NvHTTP::getXmlStringFromHex(respXml, "pairingsecret");
    QByteArray serverSecret = pairingSecret.left(16);
    QByteArray serverSignature = pairingSecret.mid(16);

    if (!verifySignature(serverSecret,
                         serverSignature,
                         serverCertStr))
    {
        qCritical() << "MITM detected";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray expectedResponseData;
    expectedResponseData.append(randomChallenge);
    expectedResponseData.append(getSignatureFromPemCert(serverCertStr));
    expectedResponseData.append(serverSecret);
    if (QCryptographicHash::hash(expectedResponseData, hashAlgo) != serverResponse)
    {
        qCritical() << "Incorrect PIN";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::PIN_WRONG;
    }

    QByteArray clientPairingSecret;
    clientPairingSecret.append(clientSecretData);
    clientPairingSecret.append(signMessage(clientSecretData));

    QString secretRespXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                          "pair",
                                                          "devicename=roth&updateState=1&clientpairingsecret=" +
                                                          clientPairingSecret.toHex(),
                                                          REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(secretRespXml);
    if (NvHTTP::getXmlString(secretRespXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #4";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QString pairChallengeXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttps,
                                                             "pair",
                                                             "devicename=roth&updateState=1&phrase=pairchallenge",
                                                             REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(pairChallengeXml);
    if (NvHTTP::getXmlString(pairChallengeXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #5";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    serverCert = std::move(unverifiedServerCert);
    return PairState::PAIRED;
```
**File:** app/backend/nvhttp.cpp (L43-46)
```cpp
void NvHTTP::setServerCert(QSslCertificate serverCert)
{
    m_ServerCert = serverCert;
}
```
**File:** app/backend/nvhttp.cpp (L419-439)
```cpp
void NvHTTP::handleSslErrors(QNetworkReply* reply, const QList<QSslError>& errors)
{
    bool ignoreErrors = true;

    if (m_ServerCert.isNull()) {
        // We should never make an HTTPS request without a cert
        Q_ASSERT(!m_ServerCert.isNull());
        return;
    }

    for (const QSslError& error : errors) {
        if (m_ServerCert != error.certificate()) {
            ignoreErrors = false;
            break;
        }
    }

    if (ignoreErrors) {
        reply->ignoreSslErrors(errors);
    }
}
```
**File:** app/backend/nvcomputer.h (L113-113)
```text
    QSslCertificate serverCert;
```
**File:** app/backend/computermanager.cpp (L599-603)
```cpp
           case NvPairingManager::PairState::PAIRED:
               // Persist the newly pinned server certificate for this host
               m_ComputerManager->saveHost(m_Computer);

               emit pairingCompleted(m_Computer, nullptr);
```
## Q7
When the client has launched/started the game and begun streaming before disconnecting, how does the client recover the connection?
### Answer
You're asking about how Moonlight handles connection recovery when a streaming session disconnects after it has already started.

## Answer

When a streaming session disconnects, Moonlight determines whether to call `/launch` or `/resume` based on the `currentgame` value from the host's `/serverinfo` response. moonlight-qt:1586-1586 

### Resume vs Launch Decision

In `Session::startConnectionAsync()`, the code checks if `m_Computer->currentgame` is non-zero (indicating a game is already running on the host): moonlight-qt:1556-1557 

If the game is already running, it calls `NvHTTP::startApp()` with the `"resume"` parameter instead of `"launch"`: moonlight-qt:1586-1593 

```cpp
http.startApp(m_Computer->currentgame != 0 ? "resume" : "launch",
              m_Computer->isNvidiaServerSoftware,
              m_App.id, &m_StreamConfig,
              enableGameOptimizations,
              m_Preferences->playAudioOnHost,
              m_InputHandler->getAttachedGamepadMask(),
              !m_Preferences->multiController,
              rtspSessionUrl);
```

### How Resume Works

The `/resume` endpoint tells the host to reconnect to an existing game session rather than starting a new one.<cite /> This preserves the game state and allows the client to rejoin the same streaming session.<cite />

The same connection establishment process follows after calling `/resume` - the RTSP session URL is obtained from the response and passed to `LiStartConnection()` to establish the streaming connection. moonlight-qt:1678-1680 

### State Detection

The host's state is tracked through periodic `/serverinfo` polling, which updates the `currentgame` field in the `NvComputer` object.<cite /> When the state shows `SUNSHINE_SERVER_BUSY` (as in your earlier example) with a non-zero `currentgame` value, Moonlight knows a game is already running and will use resume instead of launch.<cite />

## Notes

The resume functionality allows seamless reconnection to an existing game session without restarting the game on the host. This is particularly useful for temporary network interruptions or when the client application crashes but the host game continues running. The same certificate authentication and connection establishment process is used for both launch and resume operations.

Wiki pages you might want to explore:
- [User Interface System (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2)
- [Streaming Core (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#4)
### Citations
**File:** app/streaming/session.cpp (L1556-1557)
```cpp
    Q_ASSERT(m_Computer->currentGameId == 0 ||
             m_Computer->currentGameId == m_App.id);
```
**File:** app/streaming/session.cpp (L1586-1593)
```cpp
        http.startApp(m_Computer->currentGameId != 0 ? "resume" : "launch",
                      m_Computer->isNvidiaServerSoftware,
                      m_App.id, &m_StreamConfig,
                      enableGameOptimizations,
                      m_Preferences->playAudioOnHost,
                      m_InputHandler->getAttachedGamepadMask(),
                      !m_Preferences->multiController,
                      rtspSessionUrl);
```
**File:** app/streaming/session.cpp (L1678-1680)
```cpp
    int err = LiStartConnection(&hostInfo, &m_StreamConfig, &k_ConnCallbacks,
                                &m_VideoCallbacks, &m_AudioCallbacks,
                                NULL, 0, NULL, 0);
```
## Q8
How does the client terminate the connection?
### Answer
You're asking about how Moonlight terminates a streaming connection when the user wants to disconnect.

## Answer

Moonlight provides multiple ways to terminate a streaming connection:

### User-Initiated Disconnection

Users can disconnect from an active streaming session using keyboard shortcuts or gamepad button combinations. The UI displays a tip showing these options: **Ctrl+Alt+Shift+Q** for keyboard or **Start+Select+L1+R1** for gamepad. moonlight-qt:167-168 

### Connection Termination Flow

When a connection terminates, the `Session::clConnectionTerminated()` callback is invoked with an error code. moonlight-qt:98-155  This callback:

1. **Performs port testing** to diagnose connectivity issues if the termination was unexpected moonlight-qt:100-101 

2. **Determines if termination was graceful** - If the error code is `ML_ERROR_GRACEFUL_TERMINATION`, no error dialog is shown moonlight-qt:105-106 

3. **Displays error messages** for unexpected terminations (network issues, video encoding errors, etc.) moonlight-qt:108-144 

4. **Pushes a quit event** to the SDL event loop to exit the streaming session moonlight-qt:150-154 

### UI Cleanup After Termination

After the session ends, the `StreamSegue::sessionFinished()` method handles cleanup: moonlight-qt:73-108 

1. **Re-enables gamepad navigation** for the UI moonlight-qt:79-80 

2. **Pops the stream view** from the navigation stack to return to the previous screen moonlight-qt:93-94 

3. **Shows the main window** again moonlight-qt:96-97 

4. **Displays any error dialogs** if the termination was unexpected moonlight-qt:103-106 

The session object is then garbage collected to free resources. moonlight-qt:110-116 

### Quitting Running Apps

Moonlight can also terminate a running game on the host without streaming it. The `ComputerManager::quitRunningApp()` method creates a `PendingQuitTask` that sends a quit request to the host server. moonlight-qt:675-682  This is used when users want to stop a game remotely without connecting to it.

## Notes

The termination process distinguishes between graceful disconnections (user-initiated) and unexpected terminations (network errors, encoding failures). For unexpected terminations, Moonlight performs network diagnostics and displays helpful error messages to guide troubleshooting. The same cleanup process applies whether the user disconnects manually or the connection fails unexpectedly.

Wiki pages you might want to explore:
- [User Interface System (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2)
- [PC Discovery View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.1)
### Citations
**File:** app/gui/StreamSegue.qml (L73-108)
```text
    function sessionFinished(portTestResult)
    {
        if (portTestResult !== 0 && portTestResult !== -1 && streamSegueErrorDialog.text) {
            streamSegueErrorDialog.text += "\n\n" + qsTr("This PC's Internet connection is blocking Moonlight. Streaming over the Internet may not work while connected to this network.")
        }

        // Re-enable GUI gamepad usage now
        SdlGamepadKeyNavigation.enable()

        if (quitAfter) {
            if (streamSegueErrorDialog.text) {
                // Quit when the error dialog is acknowledged
                streamSegueErrorDialog.quitAfter = quitAfter
                streamSegueErrorDialog.open()
            }
            else {
                // Quit immediately
                Qt.quit()
            }
        } else {
            // Exit this view
            stackView.pop()

            // Show the Qt window again after streaming
            window.visible = true

            // Display any launch errors. We do this after
            // the Qt UI is visible again to prevent losing
            // focus on the dialog which would impact gamepad
            // users.
            if (streamSegueErrorDialog.text) {
                streamSegueErrorDialog.quitAfter = quitAfter
                streamSegueErrorDialog.open()
            }
        }
    }
```
**File:** app/gui/StreamSegue.qml (L110-116)
```text
    function sessionReadyForDeletion()
    {
        // Garbage collect the Session object since it's pretty heavyweight
        // and keeps other libraries (like SDL_TTF) around until it is deleted.
        session = null
        gc()
    }
```
**File:** app/gui/StreamSegue.qml (L167-168)
```text
            hintText.text = qsTr("Tip:") + " " + qsTr("Press %1 to disconnect your session").arg(SdlGamepadKeyNavigation.getConnectedGamepads() > 0 ?
                                                  qsTr("Start+Select+L1+R1") : qsTr("Ctrl+Alt+Shift+Q"))
```
**File:** app/streaming/session.cpp (L98-155)
```cpp
void Session::clConnectionTerminated(int errorCode)
{
    unsigned int portFlags = LiGetPortFlagsFromTerminationErrorCode(errorCode);
    s_ActiveSession->m_PortTestResults = LiTestClientConnectivity(CONN_TEST_SERVER, 443, portFlags);

    // Display the termination dialog if this was not intended
    switch (errorCode) {
    case ML_ERROR_GRACEFUL_TERMINATION:
        break;

    case ML_ERROR_NO_VIDEO_TRAFFIC:
        s_ActiveSession->m_UnexpectedTermination = true;

        char ports[128];
        SDL_assert(portFlags != 0);
        LiStringifyPortFlags(portFlags, ", ", ports, sizeof(ports));
        emit s_ActiveSession->displayLaunchError(tr("No video received from host.") + "\n\n"+
                                                 tr("Check your firewall and port forwarding rules for port(s): %1").arg(ports));
        break;

    case ML_ERROR_NO_VIDEO_FRAME:
        s_ActiveSession->m_UnexpectedTermination = true;
        emit s_ActiveSession->displayLaunchError(tr("Your network connection isn't performing well. Reduce your video bitrate setting or try a faster connection."));
        break;

    case ML_ERROR_PROTECTED_CONTENT:
    case ML_ERROR_UNEXPECTED_EARLY_TERMINATION:
        s_ActiveSession->m_UnexpectedTermination = true;
        emit s_ActiveSession->displayLaunchError(tr("Something went wrong on your host PC when starting the stream.") + "\n\n" +
                                                 tr("Make sure you don't have any DRM-protected content open on your host PC. You can also try restarting your host PC."));
        break;

    case ML_ERROR_FRAME_CONVERSION:
        s_ActiveSession->m_UnexpectedTermination = true;
        emit s_ActiveSession->displayLaunchError(tr("The host PC reported a fatal video encoding error.") + "\n\n" +
                                                 tr("Try disabling HDR mode, changing the streaming resolution, or changing your host PC's display resolution."));
        break;

    default:
        s_ActiveSession->m_UnexpectedTermination = true;

        // We'll assume large errors are hex values
        bool hexError = qAbs(errorCode) > 1000;
        emit s_ActiveSession->displayLaunchError(tr("Connection terminated") + "\n\n" +
                                                 tr("Error code: %1").arg(errorCode, hexError ? 8 : 0, hexError ? 16 : 10, QChar('0')));
        break;
    }

    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION,
                 "Connection terminated: %d",
                 errorCode);

    // Push a quit event to the main loop
    SDL_Event event;
    event.type = SDL_QUIT;
    event.quit.timestamp = SDL_GetTicks();
    SDL_PushEvent(&event);
}
```
**File:** app/backend/computermanager.cpp (L675-682)
```cpp
void ComputerManager::quitRunningApp(NvComputer* computer)
{
    QWriteLocker lock(&computer->lock);
    computer->pendingQuit = true;

    PendingQuitTask* quit = new PendingQuitTask(this, computer);
    QThreadPool::globalInstance()->start(quit);
}
```
## Q9
Please list all the APIs used for the client and server interaction, including their purposes and required parameters, and list the APIs needed for the entire process from adding a computer to selecting one in the app list and starting a connection to ending the connection.
### Answer
Based on my analysis of the Moonlight codebase, here are all the client-server interaction APIs used throughout the entire process:

## 1. **Adding a Computer**

### Server Discovery - `serverinfo` API
**Purpose**: Discover and retrieve information about the host PC, including pairing status, current game, server version, and HTTPS port. moonlight-qt:124-187 

**Required Parameters**:
- `uniqueid`: Common UID for Moonlight clients (fixed: "0123456789ABCDEF")
- `uuid`: Random UUID for the request

**Protocol**: HTTP initially (before pairing), then HTTPS (after pairing)

### Pairing - 5-Phase Cryptographic Handshake

**Purpose**: Establish trust between client and host PC through certificate exchange and PIN verification. moonlight-qt:191-355 

**Phase 1 - Get Server Certificate**:
- Endpoint: `pair`
- Parameters:
  - `devicename=roth`
  - `updateState=1`
  - `phrase=getservercert`
  - `salt`: 16-byte random salt (hex)
  - `clientcert`: Client certificate (hex)

**Phase 2 - Client Challenge**:
- Endpoint: `pair`
- Parameters:
  - `devicename=roth`
  - `updateState=1`
  - `clientchallenge`: Encrypted 16-byte challenge (hex)

**Phase 3 - Server Challenge Response**:
- Endpoint: `pair`
- Parameters:
  - `devicename=roth`
  - `updateState=1`
  - `serverchallengeresp`: Encrypted challenge response hash (hex)

**Phase 4 - Client Pairing Secret**:
- Endpoint: `pair`
- Parameters:
  - `devicename=roth`
  - `updateState=1`
  - `clientpairingsecret`: Client secret + signature (hex)

**Phase 5 - Final Challenge (HTTPS)**:
- Endpoint: `pair`
- Parameters:
  - `devicename=roth`
  - `updateState=1`
  - `phrase=pairchallenge`

**Protocol**: HTTP for phases 1-4, HTTPS for phase 5

## 2. **Selecting an App**

### App List - `applist` API
**Purpose**: Retrieve the list of available applications on the host PC. moonlight-qt:288-328 

**Required Parameters**:
- `uniqueid`: "0123456789ABCDEF"
- `uuid`: Random UUID

**Protocol**: HTTPS (requires prior pairing)

**Response**: XML with app information including:
- `AppTitle`: Application name
- `ID`: Application ID
- `IsHdrSupported`: HDR capability
- `IsAppCollectorGame`: Whether it's an App Collector game

### Box Art - `getBoxArt` API
**Purpose**: Download application cover art/thumbnails. moonlight-qt:178-179 moonlight-qt:107-129 

**Required Parameters**:
- `appId`: Application ID

**Protocol**: HTTPS
**Response**: Image data (various formats, cached as PNG locally)

## 3. **Starting a Streaming Connection**

### Launch/Resume - `launch` or `resume` API
**Purpose**: Start a new streaming session or resume an existing one. moonlight-qt:190-236 moonlight-qt:1582-1600 

**Endpoint**: `launch` (new session) or `resume` (existing session)

**Required Parameters**:
- `uniqueid`: "0123456789ABCDEF"
- `uuid`: Random UUID
- `appid`: Application ID to launch
- `mode`: Resolution and FPS (format: `{width}x{height}x{fps}`)
- `additionalStates=1`: Enable additional states
- `sops`: Stream optimization settings (0 or 1)
- `rikey`: Remote input AES key (hex)
- `rikeyid`: Remote input key ID
- `hdrMode`: HDR mode flag (included if HDR supported)
- `clientHdrCapVersion`, `clientHdrCapSupportedFlagsInUint32`, `clientHdrCapMetaDataId`, `clientHdrCapDisplayData`: HDR capability parameters (if HDR mode)
- `localAudioPlayMode`: Play audio on host (0 or 1)
- `surroundAudioInfo`: Surround audio configuration
- `remoteControllersBitmap`: Gamepad mask
- `gcmap`: Gamepad controller map
- `gcpersist`: Persist game controllers on disconnect (0 or 1)
- Additional parameters from `LiGetLaunchUrlQueryParameters()`

**Protocol**: HTTPS

**Response**: XML containing `sessionUrl0` (RTSP session URL)

**Decision Logic**: The verb is determined based on whether a game is currently running: moonlight-qt:1586-1593 

## 4. **Ending a Streaming Connection**

### Quit App - `cancel` API
**Purpose**: Terminate the currently running application on the host PC. moonlight-qt:238-259 

**Required Parameters**:
- `uniqueid`: "0123456789ABCDEF"
- `uuid`: Random UUID

**Protocol**: HTTPS

**Timeout**: 30 seconds

**Note**: The quit operation is optional based on user preferences: moonlight-qt:1554-1558 

## Additional APIs

### Wake-on-LAN
**Purpose**: Wake up a sleeping/powered-off host PC. moonlight-qt:1-50 

**Protocol**: UDP magic packets sent to multiple addresses and ports (9, 47009, and dynamic ports 47998-48010)

### Unpair - `unpair` API
**Purpose**: Remove pairing relationship (used during pairing failures). moonlight-qt:232-234 

**Required Parameters**: Standard uniqueid and uuid

**Protocol**: HTTP

## Notes

- All HTTP/HTTPS requests use a common `uniqueid` of "0123456789ABCDEF" to allow Moonlight clients to manage each other's sessions
- Each request includes a random `uuid` parameter generated via `QUuid::createUuid()`
- Certificate pinning is implemented for HTTPS connections to prevent MITM attacks
- Timeouts vary by operation: 2s (fast-fail), 5s (normal), 30s (resume/quit), 120s (launch)
- The base URL format is `http(s)://{host}:{port}/{command}?{parameters}`
### Citations
**File:** app/backend/nvhttp.cpp (L124-187)
```cpp
NvHTTP::getServerInfo(NvLogLevel logLevel, bool fastFail)
{
    QString serverInfo;

    // Check if we have a pinned cert and HTTPS port for this host yet
    if (!m_ServerCert.isNull() && httpsPort() != 0)
    {
        try
        {
            // Always try HTTPS first, since it properly reports
            // pairing status (and a few other attributes).
            serverInfo = openConnectionToString(m_BaseUrlHttps,
                                                "serverinfo",
                                                nullptr,
                                                fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                                logLevel);
            // Throws if the request failed
            verifyResponseStatus(serverInfo);
        }
        catch (const GfeHttpResponseException& e)
        {
            if (e.getStatusCode() == 401)
            {
                // Certificate validation error, fallback to HTTP
                serverInfo = openConnectionToString(m_BaseUrlHttp,
                                                    "serverinfo",
                                                    nullptr,
                                                    fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                                    logLevel);
                verifyResponseStatus(serverInfo);
            }
            else
            {
                // Rethrow real errors
                throw e;
            }
        }
    }
    else
    {
        // Only use HTTP prior to pairing or fetching HTTPS port
        serverInfo = openConnectionToString(m_BaseUrlHttp,
                                            "serverinfo",
                                            nullptr,
                                            fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                            logLevel);
        verifyResponseStatus(serverInfo);

        // Populate the HTTPS port
        uint16_t httpsPort = getXmlString(serverInfo, "HttpsPort").toUShort();
        if (httpsPort == 0) {
            httpsPort = DEFAULT_HTTPS_PORT;
        }
        setHttpsPort(httpsPort);

        // If we just needed to determine the HTTPS port, we'll try again over
        // HTTPS now that we have the port number
        if (!m_ServerCert.isNull()) {
            return getServerInfo(logLevel, fastFail);
        }
    }

    return serverInfo;
}
```
**File:** app/backend/nvhttp.cpp (L190-236)
```cpp
NvHTTP::startApp(QString verb,
                 bool isGfe,
                 int appId,
                 PSTREAM_CONFIGURATION streamConfig,
                 bool sops,
                 bool localAudio,
                 int gamepadMask,
                 bool persistGameControllersOnDisconnect,
                 QString& rtspSessionUrl)
{
    int riKeyId;

    memcpy(&riKeyId, streamConfig->remoteInputAesIv, sizeof(riKeyId));
    riKeyId = qFromBigEndian(riKeyId);

    QString response =
            openConnectionToString(m_BaseUrlHttps,
                                   verb,
                                   "appid="+QString::number(appId)+
                                   "&mode="+QString::number(streamConfig->width)+"x"+
                                   QString::number(streamConfig->height)+"x"+
                                   // Using an FPS value over 60 causes SOPS to default to 720p60,
                                   // so force it to 0 to ensure the correct resolution is set. We
                                   // used to use 60 here but that locked the frame rate to 60 FPS
                                   // on GFE 3.20.3. We don't need this hack for Sunshine.
                                   QString::number((streamConfig->fps > 60 && isGfe) ? 0 : streamConfig->fps)+
                                   "&additionalStates=1&sops="+QString::number(sops ? 1 : 0)+
                                   "&rikey="+QByteArray(streamConfig->remoteInputAesKey, sizeof(streamConfig->remoteInputAesKey)).toHex()+
                                   "&rikeyid="+QString::number(riKeyId)+
                                   ((streamConfig->supportedVideoFormats & VIDEO_FORMAT_MASK_10BIT) ?
                                       "&hdrMode=1&clientHdrCapVersion=0&clientHdrCapSupportedFlagsInUint32=0&clientHdrCapMetaDataId=NV_STATIC_METADATA_TYPE_1&clientHdrCapDisplayData=0x0x0x0x0x0x0x0x0x0x0" :
                                        "")+
                                   "&localAudioPlayMode="+QString::number(localAudio ? 1 : 0)+
                                   "&surroundAudioInfo="+QString::number(SURROUNDAUDIOINFO_FROM_AUDIO_CONFIGURATION(streamConfig->audioConfiguration))+
                                   "&remoteControllersBitmap="+QString::number(gamepadMask)+
                                   "&gcmap="+QString::number(gamepadMask)+
                                   "&gcpersist="+QString::number(persistGameControllersOnDisconnect ? 1 : 0)+
                                   LiGetLaunchUrlQueryParameters(),
                                   LAUNCH_TIMEOUT_MS);

    qInfo() << "Launch response:" << response;

    // Throws if the request failed
    verifyResponseStatus(response);

    rtspSessionUrl = getXmlString(response, "sessionUrl0");
}
```
**File:** app/backend/nvhttp.cpp (L238-259)
```cpp
void
NvHTTP::quitApp()
{
    QString response =
            openConnectionToString(m_BaseUrlHttps,
                                   "cancel",
                                   nullptr,
                                   QUIT_TIMEOUT_MS);

    qInfo() << "Quit response:" << response;

    // Throws if the request failed
    verifyResponseStatus(response);

    // Newer GFE versions will just return success even if quitting fails
    // if we're not the original requester.
    if (getCurrentGame(getServerInfo(NvHTTP::NVLL_ERROR)) != 0) {
        // Generate a synthetic GfeResponseException letting the caller know
        // that they can't kill someone else's stream.
        throw GfeHttpResponseException(599, "");
    }
}
```
**File:** app/backend/nvhttp.cpp (L288-328)
```cpp
QVector<NvApp>
NvHTTP::getAppList()
{
    QString appxml = openConnectionToString(m_BaseUrlHttps,
                                            "applist",
                                            nullptr,
                                            REQUEST_TIMEOUT_MS,
                                            NvLogLevel::NVLL_ERROR);
    verifyResponseStatus(appxml);

    QXmlStreamReader xmlReader(appxml);
    QVector<NvApp> apps;
    while (!xmlReader.atEnd()) {
        while (xmlReader.readNextStartElement()) {
            auto name = xmlReader.name();
            if (name == QString("App")) {
                // We must have a valid app before advancing to the next one
                if (!apps.isEmpty() && !apps.last().isInitialized()) {
                    qWarning() << "Invalid applist XML";
                    Q_ASSERT(false);
                    return QVector<NvApp>();
                }
                apps.append(NvApp());
            }
            else if (name == QString("AppTitle")) {
                apps.last().name = xmlReader.readElementText();
            }
            else if (name == QString("ID")) {
                apps.last().id = xmlReader.readElementText().toInt();
            }
            else if (name == QString("IsHdrSupported")) {
                apps.last().hdrSupported = xmlReader.readElementText() == "1";
            }
            else if (name == QString("IsAppCollectorGame")) {
                apps.last().isAppCollectorGame = xmlReader.readElementText() == "1";
            }
        }
    }

    return apps;
}
```
**File:** app/backend/nvpairingmanager.cpp (L191-355)
```cpp
NvPairingManager::pair(QString appVersion, QString pin, QSslCertificate& serverCert)
{
    int serverMajorVersion = NvHTTP::parseQuad(appVersion).at(0);
    qInfo() << "Pairing with server generation:" << serverMajorVersion;

    QCryptographicHash::Algorithm hashAlgo;
    int hashLength;
    if (serverMajorVersion >= 7)
    {
        // Gen 7+ uses SHA-256 hashing
        hashAlgo = QCryptographicHash::Sha256;
        hashLength = 32;
    }
    else
    {
        // Prior to Gen 7 uses SHA-1 hashing
        hashAlgo = QCryptographicHash::Sha1;
        hashLength = 20;
    }

    QByteArray salt = generateRandomBytes(16);
    QByteArray saltedPin = saltPin(salt, pin);

    QByteArray aesKey = QCryptographicHash::hash(saltedPin, hashAlgo).constData();
    aesKey.truncate(16);

    QString getCert = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&phrase=getservercert&salt=" +
                                                    salt.toHex() + "&clientcert=" + IdentityManager::get()->getCertificate().toHex(),
                                                    0);
    NvHTTP::verifyResponseStatus(getCert);
    if (NvHTTP::getXmlString(getCert, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #1";
        return PairState::FAILED;
    }

    QByteArray serverCertStr = NvHTTP::getXmlStringFromHex(getCert, "plaincert");
    if (serverCertStr == nullptr)
    {
        qCritical() << "Server likely already pairing";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::ALREADY_IN_PROGRESS;
    }

    QSslCertificate unverifiedServerCert = QSslCertificate(serverCertStr);
    if (unverifiedServerCert.isNull()) {
        Q_ASSERT(!unverifiedServerCert.isNull());

        qCritical() << "Failed to parse plaincert";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    // Pin this cert for TLS until pairing is complete. If successful, we will propagate
    // the cert into the NvComputer object and persist it.
    m_Http.setServerCert(unverifiedServerCert);

    QByteArray randomChallenge = generateRandomBytes(16);
    QByteArray encryptedChallenge = encrypt(randomChallenge, aesKey);
    QString challengeXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                         "pair",
                                                         "devicename=roth&updateState=1&clientchallenge=" +
                                                         encryptedChallenge.toHex(),
                                                         REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(challengeXml);
    if (NvHTTP::getXmlString(challengeXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #2";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray challengeResponseData = decrypt(m_Http.getXmlStringFromHex(challengeXml, "challengeresponse"), aesKey);
    QByteArray clientSecretData = generateRandomBytes(16);
    QByteArray challengeResponse;
    QByteArray serverResponse(challengeResponseData.data(), hashLength);

#if (OPENSSL_VERSION_NUMBER < 0x10002000L)
    ASN1_BIT_STRING *asnSignature = m_Cert->signature;
#elif (OPENSSL_VERSION_NUMBER < 0x10100000L)
    ASN1_BIT_STRING *asnSignature;
    X509_get0_signature(&asnSignature, NULL, m_Cert);
#else
    const ASN1_BIT_STRING *asnSignature;
    X509_get0_signature(&asnSignature, NULL, m_Cert);
#endif

    challengeResponse.append(challengeResponseData.data() + hashLength, 16);
    challengeResponse.append(reinterpret_cast<char*>(asnSignature->data), asnSignature->length);
    challengeResponse.append(clientSecretData);

    QByteArray paddedHash = QCryptographicHash::hash(challengeResponse, hashAlgo);
    paddedHash.resize(32);
    QByteArray encryptedChallengeResponseHash = encrypt(paddedHash, aesKey);
    QString respXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&serverchallengeresp=" +
                                                    encryptedChallengeResponseHash.toHex(),
                                                    REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(respXml);
    if (NvHTTP::getXmlString(respXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #3";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray pairingSecret = NvHTTP::getXmlStringFromHex(respXml, "pairingsecret");
    QByteArray serverSecret = pairingSecret.left(16);
    QByteArray serverSignature = pairingSecret.mid(16);

    if (!verifySignature(serverSecret,
                         serverSignature,
                         serverCertStr))
    {
        qCritical() << "MITM detected";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray expectedResponseData;
    expectedResponseData.append(randomChallenge);
    expectedResponseData.append(getSignatureFromPemCert(serverCertStr));
    expectedResponseData.append(serverSecret);
    if (QCryptographicHash::hash(expectedResponseData, hashAlgo) != serverResponse)
    {
        qCritical() << "Incorrect PIN";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::PIN_WRONG;
    }

    QByteArray clientPairingSecret;
    clientPairingSecret.append(clientSecretData);
    clientPairingSecret.append(signMessage(clientSecretData));

    QString secretRespXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                          "pair",
                                                          "devicename=roth&updateState=1&clientpairingsecret=" +
                                                          clientPairingSecret.toHex(),
                                                          REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(secretRespXml);
    if (NvHTTP::getXmlString(secretRespXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #4";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QString pairChallengeXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttps,
                                                             "pair",
                                                             "devicename=roth&updateState=1&phrase=pairchallenge",
                                                             REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(pairChallengeXml);
    if (NvHTTP::getXmlString(pairChallengeXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #5";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    serverCert = std::move(unverifiedServerCert);
    return PairState::PAIRED;
}
```
**File:** app/backend/nvhttp.h (L178-179)
```text
    QImage
    getBoxArt(int appId);
```
**File:** app/backend/boxartmanager.cpp (L107-129)
```cpp
QUrl BoxArtManager::loadBoxArtFromNetwork(NvComputer* computer, int appId)
{
    NvHTTP http(computer);

    QString cachePath = getFilePathForBoxArt(computer, appId);
    QImage image;
    try {
        image = http.getBoxArt(appId);
    } catch (...) {}

    // Cache the box art on disk if it loaded
    if (!image.isNull()) {
        if (image.save(cachePath)) {
            return QUrl::fromLocalFile(cachePath);
        }
        else {
            // A failed save() may leave a zero byte file. Make sure that's removed.
            QFile(cachePath).remove();
        }
    }

    return QUrl();
}
```
**File:** app/streaming/session.cpp (L1554-1558)
```cpp
    // The UI should have ensured the old game was already quit
    // if we decide to stream a different game.
    Q_ASSERT(m_Computer->currentGameId == 0 ||
             m_Computer->currentGameId == m_App.id);

```
**File:** app/streaming/session.cpp (L1582-1600)
```cpp
    QString rtspSessionUrl;

    try {
        NvHTTP http(m_Computer);
        http.startApp(m_Computer->currentGameId != 0 ? "resume" : "launch",
                      m_Computer->isNvidiaServerSoftware,
                      m_App.id, &m_StreamConfig,
                      enableGameOptimizations,
                      m_Preferences->playAudioOnHost,
                      m_InputHandler->getAttachedGamepadMask(),
                      !m_Preferences->multiController,
                      rtspSessionUrl);
    } catch (const GfeHttpResponseException& e) {
        emit displayLaunchError(tr("Host returned error: %1").arg(e.toQString()));
        return false;
    } catch (const QtNetworkReplyException& e) {
        emit displayLaunchError(e.toQString());
        return false;
    }
```
**File:** app/backend/nvcomputer.cpp (L1-50)
```cpp
#include "nvcomputer.h"
#include "nvapp.h"
#include "settings/compatfetcher.h"

#include <QUdpSocket>
#include <QHostInfo>
#include <QNetworkInterface>
#include <QNetworkProxy>

#define SER_NAME "hostname"
#define SER_UUID "uuid"
#define SER_MAC "mac"
#define SER_LOCALADDR "localaddress"
#define SER_LOCALPORT "localport"
#define SER_REMOTEADDR "remoteaddress"
#define SER_REMOTEPORT "remoteport"
#define SER_MANUALADDR "manualaddress"
#define SER_MANUALPORT "manualport"
#define SER_IPV6ADDR "ipv6address"
#define SER_IPV6PORT "ipv6port"
#define SER_APPLIST "apps"
#define SER_SRVCERT "srvcert"
#define SER_CUSTOMNAME "customname"
#define SER_NVIDIASOFTWARE "nvidiasw"

NvComputer::NvComputer(QSettings& settings)
{
    this->name = settings.value(SER_NAME).toString();
    this->uuid = settings.value(SER_UUID).toString();
    this->hasCustomName = settings.value(SER_CUSTOMNAME).toBool();
    this->macAddress = settings.value(SER_MAC).toByteArray();
    this->localAddress = NvAddress(settings.value(SER_LOCALADDR).toString(),
                                   settings.value(SER_LOCALPORT, QVariant(DEFAULT_HTTP_PORT)).toUInt());
    this->remoteAddress = NvAddress(settings.value(SER_REMOTEADDR).toString(),
                                    settings.value(SER_REMOTEPORT, QVariant(DEFAULT_HTTP_PORT)).toUInt());
    this->ipv6Address = NvAddress(settings.value(SER_IPV6ADDR).toString(),
                                  settings.value(SER_IPV6PORT, QVariant(DEFAULT_HTTP_PORT)).toUInt());
    this->manualAddress = NvAddress(settings.value(SER_MANUALADDR).toString(),
                                    settings.value(SER_MANUALPORT, QVariant(DEFAULT_HTTP_PORT)).toUInt());
    this->serverCert = QSslCertificate(settings.value(SER_SRVCERT).toByteArray());
    this->isNvidiaServerSoftware = settings.value(SER_NVIDIASOFTWARE).toBool();

    int appCount = settings.beginReadArray(SER_APPLIST);
    this->appList.reserve(appCount);
    for (int i = 0; i < appCount; i++) {
        settings.setArrayIndex(i);

        NvApp app(settings);
        this->appList.append(app);
    }
```
## Q10
The server completes the pairing by inputting the PIN code displayed by the client. How does the client wait for the server's response to complete the pairing during the time the PIN code is generated and the user inputs the PIN on the server side?
### Answer
You're asking about how the Moonlight client waits for the server to complete pairing after displaying the PIN code to the user.

## Answer

The client doesn't actively poll or wait for the server's response during pairing. Instead, the pairing process is **synchronous and blocking** - the client sends requests sequentially through all 5 phases and waits for each response before proceeding to the next phase.

### Pairing Execution Flow

When the user clicks on an unpaired PC, the client generates a PIN and displays it in a dialog: moonlight-qt:239-246 

The pairing task runs in a background thread via `PendingPairingTask`: moonlight-qt:564-582 

### The Blocking Nature of Pairing

Inside `NvPairingManager::pair()`, each phase makes an HTTP/HTTPS request and **blocks waiting for the response** before proceeding: moonlight-qt:217-227 

The server validates the PIN during Phase 3 (server challenge response). If the user hasn't entered the PIN yet on the server side, the server simply doesn't respond or returns an error, causing the pairing to fail: moonlight-qt:287-298 

### PIN Validation

The PIN validation happens when the client sends the encrypted challenge response hash in Phase 3. The server decrypts this using the PIN-derived key and verifies it matches the expected value: moonlight-qt:313-322 

If the PIN is incorrect (user entered wrong PIN on server), the server returns a response that causes the client to detect `PIN_WRONG` state: moonlight-qt:585-586 

### UI Feedback

While pairing is in progress, the dialog remains open showing the PIN: moonlight-qt:302-310 

When pairing completes (successfully or with error), the `pairingCompleted` signal is emitted, which closes the dialog: moonlight-qt:47-58 

## Notes

The pairing process uses HTTP request timeouts (defined as `REQUEST_TIMEOUT_MS`) to prevent indefinite waiting. If the user takes too long to enter the PIN on the server, the HTTP request will timeout and pairing will fail. The client doesn't implement any retry logic or polling mechanism - it's a single synchronous attempt that either succeeds or fails based on the server's responses to the 5-phase handshake.

Wiki pages you might want to explore:
- [User Interface System (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2)
- [PC Discovery View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.1)
### Citations
**File:** app/gui/PcView.qml (L47-58)
```text
    function pairingComplete(error)
    {
        // Close the PIN dialog
        pairDialog.close()

        // Display a failed dialog if we got an error
        if (error !== undefined) {
            errorDialog.text = error
            errorDialog.helpText = ""
            errorDialog.open()
        }
    }
```
**File:** app/gui/PcView.qml (L239-246)
```text
                    var pin = computerModel.generatePinString()

                    // Kick off pairing in the background
                    computerModel.pairComputer(index, pin)

                    // Display the pairing dialog
                    pairDialog.pin = pin
                    pairDialog.open()
```
**File:** app/gui/PcView.qml (L302-310)
```text
        // don't allow edits to the rest of the window while open
        property string pin : "0000"
        text:qsTr("Please enter %1 on your host PC. This dialog will close when pairing is completed.").arg(pin)+"\n\n"+
             qsTr("If your host PC is running Sunshine, navigate to the Sunshine web UI to enter the PIN.")
        standardButtons: Dialog.Cancel
        onRejected: {
            // FIXME: We should interrupt pairing here
        }
    }
```
**File:** app/backend/computermanager.cpp (L564-582)
```cpp
    PendingPairingTask(ComputerManager* computerManager, NvComputer* computer, QString pin)
        : m_ComputerManager(computerManager),
          m_Computer(computer),
          m_Pin(pin)
    {
        connect(this, &PendingPairingTask::pairingCompleted,
                computerManager, &ComputerManager::pairingCompleted);
    }

signals:
    void pairingCompleted(NvComputer* computer, QString error);

private:
    void run()
    {
        NvPairingManager pairingManager(m_Computer);

        try {
           NvPairingManager::PairState result = pairingManager.pair(m_Computer->appVersion, m_Pin, m_Computer->serverCert);
```
**File:** app/backend/computermanager.cpp (L585-586)
```cpp
           case NvPairingManager::PairState::PIN_WRONG:
               emit pairingCompleted(m_Computer, tr("The PIN from the PC didn't match. Please try again."));
```
**File:** app/backend/nvpairingmanager.cpp (L217-227)
```cpp
    QString getCert = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&phrase=getservercert&salt=" +
                                                    salt.toHex() + "&clientcert=" + IdentityManager::get()->getCertificate().toHex(),
                                                    0);
    NvHTTP::verifyResponseStatus(getCert);
    if (NvHTTP::getXmlString(getCert, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #1";
        return PairState::FAILED;
    }
```
**File:** app/backend/nvpairingmanager.cpp (L287-298)
```cpp
    QString respXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&serverchallengeresp=" +
                                                    encryptedChallengeResponseHash.toHex(),
                                                    REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(respXml);
    if (NvHTTP::getXmlString(respXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #3";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }
```
**File:** app/backend/nvpairingmanager.cpp (L313-322)
```cpp
    QByteArray expectedResponseData;
    expectedResponseData.append(randomChallenge);
    expectedResponseData.append(getSignatureFromPemCert(serverCertStr));
    expectedResponseData.append(serverSecret);
    if (QCryptographicHash::hash(expectedResponseData, hashAlgo) != serverResponse)
    {
        qCritical() << "Incorrect PIN";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::PIN_WRONG;
    }
```
# DeepWiki Q&A with Code Context for Repository: moonlight-stream/moonlight-qt
## Q1
how to get /launch and /serverinfo info from server?
### Answer
Based on the code context, you're asking about how Moonlight retrieves `/launch` and `/serverinfo` information from the host server.

## Answer

Moonlight uses the `NvHTTP` class to communicate with the host server and retrieve information through HTTP/HTTPS endpoints. moonlight-qt:124-187 

### Getting `/serverinfo`

The `NvHTTP::getServerInfo()` method fetches server information: moonlight-qt:124-140 

The method first attempts to use HTTPS if a pinned certificate is available, then falls back to HTTP if needed. moonlight-qt:143-160  If no certificate exists yet, it uses HTTP initially to fetch the HTTPS port, then retries over HTTPS. moonlight-qt:162-183 

This is called during PC discovery when adding a new host: moonlight-qt:809-818 

The response is then used to create or update an `NvComputer` object: moonlight-qt:820-821 

### Getting `/launch` info

The `/launch` endpoint is called via `NvHTTP::startApp()` when starting a streaming session: moonlight-qt:1585-1593 

This happens in `Session::startConnectionAsync()` after the user selects an app to stream. moonlight-qt:1548-1600  The method passes streaming configuration parameters and receives back an RTSP session URL that's used to establish the actual streaming connection. moonlight-qt:1582-1593 

## Notes

The `NvHTTP` class handles all HTTP/HTTPS communication with the host server, including certificate pinning for security. The `/serverinfo` endpoint is polled regularly to monitor PC status, while `/launch` (or `/resume`) is only called when initiating a streaming session. Both endpoints use the base URL constructed from the host's address and appropriate port (HTTP 47989 or HTTPS 47984 by default).

Wiki pages you might want to explore:
- [User Interface System (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2)
- [PC Discovery View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.1)
### Citations
**File:** app/backend/nvhttp.cpp (L124-187)
```cpp
NvHTTP::getServerInfo(NvLogLevel logLevel, bool fastFail)
{
    QString serverInfo;

    // Check if we have a pinned cert and HTTPS port for this host yet
    if (!m_ServerCert.isNull() && httpsPort() != 0)
    {
        try
        {
            // Always try HTTPS first, since it properly reports
            // pairing status (and a few other attributes).
            serverInfo = openConnectionToString(m_BaseUrlHttps,
                                                "serverinfo",
                                                nullptr,
                                                fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                                logLevel);
            // Throws if the request failed
            verifyResponseStatus(serverInfo);
        }
        catch (const GfeHttpResponseException& e)
        {
            if (e.getStatusCode() == 401)
            {
                // Certificate validation error, fallback to HTTP
                serverInfo = openConnectionToString(m_BaseUrlHttp,
                                                    "serverinfo",
                                                    nullptr,
                                                    fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                                    logLevel);
                verifyResponseStatus(serverInfo);
            }
            else
            {
                // Rethrow real errors
                throw e;
            }
        }
    }
    else
    {
        // Only use HTTP prior to pairing or fetching HTTPS port
        serverInfo = openConnectionToString(m_BaseUrlHttp,
                                            "serverinfo",
                                            nullptr,
                                            fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                            logLevel);
        verifyResponseStatus(serverInfo);

        // Populate the HTTPS port
        uint16_t httpsPort = getXmlString(serverInfo, "HttpsPort").toUShort();
        if (httpsPort == 0) {
            httpsPort = DEFAULT_HTTPS_PORT;
        }
        setHttpsPort(httpsPort);

        // If we just needed to determine the HTTPS port, we'll try again over
        // HTTPS now that we have the port number
        if (!m_ServerCert.isNull()) {
            return getServerInfo(logLevel, fastFail);
        }
    }

    return serverInfo;
}
```
**File:** app/backend/computermanager.cpp (L809-818)
```cpp
        // Perform initial serverinfo fetch over HTTP since we don't know which cert to use
        QString serverInfo = fetchServerInfo(http);
        if (serverInfo.isEmpty() && !m_MdnsIpv6Address.isNull()) {
            // Retry using the global IPv6 address if the IPv4 or link-local IPv6 address fails
            http.setAddress(m_MdnsIpv6Address);
            serverInfo = fetchServerInfo(http);
        }
        if (serverInfo.isEmpty()) {
            return;
        }
```
**File:** app/backend/computermanager.cpp (L820-821)
```cpp
        // Create initial newComputer using HTTP serverinfo with no pinned cert
        NvComputer* newComputer = new NvComputer(http, serverInfo);
```
**File:** app/streaming/session.cpp (L1548-1600)
```cpp
bool Session::startConnectionAsync()
{
    // Wait 1.5 seconds before connecting to let the user
    // have time to read any messages present on the segue
    SDL_Delay(1500);

    // The UI should have ensured the old game was already quit
    // if we decide to stream a different game.
    Q_ASSERT(m_Computer->currentGameId == 0 ||
             m_Computer->currentGameId == m_App.id);

    bool enableGameOptimizations;
    if (m_Computer->isNvidiaServerSoftware) {
        // GFE will set all settings to 720p60 if it doesn't recognize
        // the chosen resolution. Avoid that by disabling SOPS when it
        // is not streaming a supported resolution.
        enableGameOptimizations = false;
        for (const NvDisplayMode &mode : m_Computer->displayModes) {
            if (mode.width == m_StreamConfig.width &&
                    mode.height == m_StreamConfig.height) {
                SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION,
                            "Found host supported resolution: %dx%d",
                            mode.width, mode.height);
                enableGameOptimizations = m_Preferences->gameOptimizations;
                break;
            }
        }
    }
    else {
        // Always send SOPS to Sunshine because we may repurpose the
        // option to control whether the display mode is adjusted
        enableGameOptimizations = m_Preferences->gameOptimizations;
    }

    QString rtspSessionUrl;

    try {
        NvHTTP http(m_Computer);
        http.startApp(m_Computer->currentGameId != 0 ? "resume" : "launch",
                      m_Computer->isNvidiaServerSoftware,
                      m_App.id, &m_StreamConfig,
                      enableGameOptimizations,
                      m_Preferences->playAudioOnHost,
                      m_InputHandler->getAttachedGamepadMask(),
                      !m_Preferences->multiController,
                      rtspSessionUrl);
    } catch (const GfeHttpResponseException& e) {
        emit displayLaunchError(tr("Host returned error: %1").arg(e.toQString()));
        return false;
    } catch (const QtNetworkReplyException& e) {
        emit displayLaunchError(e.toQString());
        return false;
    }
```
## Q2
How to parse the information returned by the above 2 interfaces and provide it to the function for establishing a streaming connection?
### Answer
You're asking about how Moonlight parses the responses from `/serverinfo` and `/launch` endpoints and uses that information to establish a streaming connection.

## Answer

### Parsing `/serverinfo` Response

The `/serverinfo` response is parsed to create/update an `NvComputer` object that stores host capabilities. moonlight-qt:754-782  The `NvHTTP::getServerInfo()` method returns an XML string that gets parsed to extract server properties like:<cite />

- Server codec mode support (`serverCodecModeSupport`)
- GFE version (`gfeVersion`)
- App version (`appVersion`)
- Display modes
- Current game ID

These properties are stored in the `NvComputer` object and later used during session validation and configuration.<cite />

### Parsing `/launch` Response and Establishing Connection

When starting a stream, `NvHTTP::startApp()` is called with the `STREAM_CONFIGURATION` structure containing all streaming parameters (resolution, FPS, bitrate, codec preferences, etc.). moonlight-qt:189-236  The method constructs a URL with query parameters including:<cite />

- Resolution and FPS (`mode` parameter)
- HDR settings
- Audio configuration
- Gamepad mask
- Remote input encryption keys

The response is parsed to extract the `rtspSessionUrl` using `getXmlString(response, "sessionUrl0")`. moonlight-qt:235-235 

### Providing Information to Connection Function

After receiving the `/launch` response, the parsed information is used to populate a `SERVER_INFORMATION` structure: moonlight-qt:1602-1624 

```cpp
SERVER_INFORMATION hostInfo;
hostInfo.address = hostnameStr.data();
hostInfo.serverInfoAppVersion = siAppVersion.data();
hostInfo.serverCodecModeSupport = m_Computer->serverCodecModeSupport;
hostInfo.serverInfoGfeVersion = siGfeVersion.data();
hostInfo.rtspSessionUrl = rtspSessionUrlStr.data();
```

This structure, along with the `STREAM_CONFIGURATION` and callback structures, is passed to `LiStartConnection()` to establish the actual streaming connection: moonlight-qt:1678-1685 

The `LiStartConnection()` function (from the moonlight-common-c library) uses:
- The RTSP session URL from `/launch` response to establish the RTSP control channel
- Server codec support from `/serverinfo` to negotiate video formats
- Stream configuration to set up video/audio decoders

### Validation Before Connection

Before calling `LiStartConnection()`, the session validates that the host supports the requested features by checking `m_Computer->serverCodecModeSupport` against the requested video formats. moonlight-qt:1117-1152  For example, it verifies YUV 4:4:4 support and adjusts the supported video formats list accordingly.<cite />

## Notes

The parsing happens in two stages: first during PC discovery (parsing `/serverinfo` into `NvComputer` properties), then during session start (parsing `/launch` response for RTSP URL). The `NvComputer` object acts as a bridge, storing server capabilities that are later referenced when configuring the `SERVER_INFORMATION` structure for `LiStartConnection()`. The actual XML parsing is handled by helper functions like `getXmlString()` in the `NvHTTP` class.

Wiki pages you might want to explore:
- [Settings View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.2)
- [Input Handling (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#4.7)
### Citations
**File:** app/backend/computermanager.cpp (L754-782)
```cpp
    QString fetchServerInfo(NvHTTP& http)
    {
        QString serverInfo;

        // Do nothing if we're quitting
        if (m_AboutToQuit) {
            return QString();
        }

        try {
            // There's a race condition between GameStream servers reporting presence over
            // mDNS and the HTTPS server being ready to respond to our queries. To work
            // around this issue, we will issue the request again after a few seconds if
            // we see a ServiceUnavailableError error.
            try {
                serverInfo = http.getServerInfo(NvHTTP::NVLL_VERBOSE);
            } catch (const QtNetworkReplyException& e) {
                if (e.getError() == QNetworkReply::ServiceUnavailableError) {
                    qWarning() << "Retrying request in 5 seconds after ServiceUnavailableError";
                    QThread::sleep(5);
                    serverInfo = http.getServerInfo(NvHTTP::NVLL_VERBOSE);
                    qInfo() << "Retry successful";
                }
                else {
                    // Rethrow other errors
                    throw e;
                }
            }
            return serverInfo;
```
**File:** app/backend/nvhttp.cpp (L189-236)
```cpp
void
NvHTTP::startApp(QString verb,
                 bool isGfe,
                 int appId,
                 PSTREAM_CONFIGURATION streamConfig,
                 bool sops,
                 bool localAudio,
                 int gamepadMask,
                 bool persistGameControllersOnDisconnect,
                 QString& rtspSessionUrl)
{
    int riKeyId;

    memcpy(&riKeyId, streamConfig->remoteInputAesIv, sizeof(riKeyId));
    riKeyId = qFromBigEndian(riKeyId);

    QString response =
            openConnectionToString(m_BaseUrlHttps,
                                   verb,
                                   "appid="+QString::number(appId)+
                                   "&mode="+QString::number(streamConfig->width)+"x"+
                                   QString::number(streamConfig->height)+"x"+
                                   // Using an FPS value over 60 causes SOPS to default to 720p60,
                                   // so force it to 0 to ensure the correct resolution is set. We
                                   // used to use 60 here but that locked the frame rate to 60 FPS
                                   // on GFE 3.20.3. We don't need this hack for Sunshine.
                                   QString::number((streamConfig->fps > 60 && isGfe) ? 0 : streamConfig->fps)+
                                   "&additionalStates=1&sops="+QString::number(sops ? 1 : 0)+
                                   "&rikey="+QByteArray(streamConfig->remoteInputAesKey, sizeof(streamConfig->remoteInputAesKey)).toHex()+
                                   "&rikeyid="+QString::number(riKeyId)+
                                   ((streamConfig->supportedVideoFormats & VIDEO_FORMAT_MASK_10BIT) ?
                                       "&hdrMode=1&clientHdrCapVersion=0&clientHdrCapSupportedFlagsInUint32=0&clientHdrCapMetaDataId=NV_STATIC_METADATA_TYPE_1&clientHdrCapDisplayData=0x0x0x0x0x0x0x0x0x0x0" :
                                        "")+
                                   "&localAudioPlayMode="+QString::number(localAudio ? 1 : 0)+
                                   "&surroundAudioInfo="+QString::number(SURROUNDAUDIOINFO_FROM_AUDIO_CONFIGURATION(streamConfig->audioConfiguration))+
                                   "&remoteControllersBitmap="+QString::number(gamepadMask)+
                                   "&gcmap="+QString::number(gamepadMask)+
                                   "&gcpersist="+QString::number(persistGameControllersOnDisconnect ? 1 : 0)+
                                   LiGetLaunchUrlQueryParameters(),
                                   LAUNCH_TIMEOUT_MS);

    qInfo() << "Launch response:" << response;

    // Throws if the request failed
    verifyResponseStatus(response);

    rtspSessionUrl = getXmlString(response, "sessionUrl0");
}
```
**File:** app/streaming/session.cpp (L1117-1152)
```cpp
    if (m_Preferences->enableYUV444) {
        if (!(m_Computer->serverCodecModeSupport & SCM_MASK_YUV444)) {
            emitLaunchWarning(tr("Your host PC doesn't support YUV 4:4:4 streaming."));
            m_SupportedVideoFormats.removeByMask(VIDEO_FORMAT_MASK_YUV444);
        }
        else {
            m_SupportedVideoFormats.removeByMask(~m_SupportedVideoFormats.maskByServerCodecModes(m_Computer->serverCodecModeSupport));

            if (!m_SupportedVideoFormats.isEmpty() &&
                !(m_SupportedVideoFormats.front() & VIDEO_FORMAT_MASK_YUV444)) {
                emitLaunchWarning(tr("Your host PC doesn't support YUV 4:4:4 streaming for selected video codec."));
            }
            else if (m_Preferences->videoDecoderSelection != StreamingPreferences::VDS_FORCE_SOFTWARE) {
                while (!m_SupportedVideoFormats.isEmpty() &&
                       (m_SupportedVideoFormats.front() & VIDEO_FORMAT_MASK_YUV444) &&
                       getDecoderAvailability(testWindow,
                                              m_Preferences->videoDecoderSelection,
                                              m_SupportedVideoFormats.front(),
                                              m_StreamConfig.width,
                                              m_StreamConfig.height,
                                              m_StreamConfig.fps) != DecoderAvailability::Hardware) {
                    if (m_Preferences->videoDecoderSelection == StreamingPreferences::VDS_FORCE_HARDWARE) {
                        m_SupportedVideoFormats.removeFirst();
                    }
                    else {
                        emitLaunchWarning(tr("Using software decoding due to your selection to force YUV 4:4:4 without GPU support. This may cause poor streaming performance."));
                        break;
                    }
                }
                if (!m_SupportedVideoFormats.isEmpty() &&
                    !(m_SupportedVideoFormats.front() & VIDEO_FORMAT_MASK_YUV444)) {
                    emitLaunchWarning(tr("This PC's GPU doesn't support YUV 4:4:4 decoding for selected video codec."));
                }
            }
        }
    }
```
**File:** app/streaming/session.cpp (L1602-1624)
```cpp
    QByteArray hostnameStr = m_Computer->activeAddress.address().toLatin1();
    QByteArray siAppVersion = m_Computer->appVersion.toLatin1();

    SERVER_INFORMATION hostInfo;
    hostInfo.address = hostnameStr.data();
    hostInfo.serverInfoAppVersion = siAppVersion.data();
    hostInfo.serverCodecModeSupport = m_Computer->serverCodecModeSupport;

    // Older GFE versions didn't have this field
    QByteArray siGfeVersion;
    if (!m_Computer->gfeVersion.isEmpty()) {
        siGfeVersion = m_Computer->gfeVersion.toLatin1();
    }
    if (!siGfeVersion.isEmpty()) {
        hostInfo.serverInfoGfeVersion = siGfeVersion.data();
    }

    // Older GFE and Sunshine versions didn't have this field
    QByteArray rtspSessionUrlStr;
    if (!rtspSessionUrl.isEmpty()) {
        rtspSessionUrlStr = rtspSessionUrl.toLatin1();
        hostInfo.rtspSessionUrl = rtspSessionUrlStr.data();
    }
```
**File:** app/streaming/session.cpp (L1678-1685)
```cpp
    int err = LiStartConnection(&hostInfo, &m_StreamConfig, &k_ConnCallbacks,
                                &m_VideoCallbacks, &m_AudioCallbacks,
                                NULL, 0, NULL, 0);
    if (err != 0) {
        // We already displayed an error dialog in the stage failure
        // listener.
        return false;
    }
```
## Q3
how to get "Remote input encryption keys"
### Answer
You're asking about how Moonlight generates the "Remote input encryption keys" that are sent to the host server during the `/launch` request.

## Answer

The remote input encryption keys (`rikey` and `rikeyid`) are randomly generated AES encryption keys used to secure input data sent from the client to the host during streaming. moonlight-qt:692-696 

### Key Generation

During session initialization in `Session::initialize()`, Moonlight generates these keys using OpenSSL's cryptographically secure random number generator:

```cpp
RAND_bytes(reinterpret_cast<unsigned char*>(m_StreamConfig.remoteInputAesKey),
           sizeof(m_StreamConfig.remoteInputAesKey));

// Only the first 4 bytes are populated in the RI key IV
RAND_bytes(reinterpret_cast<unsigned char*>(m_StreamConfig.remoteInputAesIv), 4);
``` moonlight-qt:692-696 

The `remoteInputAesKey` is a full AES key (16 bytes), while `remoteInputAesIv` only uses the first 4 bytes as an initialization vector. moonlight-qt:692-696 

### Sending Keys to Host

These generated keys are then sent to the host server when calling the `/launch` endpoint in `NvHTTP::startApp()`. moonlight-qt:200-218  The method:

1. Extracts the key ID from the IV by reading the first 4 bytes as a big-endian integer moonlight-qt:200-203 
2. Converts the AES key to hexadecimal format using `QByteArray(...).toHex()` moonlight-qt:217-217 
3. Includes both values as query parameters: `rikey=<hex_key>&rikeyid=<key_id>` moonlight-qt:217-218 

### Security Considerations

For security, these keys are automatically redacted from log files to prevent exposure. moonlight-qt:108-110  The logging system uses regex patterns to strip `rikey` and `rikeyid` values before writing to logs. moonlight-qt:88-88 

## Notes

The remote input encryption is part of Moonlight's security features to protect input data (keyboard, mouse, gamepad) transmitted during streaming. The keys are generated fresh for each streaming session and are stored in the `STREAM_CONFIGURATION` structure (`m_StreamConfig`) which is later passed to `LiStartConnection()` to establish the connection. moonlight-qt:1584-1593 

Wiki pages you might want to explore:
- [PC Discovery View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.1)
### Citations
**File:** app/streaming/session.cpp (L692-696)
```cpp
    RAND_bytes(reinterpret_cast<unsigned char*>(m_StreamConfig.remoteInputAesKey),
               sizeof(m_StreamConfig.remoteInputAesKey));

    // Only the first 4 bytes are populated in the RI key IV
    RAND_bytes(reinterpret_cast<unsigned char*>(m_StreamConfig.remoteInputAesIv), 4);
```
**File:** app/streaming/session.cpp (L1584-1593)
```cpp
    try {
        NvHTTP http(m_Computer);
        http.startApp(m_Computer->currentGameId != 0 ? "resume" : "launch",
                      m_Computer->isNvidiaServerSoftware,
                      m_App.id, &m_StreamConfig,
                      enableGameOptimizations,
                      m_Preferences->playAudioOnHost,
                      m_InputHandler->getAttachedGamepadMask(),
                      !m_Preferences->multiController,
                      rtspSessionUrl);
```
**File:** app/backend/nvhttp.cpp (L200-218)
```cpp
    int riKeyId;

    memcpy(&riKeyId, streamConfig->remoteInputAesIv, sizeof(riKeyId));
    riKeyId = qFromBigEndian(riKeyId);

    QString response =
            openConnectionToString(m_BaseUrlHttps,
                                   verb,
                                   "appid="+QString::number(appId)+
                                   "&mode="+QString::number(streamConfig->width)+"x"+
                                   QString::number(streamConfig->height)+"x"+
                                   // Using an FPS value over 60 causes SOPS to default to 720p60,
                                   // so force it to 0 to ensure the correct resolution is set. We
                                   // used to use 60 here but that locked the frame rate to 60 FPS
                                   // on GFE 3.20.3. We don't need this hack for Sunshine.
                                   QString::number((streamConfig->fps > 60 && isGfe) ? 0 : streamConfig->fps)+
                                   "&additionalStates=1&sops="+QString::number(sops ? 1 : 0)+
                                   "&rikey="+QByteArray(streamConfig->remoteInputAesKey, sizeof(streamConfig->remoteInputAesKey)).toHex()+
                                   "&rikeyid="+QString::number(riKeyId)+
```
**File:** app/main.cpp (L108-110)
```cpp
    // Strip session encryption keys and IVs from the logs
    message.replace(k_RikeyRegex, "&rikey=REDACTED");
    message.replace(k_RikeyIdRegex, "&rikeyid=REDACTED");
```
**File:** app/deploy/linux/com.moonlight_stream.Moonlight.appdata.xml (L88-88)
```text
					<li>Per-session keys (rikey and rikeyid values) are now automatically stripped from logs</li>
```
## Q4
<?xml version="1.0" encoding="utf-8"?>
<root status_code="200">
  <hostname>Html5syt</hostname>
  <appversion>7.1.431.-1</appversion>
<GfeVersion>3.23.0.74</GfeVersion>
  <uniqueid>F98186B1-DE02-2328-279E-0A461FBCEC47</uniqueid>
  <HttpsPort>47984</HttpsPort>
  <ExternalPort>47989</ExternalPort>
<MaxLumaPixelsHEVC>1869449984</MaxLumaPixelsHEVC>
  <mac>00:00:00:00:00:00</mac>
  <LocalIP>127.0.0.1</LocalIP>
  <ServerCodecModeSupport>257</ServerCodecModeSupport>
<PairStatus>0</PairStatus>
  <currentgame>1191261554</currentgame>
  <state>SUNSHINE_SERVER_BUSY</state>
</root>
This is a response from a serverinfo, please tell me which parameters are used to establish the connection in it?
### Answer
You're asking which parameters from the `/serverinfo` XML response are used when establishing a streaming connection in Moonlight.

## Answer

From the `/serverinfo` response you provided, the following parameters are used to establish the streaming connection:

### Parameters Used in Connection Establishment

**`ServerCodecModeSupport` (value: 257)** - This is stored in the `NvComputer` object and later passed to `LiStartConnection()` via the `SERVER_INFORMATION` structure. moonlight-qt:1608-1608  It indicates which video codecs and formats the host supports, and is used to negotiate the video format during connection setup. moonlight-qt:1608-1608 

**`appversion` (value: 7.1.431.-1)** - This is stored as `m_Computer->appVersion` and passed to `LiStartConnection()` as `hostInfo.serverInfoAppVersion`. moonlight-qt:1603-1607  The connection library uses this to determine host capabilities and compatibility. moonlight-qt:1603-1607 

**`GfeVersion` (value: 3.23.0.74)** - This is stored as `m_Computer->gfeVersion` and passed to `LiStartConnection()` as `hostInfo.serverInfoGfeVersion`. moonlight-qt:1611-1617  It's used to determine if the host is running GFE or Sunshine and adjust behavior accordingly. moonlight-qt:1560-1580 

**`LocalIP` (value: 127.0.0.1)** - The host's address is used to construct the base URLs for HTTP/HTTPS communication and is passed to `LiStartConnection()` as `hostInfo.address`. moonlight-qt:1602-1606 

**`HttpsPort` (value: 47984)** - Used to construct the HTTPS base URL for secure communication with the host, including the `/launch` endpoint call. moonlight-qt:173-177 

### Parameters NOT Directly Used in Connection

The following parameters are informational but not directly passed to the connection function:

- `hostname`, `uniqueid`, `ExternalPort`, `MaxLumaPixelsHEVC`, `mac` - These are stored in the `NvComputer` object for display and management purposes but aren't passed to `LiStartConnection()`.<cite />
- `PairStatus` - Used to determine if pairing is needed before streaming, but not used during connection establishment.<cite />
- `currentgame` and `state` - Used to determine if the host is already streaming, which affects whether to call `/launch` or `/resume`. moonlight-qt:1586-1586 

## Notes

The `state` value "SUNSHINE_SERVER_BUSY" indicates the host is currently streaming (as confirmed by the non-zero `currentgame` value). moonlight-qt:112-116  In this case, Moonlight would call `/resume` instead of `/launch` if you're trying to connect to the same game. moonlight-qt:1586-1586  The `ServerCodecModeSupport` value of 257 indicates support for H.264 (bit 0) and H.265/HEVC (bit 8).<cite />

Wiki pages you might want to explore:
- [PC Discovery View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.1)
### Citations
**File:** app/streaming/session.cpp (L1560-1580)
```cpp
    if (m_Computer->isNvidiaServerSoftware) {
        // GFE will set all settings to 720p60 if it doesn't recognize
        // the chosen resolution. Avoid that by disabling SOPS when it
        // is not streaming a supported resolution.
        enableGameOptimizations = false;
        for (const NvDisplayMode &mode : m_Computer->displayModes) {
            if (mode.width == m_StreamConfig.width &&
                    mode.height == m_StreamConfig.height) {
                SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION,
                            "Found host supported resolution: %dx%d",
                            mode.width, mode.height);
                enableGameOptimizations = m_Preferences->gameOptimizations;
                break;
            }
        }
    }
    else {
        // Always send SOPS to Sunshine because we may repurpose the
        // option to control whether the display mode is adjusted
        enableGameOptimizations = m_Preferences->gameOptimizations;
    }
```
**File:** app/streaming/session.cpp (L1586-1586)
```cpp
        http.startApp(m_Computer->currentGameId != 0 ? "resume" : "launch",
```
**File:** app/streaming/session.cpp (L1602-1607)
```cpp
    QByteArray hostnameStr = m_Computer->activeAddress.address().toLatin1();
    QByteArray siAppVersion = m_Computer->appVersion.toLatin1();

    SERVER_INFORMATION hostInfo;
    hostInfo.address = hostnameStr.data();
    hostInfo.serverInfoAppVersion = siAppVersion.data();
```
**File:** app/streaming/session.cpp (L1608-1608)
```cpp
    hostInfo.serverCodecModeSupport = m_Computer->serverCodecModeSupport;
```
**File:** app/streaming/session.cpp (L1611-1617)
```cpp
    QByteArray siGfeVersion;
    if (!m_Computer->gfeVersion.isEmpty()) {
        siGfeVersion = m_Computer->gfeVersion.toLatin1();
    }
    if (!siGfeVersion.isEmpty()) {
        hostInfo.serverInfoGfeVersion = siGfeVersion.data();
    }
```
**File:** app/backend/nvhttp.cpp (L112-116)
```cpp
    QString serverState = getXmlString(serverInfo, "state");
    if (serverState != nullptr && serverState.endsWith("_SERVER_BUSY"))
    {
        return getXmlString(serverInfo, "currentgame").toInt();
    }
```
**File:** app/backend/nvhttp.cpp (L173-177)
```cpp
        uint16_t httpsPort = getXmlString(serverInfo, "HttpsPort").toUShort();
        if (httpsPort == 0) {
            httpsPort = DEFAULT_HTTPS_PORT;
        }
        setHttpsPort(httpsPort);
```
## Q5
When I call the /launch interface, the server requires me to provide a client certificate. How can I obtain this certificate?
### Answer
Moonlight obtains and provides client certificates through a multi-step process involving certificate generation, pairing, and SSL configuration:

## Client Certificate Generation

When Moonlight first launches, the `IdentityManager` class automatically generates a self-signed 2048-bit RSA certificate and private key pair if none exist. moonlight-qt:29-110 

These credentials are stored persistently in QSettings and cached in memory for reuse. moonlight-qt:112-139 

## Attaching Certificates to Requests

For every HTTPS request (including `/launch`), Moonlight attaches the client certificate through the `IdentityManager::getSslConfig()` method, which returns a `QSslConfiguration` containing both the client certificate and private key. moonlight-qt:184-191 

This SSL configuration is applied to all network requests in the `openConnection` method via `request.setSslConfiguration()`. moonlight-qt:486-489 

## The `/launch` Interface Specifically

When the `startApp` method is called to launch a game, it makes an HTTPS request to the `/launch` endpoint using the base HTTPS URL. moonlight-qt:205-228 

This request goes through `openConnection`, which automatically includes the client certificate for mutual TLS authentication with the host server.

## Pairing Process for Mutual Trust

Before the client certificate can be used for authentication, a pairing process must occur. During pairing, the client sends its certificate to the server and receives the server's certificate in return. moonlight-qt:217-248 

The server certificate is then pinned and stored in the `NvComputer` object for future SSL validation. moonlight-qt:419-439 

## Certificate Validation

If there's an SSL handshake failure or certificate mismatch (error 401), Moonlight falls back to HTTP and can re-initiate pairing to obtain updated certificates. moonlight-qt:143-160 

## Notes

- The client certificate uses a common name of "NVIDIA GameStream Client" moonlight-qt:70-74 
- The certificate has a 20-year validity period moonlight-qt:51-66 
- The `/launch` endpoint uses a 120-second timeout compared to the standard 5-second timeout for other requests moonlight-qt:15-19 
- Certificate pinning prevents man-in-the-middle attacks by ensuring SSL errors are only ignored if they match the previously paired server certificate moonlight-qt:429-434
### Citations
**File:** app/backend/identitymanager.cpp (L29-110)
```cpp
void IdentityManager::createCredentials(QSettings& settings)
{
    X509* cert = X509_new();
    THROW_BAD_ALLOC_IF_NULL(cert);

    EVP_PKEY_CTX* ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_RSA, NULL);
    THROW_BAD_ALLOC_IF_NULL(ctx);

    EVP_PKEY_keygen_init(ctx);
    EVP_PKEY_CTX_set_rsa_keygen_bits(ctx, 2048);

    // pk must be initialized on input
    EVP_PKEY* pk = NULL;
    EVP_PKEY_keygen(ctx, &pk);

    EVP_PKEY_CTX_free(ctx);
    THROW_BAD_ALLOC_IF_NULL(pk);

    X509_set_version(cert, 2);
    ASN1_INTEGER_set(X509_get_serialNumber(cert), 0);
#if OPENSSL_VERSION_NUMBER < 0x10100000L
    X509_gmtime_adj(X509_get_notBefore(cert), 0);
    X509_gmtime_adj(X509_get_notAfter(cert), 60 * 60 * 24 * 365 * 20); // 20 yrs
#else
    ASN1_TIME* before = ASN1_STRING_dup(X509_get0_notBefore(cert));
    THROW_BAD_ALLOC_IF_NULL(before);
    ASN1_TIME* after = ASN1_STRING_dup(X509_get0_notAfter(cert));
    THROW_BAD_ALLOC_IF_NULL(after);

    X509_gmtime_adj(before, 0);
    X509_gmtime_adj(after, 60 * 60 * 24 * 365 * 20); // 20 yrs

    X509_set1_notBefore(cert, before);
    X509_set1_notAfter(cert, after);

    ASN1_STRING_free(before);
    ASN1_STRING_free(after);
#endif

    X509_set_pubkey(cert, pk);

    X509_NAME* name = X509_get_subject_name(cert);
    X509_NAME_add_entry_by_txt(name, "CN", MBSTRING_ASC,
                               reinterpret_cast<unsigned char *>(const_cast<char*>("NVIDIA GameStream Client")),
                               -1, -1, 0);
    X509_set_issuer_name(cert, name);

    X509_sign(cert, pk, EVP_sha256());

    BIO* biokey = BIO_new(BIO_s_mem());
    THROW_BAD_ALLOC_IF_NULL(biokey);
    PEM_write_bio_PrivateKey(biokey, pk, NULL, NULL, 0, NULL, NULL);

    BIO* biocert = BIO_new(BIO_s_mem());
    THROW_BAD_ALLOC_IF_NULL(biocert);
    PEM_write_bio_X509(biocert, cert);

    BUF_MEM* mem;
    BIO_get_mem_ptr(biokey, &mem);
    m_CachedPrivateKey = QByteArray(mem->data, (int)mem->length);

    BIO_get_mem_ptr(biocert, &mem);
    m_CachedPemCert = QByteArray(mem->data, (int)mem->length);

    X509_free(cert);
    EVP_PKEY_free(pk);
    BIO_free(biokey);
    BIO_free(biocert);

    // Check that the new keypair is valid before persisting it
    if (getSslCertificate().isNull()) {
        qFatal("Newly generated certificate is unreadable");
    }
    if (getSslKey().isNull()) {
        qFatal("Newly generated private key is unreadable");
    }

    settings.setValue(SER_CERT, m_CachedPemCert);
    settings.setValue(SER_KEY, m_CachedPrivateKey);

    qInfo() << "Wrote new identity credentials to settings";
}
```
**File:** app/backend/identitymanager.cpp (L112-139)
```cpp
IdentityManager::IdentityManager()
{
    QSettings settings;

    m_CachedPemCert = settings.value(SER_CERT).toByteArray();
    m_CachedPrivateKey = settings.value(SER_KEY).toByteArray();

    if (m_CachedPemCert.isEmpty() || m_CachedPrivateKey.isEmpty()) {
        qInfo() << "No existing credentials found";
        createCredentials(settings);
    }
    else if (getSslCertificate().isNull()) {
        qWarning() << "Certificate is unreadable";
        createCredentials(settings);
    }
    else if (getSslKey().isNull()) {
        qWarning() << "Private key is unreadable";
        createCredentials(settings);
    }

    // We should have valid credentials now. If not, we're screwed
    if (getSslCertificate().isNull()) {
        qFatal("Certificate is unreadable");
    }
    if (getSslKey().isNull()) {
        qFatal("Private key is unreadable");
    }
}
```
**File:** app/backend/identitymanager.cpp (L184-191)
```cpp
QSslConfiguration
IdentityManager::getSslConfig()
{
    QSslConfiguration sslConfig(QSslConfiguration::defaultConfiguration());
    sslConfig.setLocalCertificate(getSslCertificate());
    sslConfig.setPrivateKey(getSslKey());
    return sslConfig;
}
```
**File:** app/backend/nvhttp.cpp (L15-19)
```cpp
#define FAST_FAIL_TIMEOUT_MS 2000
#define REQUEST_TIMEOUT_MS 5000
#define LAUNCH_TIMEOUT_MS 120000
#define RESUME_TIMEOUT_MS 30000
#define QUIT_TIMEOUT_MS 30000
```
**File:** app/backend/nvhttp.cpp (L143-160)
```cpp
        catch (const GfeHttpResponseException& e)
        {
            if (e.getStatusCode() == 401)
            {
                // Certificate validation error, fallback to HTTP
                serverInfo = openConnectionToString(m_BaseUrlHttp,
                                                    "serverinfo",
                                                    nullptr,
                                                    fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                                    logLevel);
                verifyResponseStatus(serverInfo);
            }
            else
            {
                // Rethrow real errors
                throw e;
            }
        }
```
**File:** app/backend/nvhttp.cpp (L205-228)
```cpp
    QString response =
            openConnectionToString(m_BaseUrlHttps,
                                   verb,
                                   "appid="+QString::number(appId)+
                                   "&mode="+QString::number(streamConfig->width)+"x"+
                                   QString::number(streamConfig->height)+"x"+
                                   // Using an FPS value over 60 causes SOPS to default to 720p60,
                                   // so force it to 0 to ensure the correct resolution is set. We
                                   // used to use 60 here but that locked the frame rate to 60 FPS
                                   // on GFE 3.20.3. We don't need this hack for Sunshine.
                                   QString::number((streamConfig->fps > 60 && isGfe) ? 0 : streamConfig->fps)+
                                   "&additionalStates=1&sops="+QString::number(sops ? 1 : 0)+
                                   "&rikey="+QByteArray(streamConfig->remoteInputAesKey, sizeof(streamConfig->remoteInputAesKey)).toHex()+
                                   "&rikeyid="+QString::number(riKeyId)+
                                   ((streamConfig->supportedVideoFormats & VIDEO_FORMAT_MASK_10BIT) ?
                                       "&hdrMode=1&clientHdrCapVersion=0&clientHdrCapSupportedFlagsInUint32=0&clientHdrCapMetaDataId=NV_STATIC_METADATA_TYPE_1&clientHdrCapDisplayData=0x0x0x0x0x0x0x0x0x0x0" :
                                        "")+
                                   "&localAudioPlayMode="+QString::number(localAudio ? 1 : 0)+
                                   "&surroundAudioInfo="+QString::number(SURROUNDAUDIOINFO_FROM_AUDIO_CONFIGURATION(streamConfig->audioConfiguration))+
                                   "&remoteControllersBitmap="+QString::number(gamepadMask)+
                                   "&gcmap="+QString::number(gamepadMask)+
                                   "&gcpersist="+QString::number(persistGameControllersOnDisconnect ? 1 : 0)+
                                   LiGetLaunchUrlQueryParameters(),
                                   LAUNCH_TIMEOUT_MS);
```
**File:** app/backend/nvhttp.cpp (L419-439)
```cpp
void NvHTTP::handleSslErrors(QNetworkReply* reply, const QList<QSslError>& errors)
{
    bool ignoreErrors = true;

    if (m_ServerCert.isNull()) {
        // We should never make an HTTPS request without a cert
        Q_ASSERT(!m_ServerCert.isNull());
        return;
    }

    for (const QSslError& error : errors) {
        if (m_ServerCert != error.certificate()) {
            ignoreErrors = false;
            break;
        }
    }

    if (ignoreErrors) {
        reply->ignoreSslErrors(errors);
    }
}
```
**File:** app/backend/nvhttp.cpp (L486-489)
```cpp
    QNetworkRequest request(url);

    // Add our client certificate
    request.setSslConfiguration(IdentityManager::get()->getSslConfig());
```
**File:** app/backend/nvpairingmanager.cpp (L217-248)
```cpp
    QString getCert = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&phrase=getservercert&salt=" +
                                                    salt.toHex() + "&clientcert=" + IdentityManager::get()->getCertificate().toHex(),
                                                    0);
    NvHTTP::verifyResponseStatus(getCert);
    if (NvHTTP::getXmlString(getCert, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #1";
        return PairState::FAILED;
    }

    QByteArray serverCertStr = NvHTTP::getXmlStringFromHex(getCert, "plaincert");
    if (serverCertStr == nullptr)
    {
        qCritical() << "Server likely already pairing";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::ALREADY_IN_PROGRESS;
    }

    QSslCertificate unverifiedServerCert = QSslCertificate(serverCertStr);
    if (unverifiedServerCert.isNull()) {
        Q_ASSERT(!unverifiedServerCert.isNull());

        qCritical() << "Failed to parse plaincert";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    // Pin this cert for TLS until pairing is complete. If successful, we will propagate
    // the cert into the NvComputer object and persist it.
    m_Http.setServerCert(unverifiedServerCert);
```
## Q6
How to pair up computer?
### Answer
The pairing process in Moonlight uses a 5-phase handshake protocol to securely exchange certificates between the client and server. Here's how it works:

## Client Certificate Generation and Storage

The client certificate is a self-signed X.509 certificate that is generated when Moonlight first runs. It uses a 2048-bit RSA key pair with SHA-256 signature and has a 20-year validity period. moonlight-qt:29-110 

The certificate and private key are stored in QSettings and cached in memory for subsequent use. moonlight-qt:112-139 

## The 5-Phase Pairing Process

The pairing process is implemented in the `NvPairingManager::pair()` method: moonlight-qt:191-354 

### Phase 1: Certificate Exchange

The client sends its certificate to the server as a hex-encoded string in the `clientcert` parameter of an HTTP request. At the same time, it receives the server's certificate in the response: moonlight-qt:217-227 

The server returns its certificate in the `plaincert` field of the XML response: moonlight-qt:229-244 

### Phase 2-5: Challenge-Response Authentication

Once the server certificate is received, it is immediately pinned to the HTTP client for all subsequent HTTPS requests: moonlight-qt:246-248 

The remaining phases involve encrypted challenge-response exchanges and signature verification to authenticate both parties and validate the PIN.

## Certificate Pinning

The `setServerCert()` method stores the server certificate for use in HTTPS connections: moonlight-qt:43-46 

During HTTPS connections, the `handleSslErrors()` method verifies that the server certificate matches the pinned certificate, preventing man-in-the-middle attacks: moonlight-qt:419-439 

## Persisting the Server Certificate

After successful pairing, the server certificate is stored in the `NvComputer` object: moonlight-qt:113-113 

The certificate is then persisted to settings by calling `saveHost()`: moonlight-qt:599-603 

## Notes

The pairing process uses AES-128-ECB encryption for challenge exchanges, with the encryption key derived from a salted PIN hash (SHA-256 for Gen 7+ servers, SHA-1 for older versions). The client certificate is sent as plain hex-encoded PEM data in Phase 1, while the server certificate is also returned as hex-encoded PEM. This certificate exchange happens over HTTP initially, but all subsequent pairing phases use HTTPS with the newly pinned certificate to ensure secure communication.
### Citations
**File:** app/backend/identitymanager.cpp (L29-110)
```cpp
void IdentityManager::createCredentials(QSettings& settings)
{
    X509* cert = X509_new();
    THROW_BAD_ALLOC_IF_NULL(cert);

    EVP_PKEY_CTX* ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_RSA, NULL);
    THROW_BAD_ALLOC_IF_NULL(ctx);

    EVP_PKEY_keygen_init(ctx);
    EVP_PKEY_CTX_set_rsa_keygen_bits(ctx, 2048);

    // pk must be initialized on input
    EVP_PKEY* pk = NULL;
    EVP_PKEY_keygen(ctx, &pk);

    EVP_PKEY_CTX_free(ctx);
    THROW_BAD_ALLOC_IF_NULL(pk);

    X509_set_version(cert, 2);
    ASN1_INTEGER_set(X509_get_serialNumber(cert), 0);
#if OPENSSL_VERSION_NUMBER < 0x10100000L
    X509_gmtime_adj(X509_get_notBefore(cert), 0);
    X509_gmtime_adj(X509_get_notAfter(cert), 60 * 60 * 24 * 365 * 20); // 20 yrs
#else
    ASN1_TIME* before = ASN1_STRING_dup(X509_get0_notBefore(cert));
    THROW_BAD_ALLOC_IF_NULL(before);
    ASN1_TIME* after = ASN1_STRING_dup(X509_get0_notAfter(cert));
    THROW_BAD_ALLOC_IF_NULL(after);

    X509_gmtime_adj(before, 0);
    X509_gmtime_adj(after, 60 * 60 * 24 * 365 * 20); // 20 yrs

    X509_set1_notBefore(cert, before);
    X509_set1_notAfter(cert, after);

    ASN1_STRING_free(before);
    ASN1_STRING_free(after);
#endif

    X509_set_pubkey(cert, pk);

    X509_NAME* name = X509_get_subject_name(cert);
    X509_NAME_add_entry_by_txt(name, "CN", MBSTRING_ASC,
                               reinterpret_cast<unsigned char *>(const_cast<char*>("NVIDIA GameStream Client")),
                               -1, -1, 0);
    X509_set_issuer_name(cert, name);

    X509_sign(cert, pk, EVP_sha256());

    BIO* biokey = BIO_new(BIO_s_mem());
    THROW_BAD_ALLOC_IF_NULL(biokey);
    PEM_write_bio_PrivateKey(biokey, pk, NULL, NULL, 0, NULL, NULL);

    BIO* biocert = BIO_new(BIO_s_mem());
    THROW_BAD_ALLOC_IF_NULL(biocert);
    PEM_write_bio_X509(biocert, cert);

    BUF_MEM* mem;
    BIO_get_mem_ptr(biokey, &mem);
    m_CachedPrivateKey = QByteArray(mem->data, (int)mem->length);

    BIO_get_mem_ptr(biocert, &mem);
    m_CachedPemCert = QByteArray(mem->data, (int)mem->length);

    X509_free(cert);
    EVP_PKEY_free(pk);
    BIO_free(biokey);
    BIO_free(biocert);

    // Check that the new keypair is valid before persisting it
    if (getSslCertificate().isNull()) {
        qFatal("Newly generated certificate is unreadable");
    }
    if (getSslKey().isNull()) {
        qFatal("Newly generated private key is unreadable");
    }

    settings.setValue(SER_CERT, m_CachedPemCert);
    settings.setValue(SER_KEY, m_CachedPrivateKey);

    qInfo() << "Wrote new identity credentials to settings";
}
```
**File:** app/backend/identitymanager.cpp (L112-139)
```cpp
IdentityManager::IdentityManager()
{
    QSettings settings;

    m_CachedPemCert = settings.value(SER_CERT).toByteArray();
    m_CachedPrivateKey = settings.value(SER_KEY).toByteArray();

    if (m_CachedPemCert.isEmpty() || m_CachedPrivateKey.isEmpty()) {
        qInfo() << "No existing credentials found";
        createCredentials(settings);
    }
    else if (getSslCertificate().isNull()) {
        qWarning() << "Certificate is unreadable";
        createCredentials(settings);
    }
    else if (getSslKey().isNull()) {
        qWarning() << "Private key is unreadable";
        createCredentials(settings);
    }

    // We should have valid credentials now. If not, we're screwed
    if (getSslCertificate().isNull()) {
        qFatal("Certificate is unreadable");
    }
    if (getSslKey().isNull()) {
        qFatal("Private key is unreadable");
    }
}
```
**File:** app/backend/nvpairingmanager.cpp (L191-354)
```cpp
NvPairingManager::pair(QString appVersion, QString pin, QSslCertificate& serverCert)
{
    int serverMajorVersion = NvHTTP::parseQuad(appVersion).at(0);
    qInfo() << "Pairing with server generation:" << serverMajorVersion;

    QCryptographicHash::Algorithm hashAlgo;
    int hashLength;
    if (serverMajorVersion >= 7)
    {
        // Gen 7+ uses SHA-256 hashing
        hashAlgo = QCryptographicHash::Sha256;
        hashLength = 32;
    }
    else
    {
        // Prior to Gen 7 uses SHA-1 hashing
        hashAlgo = QCryptographicHash::Sha1;
        hashLength = 20;
    }

    QByteArray salt = generateRandomBytes(16);
    QByteArray saltedPin = saltPin(salt, pin);

    QByteArray aesKey = QCryptographicHash::hash(saltedPin, hashAlgo).constData();
    aesKey.truncate(16);

    QString getCert = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&phrase=getservercert&salt=" +
                                                    salt.toHex() + "&clientcert=" + IdentityManager::get()->getCertificate().toHex(),
                                                    0);
    NvHTTP::verifyResponseStatus(getCert);
    if (NvHTTP::getXmlString(getCert, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #1";
        return PairState::FAILED;
    }

    QByteArray serverCertStr = NvHTTP::getXmlStringFromHex(getCert, "plaincert");
    if (serverCertStr == nullptr)
    {
        qCritical() << "Server likely already pairing";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::ALREADY_IN_PROGRESS;
    }

    QSslCertificate unverifiedServerCert = QSslCertificate(serverCertStr);
    if (unverifiedServerCert.isNull()) {
        Q_ASSERT(!unverifiedServerCert.isNull());

        qCritical() << "Failed to parse plaincert";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    // Pin this cert for TLS until pairing is complete. If successful, we will propagate
    // the cert into the NvComputer object and persist it.
    m_Http.setServerCert(unverifiedServerCert);

    QByteArray randomChallenge = generateRandomBytes(16);
    QByteArray encryptedChallenge = encrypt(randomChallenge, aesKey);
    QString challengeXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                         "pair",
                                                         "devicename=roth&updateState=1&clientchallenge=" +
                                                         encryptedChallenge.toHex(),
                                                         REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(challengeXml);
    if (NvHTTP::getXmlString(challengeXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #2";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray challengeResponseData = decrypt(m_Http.getXmlStringFromHex(challengeXml, "challengeresponse"), aesKey);
    QByteArray clientSecretData = generateRandomBytes(16);
    QByteArray challengeResponse;
    QByteArray serverResponse(challengeResponseData.data(), hashLength);

#if (OPENSSL_VERSION_NUMBER < 0x10002000L)
    ASN1_BIT_STRING *asnSignature = m_Cert->signature;
#elif (OPENSSL_VERSION_NUMBER < 0x10100000L)
    ASN1_BIT_STRING *asnSignature;
    X509_get0_signature(&asnSignature, NULL, m_Cert);
#else
    const ASN1_BIT_STRING *asnSignature;
    X509_get0_signature(&asnSignature, NULL, m_Cert);
#endif

    challengeResponse.append(challengeResponseData.data() + hashLength, 16);
    challengeResponse.append(reinterpret_cast<char*>(asnSignature->data), asnSignature->length);
    challengeResponse.append(clientSecretData);

    QByteArray paddedHash = QCryptographicHash::hash(challengeResponse, hashAlgo);
    paddedHash.resize(32);
    QByteArray encryptedChallengeResponseHash = encrypt(paddedHash, aesKey);
    QString respXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&serverchallengeresp=" +
                                                    encryptedChallengeResponseHash.toHex(),
                                                    REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(respXml);
    if (NvHTTP::getXmlString(respXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #3";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray pairingSecret = NvHTTP::getXmlStringFromHex(respXml, "pairingsecret");
    QByteArray serverSecret = pairingSecret.left(16);
    QByteArray serverSignature = pairingSecret.mid(16);

    if (!verifySignature(serverSecret,
                         serverSignature,
                         serverCertStr))
    {
        qCritical() << "MITM detected";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray expectedResponseData;
    expectedResponseData.append(randomChallenge);
    expectedResponseData.append(getSignatureFromPemCert(serverCertStr));
    expectedResponseData.append(serverSecret);
    if (QCryptographicHash::hash(expectedResponseData, hashAlgo) != serverResponse)
    {
        qCritical() << "Incorrect PIN";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::PIN_WRONG;
    }

    QByteArray clientPairingSecret;
    clientPairingSecret.append(clientSecretData);
    clientPairingSecret.append(signMessage(clientSecretData));

    QString secretRespXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                          "pair",
                                                          "devicename=roth&updateState=1&clientpairingsecret=" +
                                                          clientPairingSecret.toHex(),
                                                          REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(secretRespXml);
    if (NvHTTP::getXmlString(secretRespXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #4";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QString pairChallengeXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttps,
                                                             "pair",
                                                             "devicename=roth&updateState=1&phrase=pairchallenge",
                                                             REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(pairChallengeXml);
    if (NvHTTP::getXmlString(pairChallengeXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #5";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    serverCert = std::move(unverifiedServerCert);
    return PairState::PAIRED;
```
**File:** app/backend/nvhttp.cpp (L43-46)
```cpp
void NvHTTP::setServerCert(QSslCertificate serverCert)
{
    m_ServerCert = serverCert;
}
```
**File:** app/backend/nvhttp.cpp (L419-439)
```cpp
void NvHTTP::handleSslErrors(QNetworkReply* reply, const QList<QSslError>& errors)
{
    bool ignoreErrors = true;

    if (m_ServerCert.isNull()) {
        // We should never make an HTTPS request without a cert
        Q_ASSERT(!m_ServerCert.isNull());
        return;
    }

    for (const QSslError& error : errors) {
        if (m_ServerCert != error.certificate()) {
            ignoreErrors = false;
            break;
        }
    }

    if (ignoreErrors) {
        reply->ignoreSslErrors(errors);
    }
}
```
**File:** app/backend/nvcomputer.h (L113-113)
```text
    QSslCertificate serverCert;
```
**File:** app/backend/computermanager.cpp (L599-603)
```cpp
           case NvPairingManager::PairState::PAIRED:
               // Persist the newly pinned server certificate for this host
               m_ComputerManager->saveHost(m_Computer);

               emit pairingCompleted(m_Computer, nullptr);
```
## Q7
When the client has launched/started the game and begun streaming before disconnecting, how does the client recover the connection?
### Answer
You're asking about how Moonlight handles connection recovery when a streaming session disconnects after it has already started.

## Answer

When a streaming session disconnects, Moonlight determines whether to call `/launch` or `/resume` based on the `currentgame` value from the host's `/serverinfo` response. moonlight-qt:1586-1586 

### Resume vs Launch Decision

In `Session::startConnectionAsync()`, the code checks if `m_Computer->currentgame` is non-zero (indicating a game is already running on the host): moonlight-qt:1556-1557 

If the game is already running, it calls `NvHTTP::startApp()` with the `"resume"` parameter instead of `"launch"`: moonlight-qt:1586-1593 

```cpp
http.startApp(m_Computer->currentgame != 0 ? "resume" : "launch",
              m_Computer->isNvidiaServerSoftware,
              m_App.id, &m_StreamConfig,
              enableGameOptimizations,
              m_Preferences->playAudioOnHost,
              m_InputHandler->getAttachedGamepadMask(),
              !m_Preferences->multiController,
              rtspSessionUrl);
```

### How Resume Works

The `/resume` endpoint tells the host to reconnect to an existing game session rather than starting a new one.<cite /> This preserves the game state and allows the client to rejoin the same streaming session.<cite />

The same connection establishment process follows after calling `/resume` - the RTSP session URL is obtained from the response and passed to `LiStartConnection()` to establish the streaming connection. moonlight-qt:1678-1680 

### State Detection

The host's state is tracked through periodic `/serverinfo` polling, which updates the `currentgame` field in the `NvComputer` object.<cite /> When the state shows `SUNSHINE_SERVER_BUSY` (as in your earlier example) with a non-zero `currentgame` value, Moonlight knows a game is already running and will use resume instead of launch.<cite />

## Notes

The resume functionality allows seamless reconnection to an existing game session without restarting the game on the host. This is particularly useful for temporary network interruptions or when the client application crashes but the host game continues running. The same certificate authentication and connection establishment process is used for both launch and resume operations.

Wiki pages you might want to explore:
- [User Interface System (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2)
- [Streaming Core (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#4)
### Citations
**File:** app/streaming/session.cpp (L1556-1557)
```cpp
    Q_ASSERT(m_Computer->currentGameId == 0 ||
             m_Computer->currentGameId == m_App.id);
```
**File:** app/streaming/session.cpp (L1586-1593)
```cpp
        http.startApp(m_Computer->currentGameId != 0 ? "resume" : "launch",
                      m_Computer->isNvidiaServerSoftware,
                      m_App.id, &m_StreamConfig,
                      enableGameOptimizations,
                      m_Preferences->playAudioOnHost,
                      m_InputHandler->getAttachedGamepadMask(),
                      !m_Preferences->multiController,
                      rtspSessionUrl);
```
**File:** app/streaming/session.cpp (L1678-1680)
```cpp
    int err = LiStartConnection(&hostInfo, &m_StreamConfig, &k_ConnCallbacks,
                                &m_VideoCallbacks, &m_AudioCallbacks,
                                NULL, 0, NULL, 0);
```
## Q8
How does the client terminate the connection?
### Answer
You're asking about how Moonlight terminates a streaming connection when the user wants to disconnect.

## Answer

Moonlight provides multiple ways to terminate a streaming connection:

### User-Initiated Disconnection

Users can disconnect from an active streaming session using keyboard shortcuts or gamepad button combinations. The UI displays a tip showing these options: **Ctrl+Alt+Shift+Q** for keyboard or **Start+Select+L1+R1** for gamepad. moonlight-qt:167-168 

### Connection Termination Flow

When a connection terminates, the `Session::clConnectionTerminated()` callback is invoked with an error code. moonlight-qt:98-155  This callback:

1. **Performs port testing** to diagnose connectivity issues if the termination was unexpected moonlight-qt:100-101 

2. **Determines if termination was graceful** - If the error code is `ML_ERROR_GRACEFUL_TERMINATION`, no error dialog is shown moonlight-qt:105-106 

3. **Displays error messages** for unexpected terminations (network issues, video encoding errors, etc.) moonlight-qt:108-144 

4. **Pushes a quit event** to the SDL event loop to exit the streaming session moonlight-qt:150-154 

### UI Cleanup After Termination

After the session ends, the `StreamSegue::sessionFinished()` method handles cleanup: moonlight-qt:73-108 

1. **Re-enables gamepad navigation** for the UI moonlight-qt:79-80 

2. **Pops the stream view** from the navigation stack to return to the previous screen moonlight-qt:93-94 

3. **Shows the main window** again moonlight-qt:96-97 

4. **Displays any error dialogs** if the termination was unexpected moonlight-qt:103-106 

The session object is then garbage collected to free resources. moonlight-qt:110-116 

### Quitting Running Apps

Moonlight can also terminate a running game on the host without streaming it. The `ComputerManager::quitRunningApp()` method creates a `PendingQuitTask` that sends a quit request to the host server. moonlight-qt:675-682  This is used when users want to stop a game remotely without connecting to it.

## Notes

The termination process distinguishes between graceful disconnections (user-initiated) and unexpected terminations (network errors, encoding failures). For unexpected terminations, Moonlight performs network diagnostics and displays helpful error messages to guide troubleshooting. The same cleanup process applies whether the user disconnects manually or the connection fails unexpectedly.

Wiki pages you might want to explore:
- [User Interface System (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2)
- [PC Discovery View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.1)
### Citations
**File:** app/gui/StreamSegue.qml (L73-108)
```text
    function sessionFinished(portTestResult)
    {
        if (portTestResult !== 0 && portTestResult !== -1 && streamSegueErrorDialog.text) {
            streamSegueErrorDialog.text += "\n\n" + qsTr("This PC's Internet connection is blocking Moonlight. Streaming over the Internet may not work while connected to this network.")
        }

        // Re-enable GUI gamepad usage now
        SdlGamepadKeyNavigation.enable()

        if (quitAfter) {
            if (streamSegueErrorDialog.text) {
                // Quit when the error dialog is acknowledged
                streamSegueErrorDialog.quitAfter = quitAfter
                streamSegueErrorDialog.open()
            }
            else {
                // Quit immediately
                Qt.quit()
            }
        } else {
            // Exit this view
            stackView.pop()

            // Show the Qt window again after streaming
            window.visible = true

            // Display any launch errors. We do this after
            // the Qt UI is visible again to prevent losing
            // focus on the dialog which would impact gamepad
            // users.
            if (streamSegueErrorDialog.text) {
                streamSegueErrorDialog.quitAfter = quitAfter
                streamSegueErrorDialog.open()
            }
        }
    }
```
**File:** app/gui/StreamSegue.qml (L110-116)
```text
    function sessionReadyForDeletion()
    {
        // Garbage collect the Session object since it's pretty heavyweight
        // and keeps other libraries (like SDL_TTF) around until it is deleted.
        session = null
        gc()
    }
```
**File:** app/gui/StreamSegue.qml (L167-168)
```text
            hintText.text = qsTr("Tip:") + " " + qsTr("Press %1 to disconnect your session").arg(SdlGamepadKeyNavigation.getConnectedGamepads() > 0 ?
                                                  qsTr("Start+Select+L1+R1") : qsTr("Ctrl+Alt+Shift+Q"))
```
**File:** app/streaming/session.cpp (L98-155)
```cpp
void Session::clConnectionTerminated(int errorCode)
{
    unsigned int portFlags = LiGetPortFlagsFromTerminationErrorCode(errorCode);
    s_ActiveSession->m_PortTestResults = LiTestClientConnectivity(CONN_TEST_SERVER, 443, portFlags);

    // Display the termination dialog if this was not intended
    switch (errorCode) {
    case ML_ERROR_GRACEFUL_TERMINATION:
        break;

    case ML_ERROR_NO_VIDEO_TRAFFIC:
        s_ActiveSession->m_UnexpectedTermination = true;

        char ports[128];
        SDL_assert(portFlags != 0);
        LiStringifyPortFlags(portFlags, ", ", ports, sizeof(ports));
        emit s_ActiveSession->displayLaunchError(tr("No video received from host.") + "\n\n"+
                                                 tr("Check your firewall and port forwarding rules for port(s): %1").arg(ports));
        break;

    case ML_ERROR_NO_VIDEO_FRAME:
        s_ActiveSession->m_UnexpectedTermination = true;
        emit s_ActiveSession->displayLaunchError(tr("Your network connection isn't performing well. Reduce your video bitrate setting or try a faster connection."));
        break;

    case ML_ERROR_PROTECTED_CONTENT:
    case ML_ERROR_UNEXPECTED_EARLY_TERMINATION:
        s_ActiveSession->m_UnexpectedTermination = true;
        emit s_ActiveSession->displayLaunchError(tr("Something went wrong on your host PC when starting the stream.") + "\n\n" +
                                                 tr("Make sure you don't have any DRM-protected content open on your host PC. You can also try restarting your host PC."));
        break;

    case ML_ERROR_FRAME_CONVERSION:
        s_ActiveSession->m_UnexpectedTermination = true;
        emit s_ActiveSession->displayLaunchError(tr("The host PC reported a fatal video encoding error.") + "\n\n" +
                                                 tr("Try disabling HDR mode, changing the streaming resolution, or changing your host PC's display resolution."));
        break;

    default:
        s_ActiveSession->m_UnexpectedTermination = true;

        // We'll assume large errors are hex values
        bool hexError = qAbs(errorCode) > 1000;
        emit s_ActiveSession->displayLaunchError(tr("Connection terminated") + "\n\n" +
                                                 tr("Error code: %1").arg(errorCode, hexError ? 8 : 0, hexError ? 16 : 10, QChar('0')));
        break;
    }

    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION,
                 "Connection terminated: %d",
                 errorCode);

    // Push a quit event to the main loop
    SDL_Event event;
    event.type = SDL_QUIT;
    event.quit.timestamp = SDL_GetTicks();
    SDL_PushEvent(&event);
}
```
**File:** app/backend/computermanager.cpp (L675-682)
```cpp
void ComputerManager::quitRunningApp(NvComputer* computer)
{
    QWriteLocker lock(&computer->lock);
    computer->pendingQuit = true;

    PendingQuitTask* quit = new PendingQuitTask(this, computer);
    QThreadPool::globalInstance()->start(quit);
}
```
## Q9
Please list all the APIs used for the client and server interaction, including their purposes and required parameters, and list the APIs needed for the entire process from adding a computer to selecting one in the app list and starting a connection to ending the connection.
### Answer
Based on my analysis of the Moonlight codebase, here are all the client-server interaction APIs used throughout the entire process:

## 1. **Adding a Computer**

### Server Discovery - `serverinfo` API
**Purpose**: Discover and retrieve information about the host PC, including pairing status, current game, server version, and HTTPS port. moonlight-qt:124-187 

**Required Parameters**:
- `uniqueid`: Common UID for Moonlight clients (fixed: "0123456789ABCDEF")
- `uuid`: Random UUID for the request

**Protocol**: HTTP initially (before pairing), then HTTPS (after pairing)

### Pairing - 5-Phase Cryptographic Handshake

**Purpose**: Establish trust between client and host PC through certificate exchange and PIN verification. moonlight-qt:191-355 

**Phase 1 - Get Server Certificate**:
- Endpoint: `pair`
- Parameters:
  - `devicename=roth`
  - `updateState=1`
  - `phrase=getservercert`
  - `salt`: 16-byte random salt (hex)
  - `clientcert`: Client certificate (hex)

**Phase 2 - Client Challenge**:
- Endpoint: `pair`
- Parameters:
  - `devicename=roth`
  - `updateState=1`
  - `clientchallenge`: Encrypted 16-byte challenge (hex)

**Phase 3 - Server Challenge Response**:
- Endpoint: `pair`
- Parameters:
  - `devicename=roth`
  - `updateState=1`
  - `serverchallengeresp`: Encrypted challenge response hash (hex)

**Phase 4 - Client Pairing Secret**:
- Endpoint: `pair`
- Parameters:
  - `devicename=roth`
  - `updateState=1`
  - `clientpairingsecret`: Client secret + signature (hex)

**Phase 5 - Final Challenge (HTTPS)**:
- Endpoint: `pair`
- Parameters:
  - `devicename=roth`
  - `updateState=1`
  - `phrase=pairchallenge`

**Protocol**: HTTP for phases 1-4, HTTPS for phase 5

## 2. **Selecting an App**

### App List - `applist` API
**Purpose**: Retrieve the list of available applications on the host PC. moonlight-qt:288-328 

**Required Parameters**:
- `uniqueid`: "0123456789ABCDEF"
- `uuid`: Random UUID

**Protocol**: HTTPS (requires prior pairing)

**Response**: XML with app information including:
- `AppTitle`: Application name
- `ID`: Application ID
- `IsHdrSupported`: HDR capability
- `IsAppCollectorGame`: Whether it's an App Collector game

### Box Art - `getBoxArt` API
**Purpose**: Download application cover art/thumbnails. moonlight-qt:178-179 moonlight-qt:107-129 

**Required Parameters**:
- `appId`: Application ID

**Protocol**: HTTPS
**Response**: Image data (various formats, cached as PNG locally)

## 3. **Starting a Streaming Connection**

### Launch/Resume - `launch` or `resume` API
**Purpose**: Start a new streaming session or resume an existing one. moonlight-qt:190-236 moonlight-qt:1582-1600 

**Endpoint**: `launch` (new session) or `resume` (existing session)

**Required Parameters**:
- `uniqueid`: "0123456789ABCDEF"
- `uuid`: Random UUID
- `appid`: Application ID to launch
- `mode`: Resolution and FPS (format: `{width}x{height}x{fps}`)
- `additionalStates=1`: Enable additional states
- `sops`: Stream optimization settings (0 or 1)
- `rikey`: Remote input AES key (hex)
- `rikeyid`: Remote input key ID
- `hdrMode`: HDR mode flag (included if HDR supported)
- `clientHdrCapVersion`, `clientHdrCapSupportedFlagsInUint32`, `clientHdrCapMetaDataId`, `clientHdrCapDisplayData`: HDR capability parameters (if HDR mode)
- `localAudioPlayMode`: Play audio on host (0 or 1)
- `surroundAudioInfo`: Surround audio configuration
- `remoteControllersBitmap`: Gamepad mask
- `gcmap`: Gamepad controller map
- `gcpersist`: Persist game controllers on disconnect (0 or 1)
- Additional parameters from `LiGetLaunchUrlQueryParameters()`

**Protocol**: HTTPS

**Response**: XML containing `sessionUrl0` (RTSP session URL)

**Decision Logic**: The verb is determined based on whether a game is currently running: moonlight-qt:1586-1593 

## 4. **Ending a Streaming Connection**

### Quit App - `cancel` API
**Purpose**: Terminate the currently running application on the host PC. moonlight-qt:238-259 

**Required Parameters**:
- `uniqueid`: "0123456789ABCDEF"
- `uuid`: Random UUID

**Protocol**: HTTPS

**Timeout**: 30 seconds

**Note**: The quit operation is optional based on user preferences: moonlight-qt:1554-1558 

## Additional APIs

### Wake-on-LAN
**Purpose**: Wake up a sleeping/powered-off host PC. moonlight-qt:1-50 

**Protocol**: UDP magic packets sent to multiple addresses and ports (9, 47009, and dynamic ports 47998-48010)

### Unpair - `unpair` API
**Purpose**: Remove pairing relationship (used during pairing failures). moonlight-qt:232-234 

**Required Parameters**: Standard uniqueid and uuid

**Protocol**: HTTP

## Notes

- All HTTP/HTTPS requests use a common `uniqueid` of "0123456789ABCDEF" to allow Moonlight clients to manage each other's sessions
- Each request includes a random `uuid` parameter generated via `QUuid::createUuid()`
- Certificate pinning is implemented for HTTPS connections to prevent MITM attacks
- Timeouts vary by operation: 2s (fast-fail), 5s (normal), 30s (resume/quit), 120s (launch)
- The base URL format is `http(s)://{host}:{port}/{command}?{parameters}`
### Citations
**File:** app/backend/nvhttp.cpp (L124-187)
```cpp
NvHTTP::getServerInfo(NvLogLevel logLevel, bool fastFail)
{
    QString serverInfo;

    // Check if we have a pinned cert and HTTPS port for this host yet
    if (!m_ServerCert.isNull() && httpsPort() != 0)
    {
        try
        {
            // Always try HTTPS first, since it properly reports
            // pairing status (and a few other attributes).
            serverInfo = openConnectionToString(m_BaseUrlHttps,
                                                "serverinfo",
                                                nullptr,
                                                fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                                logLevel);
            // Throws if the request failed
            verifyResponseStatus(serverInfo);
        }
        catch (const GfeHttpResponseException& e)
        {
            if (e.getStatusCode() == 401)
            {
                // Certificate validation error, fallback to HTTP
                serverInfo = openConnectionToString(m_BaseUrlHttp,
                                                    "serverinfo",
                                                    nullptr,
                                                    fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                                    logLevel);
                verifyResponseStatus(serverInfo);
            }
            else
            {
                // Rethrow real errors
                throw e;
            }
        }
    }
    else
    {
        // Only use HTTP prior to pairing or fetching HTTPS port
        serverInfo = openConnectionToString(m_BaseUrlHttp,
                                            "serverinfo",
                                            nullptr,
                                            fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                            logLevel);
        verifyResponseStatus(serverInfo);

        // Populate the HTTPS port
        uint16_t httpsPort = getXmlString(serverInfo, "HttpsPort").toUShort();
        if (httpsPort == 0) {
            httpsPort = DEFAULT_HTTPS_PORT;
        }
        setHttpsPort(httpsPort);

        // If we just needed to determine the HTTPS port, we'll try again over
        // HTTPS now that we have the port number
        if (!m_ServerCert.isNull()) {
            return getServerInfo(logLevel, fastFail);
        }
    }

    return serverInfo;
}
```
**File:** app/backend/nvhttp.cpp (L190-236)
```cpp
NvHTTP::startApp(QString verb,
                 bool isGfe,
                 int appId,
                 PSTREAM_CONFIGURATION streamConfig,
                 bool sops,
                 bool localAudio,
                 int gamepadMask,
                 bool persistGameControllersOnDisconnect,
                 QString& rtspSessionUrl)
{
    int riKeyId;

    memcpy(&riKeyId, streamConfig->remoteInputAesIv, sizeof(riKeyId));
    riKeyId = qFromBigEndian(riKeyId);

    QString response =
            openConnectionToString(m_BaseUrlHttps,
                                   verb,
                                   "appid="+QString::number(appId)+
                                   "&mode="+QString::number(streamConfig->width)+"x"+
                                   QString::number(streamConfig->height)+"x"+
                                   // Using an FPS value over 60 causes SOPS to default to 720p60,
                                   // so force it to 0 to ensure the correct resolution is set. We
                                   // used to use 60 here but that locked the frame rate to 60 FPS
                                   // on GFE 3.20.3. We don't need this hack for Sunshine.
                                   QString::number((streamConfig->fps > 60 && isGfe) ? 0 : streamConfig->fps)+
                                   "&additionalStates=1&sops="+QString::number(sops ? 1 : 0)+
                                   "&rikey="+QByteArray(streamConfig->remoteInputAesKey, sizeof(streamConfig->remoteInputAesKey)).toHex()+
                                   "&rikeyid="+QString::number(riKeyId)+
                                   ((streamConfig->supportedVideoFormats & VIDEO_FORMAT_MASK_10BIT) ?
                                       "&hdrMode=1&clientHdrCapVersion=0&clientHdrCapSupportedFlagsInUint32=0&clientHdrCapMetaDataId=NV_STATIC_METADATA_TYPE_1&clientHdrCapDisplayData=0x0x0x0x0x0x0x0x0x0x0" :
                                        "")+
                                   "&localAudioPlayMode="+QString::number(localAudio ? 1 : 0)+
                                   "&surroundAudioInfo="+QString::number(SURROUNDAUDIOINFO_FROM_AUDIO_CONFIGURATION(streamConfig->audioConfiguration))+
                                   "&remoteControllersBitmap="+QString::number(gamepadMask)+
                                   "&gcmap="+QString::number(gamepadMask)+
                                   "&gcpersist="+QString::number(persistGameControllersOnDisconnect ? 1 : 0)+
                                   LiGetLaunchUrlQueryParameters(),
                                   LAUNCH_TIMEOUT_MS);

    qInfo() << "Launch response:" << response;

    // Throws if the request failed
    verifyResponseStatus(response);

    rtspSessionUrl = getXmlString(response, "sessionUrl0");
}
```
**File:** app/backend/nvhttp.cpp (L238-259)
```cpp
void
NvHTTP::quitApp()
{
    QString response =
            openConnectionToString(m_BaseUrlHttps,
                                   "cancel",
                                   nullptr,
                                   QUIT_TIMEOUT_MS);

    qInfo() << "Quit response:" << response;

    // Throws if the request failed
    verifyResponseStatus(response);

    // Newer GFE versions will just return success even if quitting fails
    // if we're not the original requester.
    if (getCurrentGame(getServerInfo(NvHTTP::NVLL_ERROR)) != 0) {
        // Generate a synthetic GfeResponseException letting the caller know
        // that they can't kill someone else's stream.
        throw GfeHttpResponseException(599, "");
    }
}
```
**File:** app/backend/nvhttp.cpp (L288-328)
```cpp
QVector<NvApp>
NvHTTP::getAppList()
{
    QString appxml = openConnectionToString(m_BaseUrlHttps,
                                            "applist",
                                            nullptr,
                                            REQUEST_TIMEOUT_MS,
                                            NvLogLevel::NVLL_ERROR);
    verifyResponseStatus(appxml);

    QXmlStreamReader xmlReader(appxml);
    QVector<NvApp> apps;
    while (!xmlReader.atEnd()) {
        while (xmlReader.readNextStartElement()) {
            auto name = xmlReader.name();
            if (name == QString("App")) {
                // We must have a valid app before advancing to the next one
                if (!apps.isEmpty() && !apps.last().isInitialized()) {
                    qWarning() << "Invalid applist XML";
                    Q_ASSERT(false);
                    return QVector<NvApp>();
                }
                apps.append(NvApp());
            }
            else if (name == QString("AppTitle")) {
                apps.last().name = xmlReader.readElementText();
            }
            else if (name == QString("ID")) {
                apps.last().id = xmlReader.readElementText().toInt();
            }
            else if (name == QString("IsHdrSupported")) {
                apps.last().hdrSupported = xmlReader.readElementText() == "1";
            }
            else if (name == QString("IsAppCollectorGame")) {
                apps.last().isAppCollectorGame = xmlReader.readElementText() == "1";
            }
        }
    }

    return apps;
}
```
**File:** app/backend/nvpairingmanager.cpp (L191-355)
```cpp
NvPairingManager::pair(QString appVersion, QString pin, QSslCertificate& serverCert)
{
    int serverMajorVersion = NvHTTP::parseQuad(appVersion).at(0);
    qInfo() << "Pairing with server generation:" << serverMajorVersion;

    QCryptographicHash::Algorithm hashAlgo;
    int hashLength;
    if (serverMajorVersion >= 7)
    {
        // Gen 7+ uses SHA-256 hashing
        hashAlgo = QCryptographicHash::Sha256;
        hashLength = 32;
    }
    else
    {
        // Prior to Gen 7 uses SHA-1 hashing
        hashAlgo = QCryptographicHash::Sha1;
        hashLength = 20;
    }

    QByteArray salt = generateRandomBytes(16);
    QByteArray saltedPin = saltPin(salt, pin);

    QByteArray aesKey = QCryptographicHash::hash(saltedPin, hashAlgo).constData();
    aesKey.truncate(16);

    QString getCert = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&phrase=getservercert&salt=" +
                                                    salt.toHex() + "&clientcert=" + IdentityManager::get()->getCertificate().toHex(),
                                                    0);
    NvHTTP::verifyResponseStatus(getCert);
    if (NvHTTP::getXmlString(getCert, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #1";
        return PairState::FAILED;
    }

    QByteArray serverCertStr = NvHTTP::getXmlStringFromHex(getCert, "plaincert");
    if (serverCertStr == nullptr)
    {
        qCritical() << "Server likely already pairing";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::ALREADY_IN_PROGRESS;
    }

    QSslCertificate unverifiedServerCert = QSslCertificate(serverCertStr);
    if (unverifiedServerCert.isNull()) {
        Q_ASSERT(!unverifiedServerCert.isNull());

        qCritical() << "Failed to parse plaincert";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    // Pin this cert for TLS until pairing is complete. If successful, we will propagate
    // the cert into the NvComputer object and persist it.
    m_Http.setServerCert(unverifiedServerCert);

    QByteArray randomChallenge = generateRandomBytes(16);
    QByteArray encryptedChallenge = encrypt(randomChallenge, aesKey);
    QString challengeXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                         "pair",
                                                         "devicename=roth&updateState=1&clientchallenge=" +
                                                         encryptedChallenge.toHex(),
                                                         REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(challengeXml);
    if (NvHTTP::getXmlString(challengeXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #2";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray challengeResponseData = decrypt(m_Http.getXmlStringFromHex(challengeXml, "challengeresponse"), aesKey);
    QByteArray clientSecretData = generateRandomBytes(16);
    QByteArray challengeResponse;
    QByteArray serverResponse(challengeResponseData.data(), hashLength);

#if (OPENSSL_VERSION_NUMBER < 0x10002000L)
    ASN1_BIT_STRING *asnSignature = m_Cert->signature;
#elif (OPENSSL_VERSION_NUMBER < 0x10100000L)
    ASN1_BIT_STRING *asnSignature;
    X509_get0_signature(&asnSignature, NULL, m_Cert);
#else
    const ASN1_BIT_STRING *asnSignature;
    X509_get0_signature(&asnSignature, NULL, m_Cert);
#endif

    challengeResponse.append(challengeResponseData.data() + hashLength, 16);
    challengeResponse.append(reinterpret_cast<char*>(asnSignature->data), asnSignature->length);
    challengeResponse.append(clientSecretData);

    QByteArray paddedHash = QCryptographicHash::hash(challengeResponse, hashAlgo);
    paddedHash.resize(32);
    QByteArray encryptedChallengeResponseHash = encrypt(paddedHash, aesKey);
    QString respXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&serverchallengeresp=" +
                                                    encryptedChallengeResponseHash.toHex(),
                                                    REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(respXml);
    if (NvHTTP::getXmlString(respXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #3";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray pairingSecret = NvHTTP::getXmlStringFromHex(respXml, "pairingsecret");
    QByteArray serverSecret = pairingSecret.left(16);
    QByteArray serverSignature = pairingSecret.mid(16);

    if (!verifySignature(serverSecret,
                         serverSignature,
                         serverCertStr))
    {
        qCritical() << "MITM detected";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray expectedResponseData;
    expectedResponseData.append(randomChallenge);
    expectedResponseData.append(getSignatureFromPemCert(serverCertStr));
    expectedResponseData.append(serverSecret);
    if (QCryptographicHash::hash(expectedResponseData, hashAlgo) != serverResponse)
    {
        qCritical() << "Incorrect PIN";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::PIN_WRONG;
    }

    QByteArray clientPairingSecret;
    clientPairingSecret.append(clientSecretData);
    clientPairingSecret.append(signMessage(clientSecretData));

    QString secretRespXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                          "pair",
                                                          "devicename=roth&updateState=1&clientpairingsecret=" +
                                                          clientPairingSecret.toHex(),
                                                          REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(secretRespXml);
    if (NvHTTP::getXmlString(secretRespXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #4";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QString pairChallengeXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttps,
                                                             "pair",
                                                             "devicename=roth&updateState=1&phrase=pairchallenge",
                                                             REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(pairChallengeXml);
    if (NvHTTP::getXmlString(pairChallengeXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #5";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    serverCert = std::move(unverifiedServerCert);
    return PairState::PAIRED;
}
```
**File:** app/backend/nvhttp.h (L178-179)
```text
    QImage
    getBoxArt(int appId);
```
**File:** app/backend/boxartmanager.cpp (L107-129)
```cpp
QUrl BoxArtManager::loadBoxArtFromNetwork(NvComputer* computer, int appId)
{
    NvHTTP http(computer);

    QString cachePath = getFilePathForBoxArt(computer, appId);
    QImage image;
    try {
        image = http.getBoxArt(appId);
    } catch (...) {}

    // Cache the box art on disk if it loaded
    if (!image.isNull()) {
        if (image.save(cachePath)) {
            return QUrl::fromLocalFile(cachePath);
        }
        else {
            // A failed save() may leave a zero byte file. Make sure that's removed.
            QFile(cachePath).remove();
        }
    }

    return QUrl();
}
```
**File:** app/streaming/session.cpp (L1554-1558)
```cpp
    // The UI should have ensured the old game was already quit
    // if we decide to stream a different game.
    Q_ASSERT(m_Computer->currentGameId == 0 ||
             m_Computer->currentGameId == m_App.id);

```
**File:** app/streaming/session.cpp (L1582-1600)
```cpp
    QString rtspSessionUrl;

    try {
        NvHTTP http(m_Computer);
        http.startApp(m_Computer->currentGameId != 0 ? "resume" : "launch",
                      m_Computer->isNvidiaServerSoftware,
                      m_App.id, &m_StreamConfig,
                      enableGameOptimizations,
                      m_Preferences->playAudioOnHost,
                      m_InputHandler->getAttachedGamepadMask(),
                      !m_Preferences->multiController,
                      rtspSessionUrl);
    } catch (const GfeHttpResponseException& e) {
        emit displayLaunchError(tr("Host returned error: %1").arg(e.toQString()));
        return false;
    } catch (const QtNetworkReplyException& e) {
        emit displayLaunchError(e.toQString());
        return false;
    }
```
**File:** app/backend/nvcomputer.cpp (L1-50)
```cpp
#include "nvcomputer.h"
#include "nvapp.h"
#include "settings/compatfetcher.h"

#include <QUdpSocket>
#include <QHostInfo>
#include <QNetworkInterface>
#include <QNetworkProxy>

#define SER_NAME "hostname"
#define SER_UUID "uuid"
#define SER_MAC "mac"
#define SER_LOCALADDR "localaddress"
#define SER_LOCALPORT "localport"
#define SER_REMOTEADDR "remoteaddress"
#define SER_REMOTEPORT "remoteport"
#define SER_MANUALADDR "manualaddress"
#define SER_MANUALPORT "manualport"
#define SER_IPV6ADDR "ipv6address"
#define SER_IPV6PORT "ipv6port"
#define SER_APPLIST "apps"
#define SER_SRVCERT "srvcert"
#define SER_CUSTOMNAME "customname"
#define SER_NVIDIASOFTWARE "nvidiasw"

NvComputer::NvComputer(QSettings& settings)
{
    this->name = settings.value(SER_NAME).toString();
    this->uuid = settings.value(SER_UUID).toString();
    this->hasCustomName = settings.value(SER_CUSTOMNAME).toBool();
    this->macAddress = settings.value(SER_MAC).toByteArray();
    this->localAddress = NvAddress(settings.value(SER_LOCALADDR).toString(),
                                   settings.value(SER_LOCALPORT, QVariant(DEFAULT_HTTP_PORT)).toUInt());
    this->remoteAddress = NvAddress(settings.value(SER_REMOTEADDR).toString(),
                                    settings.value(SER_REMOTEPORT, QVariant(DEFAULT_HTTP_PORT)).toUInt());
    this->ipv6Address = NvAddress(settings.value(SER_IPV6ADDR).toString(),
                                  settings.value(SER_IPV6PORT, QVariant(DEFAULT_HTTP_PORT)).toUInt());
    this->manualAddress = NvAddress(settings.value(SER_MANUALADDR).toString(),
                                    settings.value(SER_MANUALPORT, QVariant(DEFAULT_HTTP_PORT)).toUInt());
    this->serverCert = QSslCertificate(settings.value(SER_SRVCERT).toByteArray());
    this->isNvidiaServerSoftware = settings.value(SER_NVIDIASOFTWARE).toBool();

    int appCount = settings.beginReadArray(SER_APPLIST);
    this->appList.reserve(appCount);
    for (int i = 0; i < appCount; i++) {
        settings.setArrayIndex(i);

        NvApp app(settings);
        this->appList.append(app);
    }
```
## Q10
The server completes the pairing by inputting the PIN code displayed by the client. How does the client wait for the server's response to complete the pairing during the time the PIN code is generated and the user inputs the PIN on the server side?
### Answer
You're asking about how the Moonlight client waits for the server to complete pairing after displaying the PIN code to the user.

## Answer

The client doesn't actively poll or wait for the server's response during pairing. Instead, the pairing process is **synchronous and blocking** - the client sends requests sequentially through all 5 phases and waits for each response before proceeding to the next phase.

### Pairing Execution Flow

When the user clicks on an unpaired PC, the client generates a PIN and displays it in a dialog: moonlight-qt:239-246 

The pairing task runs in a background thread via `PendingPairingTask`: moonlight-qt:564-582 

### The Blocking Nature of Pairing

Inside `NvPairingManager::pair()`, each phase makes an HTTP/HTTPS request and **blocks waiting for the response** before proceeding: moonlight-qt:217-227 

The server validates the PIN during Phase 3 (server challenge response). If the user hasn't entered the PIN yet on the server side, the server simply doesn't respond or returns an error, causing the pairing to fail: moonlight-qt:287-298 

### PIN Validation

The PIN validation happens when the client sends the encrypted challenge response hash in Phase 3. The server decrypts this using the PIN-derived key and verifies it matches the expected value: moonlight-qt:313-322 

If the PIN is incorrect (user entered wrong PIN on server), the server returns a response that causes the client to detect `PIN_WRONG` state: moonlight-qt:585-586 

### UI Feedback

While pairing is in progress, the dialog remains open showing the PIN: moonlight-qt:302-310 

When pairing completes (successfully or with error), the `pairingCompleted` signal is emitted, which closes the dialog: moonlight-qt:47-58 

## Notes

The pairing process uses HTTP request timeouts (defined as `REQUEST_TIMEOUT_MS`) to prevent indefinite waiting. If the user takes too long to enter the PIN on the server, the HTTP request will timeout and pairing will fail. The client doesn't implement any retry logic or polling mechanism - it's a single synchronous attempt that either succeeds or fails based on the server's responses to the 5-phase handshake.

Wiki pages you might want to explore:
- [User Interface System (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2)
- [PC Discovery View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.1)
### Citations
**File:** app/gui/PcView.qml (L47-58)
```text
    function pairingComplete(error)
    {
        // Close the PIN dialog
        pairDialog.close()

        // Display a failed dialog if we got an error
        if (error !== undefined) {
            errorDialog.text = error
            errorDialog.helpText = ""
            errorDialog.open()
        }
    }
```
**File:** app/gui/PcView.qml (L239-246)
```text
                    var pin = computerModel.generatePinString()

                    // Kick off pairing in the background
                    computerModel.pairComputer(index, pin)

                    // Display the pairing dialog
                    pairDialog.pin = pin
                    pairDialog.open()
```
**File:** app/gui/PcView.qml (L302-310)
```text
        // don't allow edits to the rest of the window while open
        property string pin : "0000"
        text:qsTr("Please enter %1 on your host PC. This dialog will close when pairing is completed.").arg(pin)+"\n\n"+
             qsTr("If your host PC is running Sunshine, navigate to the Sunshine web UI to enter the PIN.")
        standardButtons: Dialog.Cancel
        onRejected: {
            // FIXME: We should interrupt pairing here
        }
    }
```
**File:** app/backend/computermanager.cpp (L564-582)
```cpp
    PendingPairingTask(ComputerManager* computerManager, NvComputer* computer, QString pin)
        : m_ComputerManager(computerManager),
          m_Computer(computer),
          m_Pin(pin)
    {
        connect(this, &PendingPairingTask::pairingCompleted,
                computerManager, &ComputerManager::pairingCompleted);
    }

signals:
    void pairingCompleted(NvComputer* computer, QString error);

private:
    void run()
    {
        NvPairingManager pairingManager(m_Computer);

        try {
           NvPairingManager::PairState result = pairingManager.pair(m_Computer->appVersion, m_Pin, m_Computer->serverCert);
```
**File:** app/backend/computermanager.cpp (L585-586)
```cpp
           case NvPairingManager::PairState::PIN_WRONG:
               emit pairingCompleted(m_Computer, tr("The PIN from the PC didn't match. Please try again."));
```
**File:** app/backend/nvpairingmanager.cpp (L217-227)
```cpp
    QString getCert = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&phrase=getservercert&salt=" +
                                                    salt.toHex() + "&clientcert=" + IdentityManager::get()->getCertificate().toHex(),
                                                    0);
    NvHTTP::verifyResponseStatus(getCert);
    if (NvHTTP::getXmlString(getCert, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #1";
        return PairState::FAILED;
    }
```
**File:** app/backend/nvpairingmanager.cpp (L287-298)
```cpp
    QString respXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&serverchallengeresp=" +
                                                    encryptedChallengeResponseHash.toHex(),
                                                    REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(respXml);
    if (NvHTTP::getXmlString(respXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #3";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }
```
**File:** app/backend/nvpairingmanager.cpp (L313-322)
```cpp
    QByteArray expectedResponseData;
    expectedResponseData.append(randomChallenge);
    expectedResponseData.append(getSignatureFromPemCert(serverCertStr));
    expectedResponseData.append(serverSecret);
    if (QCryptographicHash::hash(expectedResponseData, hashAlgo) != serverResponse)
    {
        qCritical() << "Incorrect PIN";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::PIN_WRONG;
    }
```
# DeepWiki Q&A with Code Context for Repository: moonlight-stream/moonlight-qt
## Q1
how to get /launch and /serverinfo info from server?
### Answer
Based on the code context, you're asking about how Moonlight retrieves `/launch` and `/serverinfo` information from the host server.

## Answer

Moonlight uses the `NvHTTP` class to communicate with the host server and retrieve information through HTTP/HTTPS endpoints. moonlight-qt:124-187 

### Getting `/serverinfo`

The `NvHTTP::getServerInfo()` method fetches server information: moonlight-qt:124-140 

The method first attempts to use HTTPS if a pinned certificate is available, then falls back to HTTP if needed. moonlight-qt:143-160  If no certificate exists yet, it uses HTTP initially to fetch the HTTPS port, then retries over HTTPS. moonlight-qt:162-183 

This is called during PC discovery when adding a new host: moonlight-qt:809-818 

The response is then used to create or update an `NvComputer` object: moonlight-qt:820-821 

### Getting `/launch` info

The `/launch` endpoint is called via `NvHTTP::startApp()` when starting a streaming session: moonlight-qt:1585-1593 

This happens in `Session::startConnectionAsync()` after the user selects an app to stream. moonlight-qt:1548-1600  The method passes streaming configuration parameters and receives back an RTSP session URL that's used to establish the actual streaming connection. moonlight-qt:1582-1593 

## Notes

The `NvHTTP` class handles all HTTP/HTTPS communication with the host server, including certificate pinning for security. The `/serverinfo` endpoint is polled regularly to monitor PC status, while `/launch` (or `/resume`) is only called when initiating a streaming session. Both endpoints use the base URL constructed from the host's address and appropriate port (HTTP 47989 or HTTPS 47984 by default).

Wiki pages you might want to explore:
- [User Interface System (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2)
- [PC Discovery View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.1)
### Citations
**File:** app/backend/nvhttp.cpp (L124-187)
```cpp
NvHTTP::getServerInfo(NvLogLevel logLevel, bool fastFail)
{
    QString serverInfo;

    // Check if we have a pinned cert and HTTPS port for this host yet
    if (!m_ServerCert.isNull() && httpsPort() != 0)
    {
        try
        {
            // Always try HTTPS first, since it properly reports
            // pairing status (and a few other attributes).
            serverInfo = openConnectionToString(m_BaseUrlHttps,
                                                "serverinfo",
                                                nullptr,
                                                fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                                logLevel);
            // Throws if the request failed
            verifyResponseStatus(serverInfo);
        }
        catch (const GfeHttpResponseException& e)
        {
            if (e.getStatusCode() == 401)
            {
                // Certificate validation error, fallback to HTTP
                serverInfo = openConnectionToString(m_BaseUrlHttp,
                                                    "serverinfo",
                                                    nullptr,
                                                    fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                                    logLevel);
                verifyResponseStatus(serverInfo);
            }
            else
            {
                // Rethrow real errors
                throw e;
            }
        }
    }
    else
    {
        // Only use HTTP prior to pairing or fetching HTTPS port
        serverInfo = openConnectionToString(m_BaseUrlHttp,
                                            "serverinfo",
                                            nullptr,
                                            fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                            logLevel);
        verifyResponseStatus(serverInfo);

        // Populate the HTTPS port
        uint16_t httpsPort = getXmlString(serverInfo, "HttpsPort").toUShort();
        if (httpsPort == 0) {
            httpsPort = DEFAULT_HTTPS_PORT;
        }
        setHttpsPort(httpsPort);

        // If we just needed to determine the HTTPS port, we'll try again over
        // HTTPS now that we have the port number
        if (!m_ServerCert.isNull()) {
            return getServerInfo(logLevel, fastFail);
        }
    }

    return serverInfo;
}
```
**File:** app/backend/computermanager.cpp (L809-818)
```cpp
        // Perform initial serverinfo fetch over HTTP since we don't know which cert to use
        QString serverInfo = fetchServerInfo(http);
        if (serverInfo.isEmpty() && !m_MdnsIpv6Address.isNull()) {
            // Retry using the global IPv6 address if the IPv4 or link-local IPv6 address fails
            http.setAddress(m_MdnsIpv6Address);
            serverInfo = fetchServerInfo(http);
        }
        if (serverInfo.isEmpty()) {
            return;
        }
```
**File:** app/backend/computermanager.cpp (L820-821)
```cpp
        // Create initial newComputer using HTTP serverinfo with no pinned cert
        NvComputer* newComputer = new NvComputer(http, serverInfo);
```
**File:** app/streaming/session.cpp (L1548-1600)
```cpp
bool Session::startConnectionAsync()
{
    // Wait 1.5 seconds before connecting to let the user
    // have time to read any messages present on the segue
    SDL_Delay(1500);

    // The UI should have ensured the old game was already quit
    // if we decide to stream a different game.
    Q_ASSERT(m_Computer->currentGameId == 0 ||
             m_Computer->currentGameId == m_App.id);

    bool enableGameOptimizations;
    if (m_Computer->isNvidiaServerSoftware) {
        // GFE will set all settings to 720p60 if it doesn't recognize
        // the chosen resolution. Avoid that by disabling SOPS when it
        // is not streaming a supported resolution.
        enableGameOptimizations = false;
        for (const NvDisplayMode &mode : m_Computer->displayModes) {
            if (mode.width == m_StreamConfig.width &&
                    mode.height == m_StreamConfig.height) {
                SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION,
                            "Found host supported resolution: %dx%d",
                            mode.width, mode.height);
                enableGameOptimizations = m_Preferences->gameOptimizations;
                break;
            }
        }
    }
    else {
        // Always send SOPS to Sunshine because we may repurpose the
        // option to control whether the display mode is adjusted
        enableGameOptimizations = m_Preferences->gameOptimizations;
    }

    QString rtspSessionUrl;

    try {
        NvHTTP http(m_Computer);
        http.startApp(m_Computer->currentGameId != 0 ? "resume" : "launch",
                      m_Computer->isNvidiaServerSoftware,
                      m_App.id, &m_StreamConfig,
                      enableGameOptimizations,
                      m_Preferences->playAudioOnHost,
                      m_InputHandler->getAttachedGamepadMask(),
                      !m_Preferences->multiController,
                      rtspSessionUrl);
    } catch (const GfeHttpResponseException& e) {
        emit displayLaunchError(tr("Host returned error: %1").arg(e.toQString()));
        return false;
    } catch (const QtNetworkReplyException& e) {
        emit displayLaunchError(e.toQString());
        return false;
    }
```
## Q2
How to parse the information returned by the above 2 interfaces and provide it to the function for establishing a streaming connection?
### Answer
You're asking about how Moonlight parses the responses from `/serverinfo` and `/launch` endpoints and uses that information to establish a streaming connection.

## Answer

### Parsing `/serverinfo` Response

The `/serverinfo` response is parsed to create/update an `NvComputer` object that stores host capabilities. moonlight-qt:754-782  The `NvHTTP::getServerInfo()` method returns an XML string that gets parsed to extract server properties like:<cite />

- Server codec mode support (`serverCodecModeSupport`)
- GFE version (`gfeVersion`)
- App version (`appVersion`)
- Display modes
- Current game ID

These properties are stored in the `NvComputer` object and later used during session validation and configuration.<cite />

### Parsing `/launch` Response and Establishing Connection

When starting a stream, `NvHTTP::startApp()` is called with the `STREAM_CONFIGURATION` structure containing all streaming parameters (resolution, FPS, bitrate, codec preferences, etc.). moonlight-qt:189-236  The method constructs a URL with query parameters including:<cite />

- Resolution and FPS (`mode` parameter)
- HDR settings
- Audio configuration
- Gamepad mask
- Remote input encryption keys

The response is parsed to extract the `rtspSessionUrl` using `getXmlString(response, "sessionUrl0")`. moonlight-qt:235-235 

### Providing Information to Connection Function

After receiving the `/launch` response, the parsed information is used to populate a `SERVER_INFORMATION` structure: moonlight-qt:1602-1624 

```cpp
SERVER_INFORMATION hostInfo;
hostInfo.address = hostnameStr.data();
hostInfo.serverInfoAppVersion = siAppVersion.data();
hostInfo.serverCodecModeSupport = m_Computer->serverCodecModeSupport;
hostInfo.serverInfoGfeVersion = siGfeVersion.data();
hostInfo.rtspSessionUrl = rtspSessionUrlStr.data();
```

This structure, along with the `STREAM_CONFIGURATION` and callback structures, is passed to `LiStartConnection()` to establish the actual streaming connection: moonlight-qt:1678-1685 

The `LiStartConnection()` function (from the moonlight-common-c library) uses:
- The RTSP session URL from `/launch` response to establish the RTSP control channel
- Server codec support from `/serverinfo` to negotiate video formats
- Stream configuration to set up video/audio decoders

### Validation Before Connection

Before calling `LiStartConnection()`, the session validates that the host supports the requested features by checking `m_Computer->serverCodecModeSupport` against the requested video formats. moonlight-qt:1117-1152  For example, it verifies YUV 4:4:4 support and adjusts the supported video formats list accordingly.<cite />

## Notes

The parsing happens in two stages: first during PC discovery (parsing `/serverinfo` into `NvComputer` properties), then during session start (parsing `/launch` response for RTSP URL). The `NvComputer` object acts as a bridge, storing server capabilities that are later referenced when configuring the `SERVER_INFORMATION` structure for `LiStartConnection()`. The actual XML parsing is handled by helper functions like `getXmlString()` in the `NvHTTP` class.

Wiki pages you might want to explore:
- [Settings View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.2)
- [Input Handling (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#4.7)
### Citations
**File:** app/backend/computermanager.cpp (L754-782)
```cpp
    QString fetchServerInfo(NvHTTP& http)
    {
        QString serverInfo;

        // Do nothing if we're quitting
        if (m_AboutToQuit) {
            return QString();
        }

        try {
            // There's a race condition between GameStream servers reporting presence over
            // mDNS and the HTTPS server being ready to respond to our queries. To work
            // around this issue, we will issue the request again after a few seconds if
            // we see a ServiceUnavailableError error.
            try {
                serverInfo = http.getServerInfo(NvHTTP::NVLL_VERBOSE);
            } catch (const QtNetworkReplyException& e) {
                if (e.getError() == QNetworkReply::ServiceUnavailableError) {
                    qWarning() << "Retrying request in 5 seconds after ServiceUnavailableError";
                    QThread::sleep(5);
                    serverInfo = http.getServerInfo(NvHTTP::NVLL_VERBOSE);
                    qInfo() << "Retry successful";
                }
                else {
                    // Rethrow other errors
                    throw e;
                }
            }
            return serverInfo;
```
**File:** app/backend/nvhttp.cpp (L189-236)
```cpp
void
NvHTTP::startApp(QString verb,
                 bool isGfe,
                 int appId,
                 PSTREAM_CONFIGURATION streamConfig,
                 bool sops,
                 bool localAudio,
                 int gamepadMask,
                 bool persistGameControllersOnDisconnect,
                 QString& rtspSessionUrl)
{
    int riKeyId;

    memcpy(&riKeyId, streamConfig->remoteInputAesIv, sizeof(riKeyId));
    riKeyId = qFromBigEndian(riKeyId);

    QString response =
            openConnectionToString(m_BaseUrlHttps,
                                   verb,
                                   "appid="+QString::number(appId)+
                                   "&mode="+QString::number(streamConfig->width)+"x"+
                                   QString::number(streamConfig->height)+"x"+
                                   // Using an FPS value over 60 causes SOPS to default to 720p60,
                                   // so force it to 0 to ensure the correct resolution is set. We
                                   // used to use 60 here but that locked the frame rate to 60 FPS
                                   // on GFE 3.20.3. We don't need this hack for Sunshine.
                                   QString::number((streamConfig->fps > 60 && isGfe) ? 0 : streamConfig->fps)+
                                   "&additionalStates=1&sops="+QString::number(sops ? 1 : 0)+
                                   "&rikey="+QByteArray(streamConfig->remoteInputAesKey, sizeof(streamConfig->remoteInputAesKey)).toHex()+
                                   "&rikeyid="+QString::number(riKeyId)+
                                   ((streamConfig->supportedVideoFormats & VIDEO_FORMAT_MASK_10BIT) ?
                                       "&hdrMode=1&clientHdrCapVersion=0&clientHdrCapSupportedFlagsInUint32=0&clientHdrCapMetaDataId=NV_STATIC_METADATA_TYPE_1&clientHdrCapDisplayData=0x0x0x0x0x0x0x0x0x0x0" :
                                        "")+
                                   "&localAudioPlayMode="+QString::number(localAudio ? 1 : 0)+
                                   "&surroundAudioInfo="+QString::number(SURROUNDAUDIOINFO_FROM_AUDIO_CONFIGURATION(streamConfig->audioConfiguration))+
                                   "&remoteControllersBitmap="+QString::number(gamepadMask)+
                                   "&gcmap="+QString::number(gamepadMask)+
                                   "&gcpersist="+QString::number(persistGameControllersOnDisconnect ? 1 : 0)+
                                   LiGetLaunchUrlQueryParameters(),
                                   LAUNCH_TIMEOUT_MS);

    qInfo() << "Launch response:" << response;

    // Throws if the request failed
    verifyResponseStatus(response);

    rtspSessionUrl = getXmlString(response, "sessionUrl0");
}
```
**File:** app/streaming/session.cpp (L1117-1152)
```cpp
    if (m_Preferences->enableYUV444) {
        if (!(m_Computer->serverCodecModeSupport & SCM_MASK_YUV444)) {
            emitLaunchWarning(tr("Your host PC doesn't support YUV 4:4:4 streaming."));
            m_SupportedVideoFormats.removeByMask(VIDEO_FORMAT_MASK_YUV444);
        }
        else {
            m_SupportedVideoFormats.removeByMask(~m_SupportedVideoFormats.maskByServerCodecModes(m_Computer->serverCodecModeSupport));

            if (!m_SupportedVideoFormats.isEmpty() &&
                !(m_SupportedVideoFormats.front() & VIDEO_FORMAT_MASK_YUV444)) {
                emitLaunchWarning(tr("Your host PC doesn't support YUV 4:4:4 streaming for selected video codec."));
            }
            else if (m_Preferences->videoDecoderSelection != StreamingPreferences::VDS_FORCE_SOFTWARE) {
                while (!m_SupportedVideoFormats.isEmpty() &&
                       (m_SupportedVideoFormats.front() & VIDEO_FORMAT_MASK_YUV444) &&
                       getDecoderAvailability(testWindow,
                                              m_Preferences->videoDecoderSelection,
                                              m_SupportedVideoFormats.front(),
                                              m_StreamConfig.width,
                                              m_StreamConfig.height,
                                              m_StreamConfig.fps) != DecoderAvailability::Hardware) {
                    if (m_Preferences->videoDecoderSelection == StreamingPreferences::VDS_FORCE_HARDWARE) {
                        m_SupportedVideoFormats.removeFirst();
                    }
                    else {
                        emitLaunchWarning(tr("Using software decoding due to your selection to force YUV 4:4:4 without GPU support. This may cause poor streaming performance."));
                        break;
                    }
                }
                if (!m_SupportedVideoFormats.isEmpty() &&
                    !(m_SupportedVideoFormats.front() & VIDEO_FORMAT_MASK_YUV444)) {
                    emitLaunchWarning(tr("This PC's GPU doesn't support YUV 4:4:4 decoding for selected video codec."));
                }
            }
        }
    }
```
**File:** app/streaming/session.cpp (L1602-1624)
```cpp
    QByteArray hostnameStr = m_Computer->activeAddress.address().toLatin1();
    QByteArray siAppVersion = m_Computer->appVersion.toLatin1();

    SERVER_INFORMATION hostInfo;
    hostInfo.address = hostnameStr.data();
    hostInfo.serverInfoAppVersion = siAppVersion.data();
    hostInfo.serverCodecModeSupport = m_Computer->serverCodecModeSupport;

    // Older GFE versions didn't have this field
    QByteArray siGfeVersion;
    if (!m_Computer->gfeVersion.isEmpty()) {
        siGfeVersion = m_Computer->gfeVersion.toLatin1();
    }
    if (!siGfeVersion.isEmpty()) {
        hostInfo.serverInfoGfeVersion = siGfeVersion.data();
    }

    // Older GFE and Sunshine versions didn't have this field
    QByteArray rtspSessionUrlStr;
    if (!rtspSessionUrl.isEmpty()) {
        rtspSessionUrlStr = rtspSessionUrl.toLatin1();
        hostInfo.rtspSessionUrl = rtspSessionUrlStr.data();
    }
```
**File:** app/streaming/session.cpp (L1678-1685)
```cpp
    int err = LiStartConnection(&hostInfo, &m_StreamConfig, &k_ConnCallbacks,
                                &m_VideoCallbacks, &m_AudioCallbacks,
                                NULL, 0, NULL, 0);
    if (err != 0) {
        // We already displayed an error dialog in the stage failure
        // listener.
        return false;
    }
```
## Q3
how to get "Remote input encryption keys"
### Answer
You're asking about how Moonlight generates the "Remote input encryption keys" that are sent to the host server during the `/launch` request.

## Answer

The remote input encryption keys (`rikey` and `rikeyid`) are randomly generated AES encryption keys used to secure input data sent from the client to the host during streaming. moonlight-qt:692-696 

### Key Generation

During session initialization in `Session::initialize()`, Moonlight generates these keys using OpenSSL's cryptographically secure random number generator:

```cpp
RAND_bytes(reinterpret_cast<unsigned char*>(m_StreamConfig.remoteInputAesKey),
           sizeof(m_StreamConfig.remoteInputAesKey));

// Only the first 4 bytes are populated in the RI key IV
RAND_bytes(reinterpret_cast<unsigned char*>(m_StreamConfig.remoteInputAesIv), 4);
``` moonlight-qt:692-696 

The `remoteInputAesKey` is a full AES key (16 bytes), while `remoteInputAesIv` only uses the first 4 bytes as an initialization vector. moonlight-qt:692-696 

### Sending Keys to Host

These generated keys are then sent to the host server when calling the `/launch` endpoint in `NvHTTP::startApp()`. moonlight-qt:200-218  The method:

1. Extracts the key ID from the IV by reading the first 4 bytes as a big-endian integer moonlight-qt:200-203 
2. Converts the AES key to hexadecimal format using `QByteArray(...).toHex()` moonlight-qt:217-217 
3. Includes both values as query parameters: `rikey=<hex_key>&rikeyid=<key_id>` moonlight-qt:217-218 

### Security Considerations

For security, these keys are automatically redacted from log files to prevent exposure. moonlight-qt:108-110  The logging system uses regex patterns to strip `rikey` and `rikeyid` values before writing to logs. moonlight-qt:88-88 

## Notes

The remote input encryption is part of Moonlight's security features to protect input data (keyboard, mouse, gamepad) transmitted during streaming. The keys are generated fresh for each streaming session and are stored in the `STREAM_CONFIGURATION` structure (`m_StreamConfig`) which is later passed to `LiStartConnection()` to establish the connection. moonlight-qt:1584-1593 

Wiki pages you might want to explore:
- [PC Discovery View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.1)
### Citations
**File:** app/streaming/session.cpp (L692-696)
```cpp
    RAND_bytes(reinterpret_cast<unsigned char*>(m_StreamConfig.remoteInputAesKey),
               sizeof(m_StreamConfig.remoteInputAesKey));

    // Only the first 4 bytes are populated in the RI key IV
    RAND_bytes(reinterpret_cast<unsigned char*>(m_StreamConfig.remoteInputAesIv), 4);
```
**File:** app/streaming/session.cpp (L1584-1593)
```cpp
    try {
        NvHTTP http(m_Computer);
        http.startApp(m_Computer->currentGameId != 0 ? "resume" : "launch",
                      m_Computer->isNvidiaServerSoftware,
                      m_App.id, &m_StreamConfig,
                      enableGameOptimizations,
                      m_Preferences->playAudioOnHost,
                      m_InputHandler->getAttachedGamepadMask(),
                      !m_Preferences->multiController,
                      rtspSessionUrl);
```
**File:** app/backend/nvhttp.cpp (L200-218)
```cpp
    int riKeyId;

    memcpy(&riKeyId, streamConfig->remoteInputAesIv, sizeof(riKeyId));
    riKeyId = qFromBigEndian(riKeyId);

    QString response =
            openConnectionToString(m_BaseUrlHttps,
                                   verb,
                                   "appid="+QString::number(appId)+
                                   "&mode="+QString::number(streamConfig->width)+"x"+
                                   QString::number(streamConfig->height)+"x"+
                                   // Using an FPS value over 60 causes SOPS to default to 720p60,
                                   // so force it to 0 to ensure the correct resolution is set. We
                                   // used to use 60 here but that locked the frame rate to 60 FPS
                                   // on GFE 3.20.3. We don't need this hack for Sunshine.
                                   QString::number((streamConfig->fps > 60 && isGfe) ? 0 : streamConfig->fps)+
                                   "&additionalStates=1&sops="+QString::number(sops ? 1 : 0)+
                                   "&rikey="+QByteArray(streamConfig->remoteInputAesKey, sizeof(streamConfig->remoteInputAesKey)).toHex()+
                                   "&rikeyid="+QString::number(riKeyId)+
```
**File:** app/main.cpp (L108-110)
```cpp
    // Strip session encryption keys and IVs from the logs
    message.replace(k_RikeyRegex, "&rikey=REDACTED");
    message.replace(k_RikeyIdRegex, "&rikeyid=REDACTED");
```
**File:** app/deploy/linux/com.moonlight_stream.Moonlight.appdata.xml (L88-88)
```text
					<li>Per-session keys (rikey and rikeyid values) are now automatically stripped from logs</li>
```
## Q4
<?xml version="1.0" encoding="utf-8"?>
<root status_code="200">
  <hostname>Html5syt</hostname>
  <appversion>7.1.431.-1</appversion>
<GfeVersion>3.23.0.74</GfeVersion>
  <uniqueid>F98186B1-DE02-2328-279E-0A461FBCEC47</uniqueid>
  <HttpsPort>47984</HttpsPort>
  <ExternalPort>47989</ExternalPort>
<MaxLumaPixelsHEVC>1869449984</MaxLumaPixelsHEVC>
  <mac>00:00:00:00:00:00</mac>
  <LocalIP>127.0.0.1</LocalIP>
  <ServerCodecModeSupport>257</ServerCodecModeSupport>
<PairStatus>0</PairStatus>
  <currentgame>1191261554</currentgame>
  <state>SUNSHINE_SERVER_BUSY</state>
</root>
This is a response from a serverinfo, please tell me which parameters are used to establish the connection in it?
### Answer
You're asking which parameters from the `/serverinfo` XML response are used when establishing a streaming connection in Moonlight.

## Answer

From the `/serverinfo` response you provided, the following parameters are used to establish the streaming connection:

### Parameters Used in Connection Establishment

**`ServerCodecModeSupport` (value: 257)** - This is stored in the `NvComputer` object and later passed to `LiStartConnection()` via the `SERVER_INFORMATION` structure. moonlight-qt:1608-1608  It indicates which video codecs and formats the host supports, and is used to negotiate the video format during connection setup. moonlight-qt:1608-1608 

**`appversion` (value: 7.1.431.-1)** - This is stored as `m_Computer->appVersion` and passed to `LiStartConnection()` as `hostInfo.serverInfoAppVersion`. moonlight-qt:1603-1607  The connection library uses this to determine host capabilities and compatibility. moonlight-qt:1603-1607 

**`GfeVersion` (value: 3.23.0.74)** - This is stored as `m_Computer->gfeVersion` and passed to `LiStartConnection()` as `hostInfo.serverInfoGfeVersion`. moonlight-qt:1611-1617  It's used to determine if the host is running GFE or Sunshine and adjust behavior accordingly. moonlight-qt:1560-1580 

**`LocalIP` (value: 127.0.0.1)** - The host's address is used to construct the base URLs for HTTP/HTTPS communication and is passed to `LiStartConnection()` as `hostInfo.address`. moonlight-qt:1602-1606 

**`HttpsPort` (value: 47984)** - Used to construct the HTTPS base URL for secure communication with the host, including the `/launch` endpoint call. moonlight-qt:173-177 

### Parameters NOT Directly Used in Connection

The following parameters are informational but not directly passed to the connection function:

- `hostname`, `uniqueid`, `ExternalPort`, `MaxLumaPixelsHEVC`, `mac` - These are stored in the `NvComputer` object for display and management purposes but aren't passed to `LiStartConnection()`.<cite />
- `PairStatus` - Used to determine if pairing is needed before streaming, but not used during connection establishment.<cite />
- `currentgame` and `state` - Used to determine if the host is already streaming, which affects whether to call `/launch` or `/resume`. moonlight-qt:1586-1586 

## Notes

The `state` value "SUNSHINE_SERVER_BUSY" indicates the host is currently streaming (as confirmed by the non-zero `currentgame` value). moonlight-qt:112-116  In this case, Moonlight would call `/resume` instead of `/launch` if you're trying to connect to the same game. moonlight-qt:1586-1586  The `ServerCodecModeSupport` value of 257 indicates support for H.264 (bit 0) and H.265/HEVC (bit 8).<cite />

Wiki pages you might want to explore:
- [PC Discovery View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.1)
### Citations
**File:** app/streaming/session.cpp (L1560-1580)
```cpp
    if (m_Computer->isNvidiaServerSoftware) {
        // GFE will set all settings to 720p60 if it doesn't recognize
        // the chosen resolution. Avoid that by disabling SOPS when it
        // is not streaming a supported resolution.
        enableGameOptimizations = false;
        for (const NvDisplayMode &mode : m_Computer->displayModes) {
            if (mode.width == m_StreamConfig.width &&
                    mode.height == m_StreamConfig.height) {
                SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION,
                            "Found host supported resolution: %dx%d",
                            mode.width, mode.height);
                enableGameOptimizations = m_Preferences->gameOptimizations;
                break;
            }
        }
    }
    else {
        // Always send SOPS to Sunshine because we may repurpose the
        // option to control whether the display mode is adjusted
        enableGameOptimizations = m_Preferences->gameOptimizations;
    }
```
**File:** app/streaming/session.cpp (L1586-1586)
```cpp
        http.startApp(m_Computer->currentGameId != 0 ? "resume" : "launch",
```
**File:** app/streaming/session.cpp (L1602-1607)
```cpp
    QByteArray hostnameStr = m_Computer->activeAddress.address().toLatin1();
    QByteArray siAppVersion = m_Computer->appVersion.toLatin1();

    SERVER_INFORMATION hostInfo;
    hostInfo.address = hostnameStr.data();
    hostInfo.serverInfoAppVersion = siAppVersion.data();
```
**File:** app/streaming/session.cpp (L1608-1608)
```cpp
    hostInfo.serverCodecModeSupport = m_Computer->serverCodecModeSupport;
```
**File:** app/streaming/session.cpp (L1611-1617)
```cpp
    QByteArray siGfeVersion;
    if (!m_Computer->gfeVersion.isEmpty()) {
        siGfeVersion = m_Computer->gfeVersion.toLatin1();
    }
    if (!siGfeVersion.isEmpty()) {
        hostInfo.serverInfoGfeVersion = siGfeVersion.data();
    }
```
**File:** app/backend/nvhttp.cpp (L112-116)
```cpp
    QString serverState = getXmlString(serverInfo, "state");
    if (serverState != nullptr && serverState.endsWith("_SERVER_BUSY"))
    {
        return getXmlString(serverInfo, "currentgame").toInt();
    }
```
**File:** app/backend/nvhttp.cpp (L173-177)
```cpp
        uint16_t httpsPort = getXmlString(serverInfo, "HttpsPort").toUShort();
        if (httpsPort == 0) {
            httpsPort = DEFAULT_HTTPS_PORT;
        }
        setHttpsPort(httpsPort);
```
## Q5
When I call the /launch interface, the server requires me to provide a client certificate. How can I obtain this certificate?
### Answer
Moonlight obtains and provides client certificates through a multi-step process involving certificate generation, pairing, and SSL configuration:

## Client Certificate Generation

When Moonlight first launches, the `IdentityManager` class automatically generates a self-signed 2048-bit RSA certificate and private key pair if none exist. moonlight-qt:29-110 

These credentials are stored persistently in QSettings and cached in memory for reuse. moonlight-qt:112-139 

## Attaching Certificates to Requests

For every HTTPS request (including `/launch`), Moonlight attaches the client certificate through the `IdentityManager::getSslConfig()` method, which returns a `QSslConfiguration` containing both the client certificate and private key. moonlight-qt:184-191 

This SSL configuration is applied to all network requests in the `openConnection` method via `request.setSslConfiguration()`. moonlight-qt:486-489 

## The `/launch` Interface Specifically

When the `startApp` method is called to launch a game, it makes an HTTPS request to the `/launch` endpoint using the base HTTPS URL. moonlight-qt:205-228 

This request goes through `openConnection`, which automatically includes the client certificate for mutual TLS authentication with the host server.

## Pairing Process for Mutual Trust

Before the client certificate can be used for authentication, a pairing process must occur. During pairing, the client sends its certificate to the server and receives the server's certificate in return. moonlight-qt:217-248 

The server certificate is then pinned and stored in the `NvComputer` object for future SSL validation. moonlight-qt:419-439 

## Certificate Validation

If there's an SSL handshake failure or certificate mismatch (error 401), Moonlight falls back to HTTP and can re-initiate pairing to obtain updated certificates. moonlight-qt:143-160 

## Notes

- The client certificate uses a common name of "NVIDIA GameStream Client" moonlight-qt:70-74 
- The certificate has a 20-year validity period moonlight-qt:51-66 
- The `/launch` endpoint uses a 120-second timeout compared to the standard 5-second timeout for other requests moonlight-qt:15-19 
- Certificate pinning prevents man-in-the-middle attacks by ensuring SSL errors are only ignored if they match the previously paired server certificate moonlight-qt:429-434
### Citations
**File:** app/backend/identitymanager.cpp (L29-110)
```cpp
void IdentityManager::createCredentials(QSettings& settings)
{
    X509* cert = X509_new();
    THROW_BAD_ALLOC_IF_NULL(cert);

    EVP_PKEY_CTX* ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_RSA, NULL);
    THROW_BAD_ALLOC_IF_NULL(ctx);

    EVP_PKEY_keygen_init(ctx);
    EVP_PKEY_CTX_set_rsa_keygen_bits(ctx, 2048);

    // pk must be initialized on input
    EVP_PKEY* pk = NULL;
    EVP_PKEY_keygen(ctx, &pk);

    EVP_PKEY_CTX_free(ctx);
    THROW_BAD_ALLOC_IF_NULL(pk);

    X509_set_version(cert, 2);
    ASN1_INTEGER_set(X509_get_serialNumber(cert), 0);
#if OPENSSL_VERSION_NUMBER < 0x10100000L
    X509_gmtime_adj(X509_get_notBefore(cert), 0);
    X509_gmtime_adj(X509_get_notAfter(cert), 60 * 60 * 24 * 365 * 20); // 20 yrs
#else
    ASN1_TIME* before = ASN1_STRING_dup(X509_get0_notBefore(cert));
    THROW_BAD_ALLOC_IF_NULL(before);
    ASN1_TIME* after = ASN1_STRING_dup(X509_get0_notAfter(cert));
    THROW_BAD_ALLOC_IF_NULL(after);

    X509_gmtime_adj(before, 0);
    X509_gmtime_adj(after, 60 * 60 * 24 * 365 * 20); // 20 yrs

    X509_set1_notBefore(cert, before);
    X509_set1_notAfter(cert, after);

    ASN1_STRING_free(before);
    ASN1_STRING_free(after);
#endif

    X509_set_pubkey(cert, pk);

    X509_NAME* name = X509_get_subject_name(cert);
    X509_NAME_add_entry_by_txt(name, "CN", MBSTRING_ASC,
                               reinterpret_cast<unsigned char *>(const_cast<char*>("NVIDIA GameStream Client")),
                               -1, -1, 0);
    X509_set_issuer_name(cert, name);

    X509_sign(cert, pk, EVP_sha256());

    BIO* biokey = BIO_new(BIO_s_mem());
    THROW_BAD_ALLOC_IF_NULL(biokey);
    PEM_write_bio_PrivateKey(biokey, pk, NULL, NULL, 0, NULL, NULL);

    BIO* biocert = BIO_new(BIO_s_mem());
    THROW_BAD_ALLOC_IF_NULL(biocert);
    PEM_write_bio_X509(biocert, cert);

    BUF_MEM* mem;
    BIO_get_mem_ptr(biokey, &mem);
    m_CachedPrivateKey = QByteArray(mem->data, (int)mem->length);

    BIO_get_mem_ptr(biocert, &mem);
    m_CachedPemCert = QByteArray(mem->data, (int)mem->length);

    X509_free(cert);
    EVP_PKEY_free(pk);
    BIO_free(biokey);
    BIO_free(biocert);

    // Check that the new keypair is valid before persisting it
    if (getSslCertificate().isNull()) {
        qFatal("Newly generated certificate is unreadable");
    }
    if (getSslKey().isNull()) {
        qFatal("Newly generated private key is unreadable");
    }

    settings.setValue(SER_CERT, m_CachedPemCert);
    settings.setValue(SER_KEY, m_CachedPrivateKey);

    qInfo() << "Wrote new identity credentials to settings";
}
```
**File:** app/backend/identitymanager.cpp (L112-139)
```cpp
IdentityManager::IdentityManager()
{
    QSettings settings;

    m_CachedPemCert = settings.value(SER_CERT).toByteArray();
    m_CachedPrivateKey = settings.value(SER_KEY).toByteArray();

    if (m_CachedPemCert.isEmpty() || m_CachedPrivateKey.isEmpty()) {
        qInfo() << "No existing credentials found";
        createCredentials(settings);
    }
    else if (getSslCertificate().isNull()) {
        qWarning() << "Certificate is unreadable";
        createCredentials(settings);
    }
    else if (getSslKey().isNull()) {
        qWarning() << "Private key is unreadable";
        createCredentials(settings);
    }

    // We should have valid credentials now. If not, we're screwed
    if (getSslCertificate().isNull()) {
        qFatal("Certificate is unreadable");
    }
    if (getSslKey().isNull()) {
        qFatal("Private key is unreadable");
    }
}
```
**File:** app/backend/identitymanager.cpp (L184-191)
```cpp
QSslConfiguration
IdentityManager::getSslConfig()
{
    QSslConfiguration sslConfig(QSslConfiguration::defaultConfiguration());
    sslConfig.setLocalCertificate(getSslCertificate());
    sslConfig.setPrivateKey(getSslKey());
    return sslConfig;
}
```
**File:** app/backend/nvhttp.cpp (L15-19)
```cpp
#define FAST_FAIL_TIMEOUT_MS 2000
#define REQUEST_TIMEOUT_MS 5000
#define LAUNCH_TIMEOUT_MS 120000
#define RESUME_TIMEOUT_MS 30000
#define QUIT_TIMEOUT_MS 30000
```
**File:** app/backend/nvhttp.cpp (L143-160)
```cpp
        catch (const GfeHttpResponseException& e)
        {
            if (e.getStatusCode() == 401)
            {
                // Certificate validation error, fallback to HTTP
                serverInfo = openConnectionToString(m_BaseUrlHttp,
                                                    "serverinfo",
                                                    nullptr,
                                                    fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                                    logLevel);
                verifyResponseStatus(serverInfo);
            }
            else
            {
                // Rethrow real errors
                throw e;
            }
        }
```
**File:** app/backend/nvhttp.cpp (L205-228)
```cpp
    QString response =
            openConnectionToString(m_BaseUrlHttps,
                                   verb,
                                   "appid="+QString::number(appId)+
                                   "&mode="+QString::number(streamConfig->width)+"x"+
                                   QString::number(streamConfig->height)+"x"+
                                   // Using an FPS value over 60 causes SOPS to default to 720p60,
                                   // so force it to 0 to ensure the correct resolution is set. We
                                   // used to use 60 here but that locked the frame rate to 60 FPS
                                   // on GFE 3.20.3. We don't need this hack for Sunshine.
                                   QString::number((streamConfig->fps > 60 && isGfe) ? 0 : streamConfig->fps)+
                                   "&additionalStates=1&sops="+QString::number(sops ? 1 : 0)+
                                   "&rikey="+QByteArray(streamConfig->remoteInputAesKey, sizeof(streamConfig->remoteInputAesKey)).toHex()+
                                   "&rikeyid="+QString::number(riKeyId)+
                                   ((streamConfig->supportedVideoFormats & VIDEO_FORMAT_MASK_10BIT) ?
                                       "&hdrMode=1&clientHdrCapVersion=0&clientHdrCapSupportedFlagsInUint32=0&clientHdrCapMetaDataId=NV_STATIC_METADATA_TYPE_1&clientHdrCapDisplayData=0x0x0x0x0x0x0x0x0x0x0" :
                                        "")+
                                   "&localAudioPlayMode="+QString::number(localAudio ? 1 : 0)+
                                   "&surroundAudioInfo="+QString::number(SURROUNDAUDIOINFO_FROM_AUDIO_CONFIGURATION(streamConfig->audioConfiguration))+
                                   "&remoteControllersBitmap="+QString::number(gamepadMask)+
                                   "&gcmap="+QString::number(gamepadMask)+
                                   "&gcpersist="+QString::number(persistGameControllersOnDisconnect ? 1 : 0)+
                                   LiGetLaunchUrlQueryParameters(),
                                   LAUNCH_TIMEOUT_MS);
```
**File:** app/backend/nvhttp.cpp (L419-439)
```cpp
void NvHTTP::handleSslErrors(QNetworkReply* reply, const QList<QSslError>& errors)
{
    bool ignoreErrors = true;

    if (m_ServerCert.isNull()) {
        // We should never make an HTTPS request without a cert
        Q_ASSERT(!m_ServerCert.isNull());
        return;
    }

    for (const QSslError& error : errors) {
        if (m_ServerCert != error.certificate()) {
            ignoreErrors = false;
            break;
        }
    }

    if (ignoreErrors) {
        reply->ignoreSslErrors(errors);
    }
}
```
**File:** app/backend/nvhttp.cpp (L486-489)
```cpp
    QNetworkRequest request(url);

    // Add our client certificate
    request.setSslConfiguration(IdentityManager::get()->getSslConfig());
```
**File:** app/backend/nvpairingmanager.cpp (L217-248)
```cpp
    QString getCert = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&phrase=getservercert&salt=" +
                                                    salt.toHex() + "&clientcert=" + IdentityManager::get()->getCertificate().toHex(),
                                                    0);
    NvHTTP::verifyResponseStatus(getCert);
    if (NvHTTP::getXmlString(getCert, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #1";
        return PairState::FAILED;
    }

    QByteArray serverCertStr = NvHTTP::getXmlStringFromHex(getCert, "plaincert");
    if (serverCertStr == nullptr)
    {
        qCritical() << "Server likely already pairing";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::ALREADY_IN_PROGRESS;
    }

    QSslCertificate unverifiedServerCert = QSslCertificate(serverCertStr);
    if (unverifiedServerCert.isNull()) {
        Q_ASSERT(!unverifiedServerCert.isNull());

        qCritical() << "Failed to parse plaincert";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    // Pin this cert for TLS until pairing is complete. If successful, we will propagate
    // the cert into the NvComputer object and persist it.
    m_Http.setServerCert(unverifiedServerCert);
```
## Q6
How to pair up computer?
### Answer
The pairing process in Moonlight uses a 5-phase handshake protocol to securely exchange certificates between the client and server. Here's how it works:

## Client Certificate Generation and Storage

The client certificate is a self-signed X.509 certificate that is generated when Moonlight first runs. It uses a 2048-bit RSA key pair with SHA-256 signature and has a 20-year validity period. moonlight-qt:29-110 

The certificate and private key are stored in QSettings and cached in memory for subsequent use. moonlight-qt:112-139 

## The 5-Phase Pairing Process

The pairing process is implemented in the `NvPairingManager::pair()` method: moonlight-qt:191-354 

### Phase 1: Certificate Exchange

The client sends its certificate to the server as a hex-encoded string in the `clientcert` parameter of an HTTP request. At the same time, it receives the server's certificate in the response: moonlight-qt:217-227 

The server returns its certificate in the `plaincert` field of the XML response: moonlight-qt:229-244 

### Phase 2-5: Challenge-Response Authentication

Once the server certificate is received, it is immediately pinned to the HTTP client for all subsequent HTTPS requests: moonlight-qt:246-248 

The remaining phases involve encrypted challenge-response exchanges and signature verification to authenticate both parties and validate the PIN.

## Certificate Pinning

The `setServerCert()` method stores the server certificate for use in HTTPS connections: moonlight-qt:43-46 

During HTTPS connections, the `handleSslErrors()` method verifies that the server certificate matches the pinned certificate, preventing man-in-the-middle attacks: moonlight-qt:419-439 

## Persisting the Server Certificate

After successful pairing, the server certificate is stored in the `NvComputer` object: moonlight-qt:113-113 

The certificate is then persisted to settings by calling `saveHost()`: moonlight-qt:599-603 

## Notes

The pairing process uses AES-128-ECB encryption for challenge exchanges, with the encryption key derived from a salted PIN hash (SHA-256 for Gen 7+ servers, SHA-1 for older versions). The client certificate is sent as plain hex-encoded PEM data in Phase 1, while the server certificate is also returned as hex-encoded PEM. This certificate exchange happens over HTTP initially, but all subsequent pairing phases use HTTPS with the newly pinned certificate to ensure secure communication.
### Citations
**File:** app/backend/identitymanager.cpp (L29-110)
```cpp
void IdentityManager::createCredentials(QSettings& settings)
{
    X509* cert = X509_new();
    THROW_BAD_ALLOC_IF_NULL(cert);

    EVP_PKEY_CTX* ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_RSA, NULL);
    THROW_BAD_ALLOC_IF_NULL(ctx);

    EVP_PKEY_keygen_init(ctx);
    EVP_PKEY_CTX_set_rsa_keygen_bits(ctx, 2048);

    // pk must be initialized on input
    EVP_PKEY* pk = NULL;
    EVP_PKEY_keygen(ctx, &pk);

    EVP_PKEY_CTX_free(ctx);
    THROW_BAD_ALLOC_IF_NULL(pk);

    X509_set_version(cert, 2);
    ASN1_INTEGER_set(X509_get_serialNumber(cert), 0);
#if OPENSSL_VERSION_NUMBER < 0x10100000L
    X509_gmtime_adj(X509_get_notBefore(cert), 0);
    X509_gmtime_adj(X509_get_notAfter(cert), 60 * 60 * 24 * 365 * 20); // 20 yrs
#else
    ASN1_TIME* before = ASN1_STRING_dup(X509_get0_notBefore(cert));
    THROW_BAD_ALLOC_IF_NULL(before);
    ASN1_TIME* after = ASN1_STRING_dup(X509_get0_notAfter(cert));
    THROW_BAD_ALLOC_IF_NULL(after);

    X509_gmtime_adj(before, 0);
    X509_gmtime_adj(after, 60 * 60 * 24 * 365 * 20); // 20 yrs

    X509_set1_notBefore(cert, before);
    X509_set1_notAfter(cert, after);

    ASN1_STRING_free(before);
    ASN1_STRING_free(after);
#endif

    X509_set_pubkey(cert, pk);

    X509_NAME* name = X509_get_subject_name(cert);
    X509_NAME_add_entry_by_txt(name, "CN", MBSTRING_ASC,
                               reinterpret_cast<unsigned char *>(const_cast<char*>("NVIDIA GameStream Client")),
                               -1, -1, 0);
    X509_set_issuer_name(cert, name);

    X509_sign(cert, pk, EVP_sha256());

    BIO* biokey = BIO_new(BIO_s_mem());
    THROW_BAD_ALLOC_IF_NULL(biokey);
    PEM_write_bio_PrivateKey(biokey, pk, NULL, NULL, 0, NULL, NULL);

    BIO* biocert = BIO_new(BIO_s_mem());
    THROW_BAD_ALLOC_IF_NULL(biocert);
    PEM_write_bio_X509(biocert, cert);

    BUF_MEM* mem;
    BIO_get_mem_ptr(biokey, &mem);
    m_CachedPrivateKey = QByteArray(mem->data, (int)mem->length);

    BIO_get_mem_ptr(biocert, &mem);
    m_CachedPemCert = QByteArray(mem->data, (int)mem->length);

    X509_free(cert);
    EVP_PKEY_free(pk);
    BIO_free(biokey);
    BIO_free(biocert);

    // Check that the new keypair is valid before persisting it
    if (getSslCertificate().isNull()) {
        qFatal("Newly generated certificate is unreadable");
    }
    if (getSslKey().isNull()) {
        qFatal("Newly generated private key is unreadable");
    }

    settings.setValue(SER_CERT, m_CachedPemCert);
    settings.setValue(SER_KEY, m_CachedPrivateKey);

    qInfo() << "Wrote new identity credentials to settings";
}
```
**File:** app/backend/identitymanager.cpp (L112-139)
```cpp
IdentityManager::IdentityManager()
{
    QSettings settings;

    m_CachedPemCert = settings.value(SER_CERT).toByteArray();
    m_CachedPrivateKey = settings.value(SER_KEY).toByteArray();

    if (m_CachedPemCert.isEmpty() || m_CachedPrivateKey.isEmpty()) {
        qInfo() << "No existing credentials found";
        createCredentials(settings);
    }
    else if (getSslCertificate().isNull()) {
        qWarning() << "Certificate is unreadable";
        createCredentials(settings);
    }
    else if (getSslKey().isNull()) {
        qWarning() << "Private key is unreadable";
        createCredentials(settings);
    }

    // We should have valid credentials now. If not, we're screwed
    if (getSslCertificate().isNull()) {
        qFatal("Certificate is unreadable");
    }
    if (getSslKey().isNull()) {
        qFatal("Private key is unreadable");
    }
}
```
**File:** app/backend/nvpairingmanager.cpp (L191-354)
```cpp
NvPairingManager::pair(QString appVersion, QString pin, QSslCertificate& serverCert)
{
    int serverMajorVersion = NvHTTP::parseQuad(appVersion).at(0);
    qInfo() << "Pairing with server generation:" << serverMajorVersion;

    QCryptographicHash::Algorithm hashAlgo;
    int hashLength;
    if (serverMajorVersion >= 7)
    {
        // Gen 7+ uses SHA-256 hashing
        hashAlgo = QCryptographicHash::Sha256;
        hashLength = 32;
    }
    else
    {
        // Prior to Gen 7 uses SHA-1 hashing
        hashAlgo = QCryptographicHash::Sha1;
        hashLength = 20;
    }

    QByteArray salt = generateRandomBytes(16);
    QByteArray saltedPin = saltPin(salt, pin);

    QByteArray aesKey = QCryptographicHash::hash(saltedPin, hashAlgo).constData();
    aesKey.truncate(16);

    QString getCert = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&phrase=getservercert&salt=" +
                                                    salt.toHex() + "&clientcert=" + IdentityManager::get()->getCertificate().toHex(),
                                                    0);
    NvHTTP::verifyResponseStatus(getCert);
    if (NvHTTP::getXmlString(getCert, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #1";
        return PairState::FAILED;
    }

    QByteArray serverCertStr = NvHTTP::getXmlStringFromHex(getCert, "plaincert");
    if (serverCertStr == nullptr)
    {
        qCritical() << "Server likely already pairing";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::ALREADY_IN_PROGRESS;
    }

    QSslCertificate unverifiedServerCert = QSslCertificate(serverCertStr);
    if (unverifiedServerCert.isNull()) {
        Q_ASSERT(!unverifiedServerCert.isNull());

        qCritical() << "Failed to parse plaincert";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    // Pin this cert for TLS until pairing is complete. If successful, we will propagate
    // the cert into the NvComputer object and persist it.
    m_Http.setServerCert(unverifiedServerCert);

    QByteArray randomChallenge = generateRandomBytes(16);
    QByteArray encryptedChallenge = encrypt(randomChallenge, aesKey);
    QString challengeXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                         "pair",
                                                         "devicename=roth&updateState=1&clientchallenge=" +
                                                         encryptedChallenge.toHex(),
                                                         REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(challengeXml);
    if (NvHTTP::getXmlString(challengeXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #2";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray challengeResponseData = decrypt(m_Http.getXmlStringFromHex(challengeXml, "challengeresponse"), aesKey);
    QByteArray clientSecretData = generateRandomBytes(16);
    QByteArray challengeResponse;
    QByteArray serverResponse(challengeResponseData.data(), hashLength);

#if (OPENSSL_VERSION_NUMBER < 0x10002000L)
    ASN1_BIT_STRING *asnSignature = m_Cert->signature;
#elif (OPENSSL_VERSION_NUMBER < 0x10100000L)
    ASN1_BIT_STRING *asnSignature;
    X509_get0_signature(&asnSignature, NULL, m_Cert);
#else
    const ASN1_BIT_STRING *asnSignature;
    X509_get0_signature(&asnSignature, NULL, m_Cert);
#endif

    challengeResponse.append(challengeResponseData.data() + hashLength, 16);
    challengeResponse.append(reinterpret_cast<char*>(asnSignature->data), asnSignature->length);
    challengeResponse.append(clientSecretData);

    QByteArray paddedHash = QCryptographicHash::hash(challengeResponse, hashAlgo);
    paddedHash.resize(32);
    QByteArray encryptedChallengeResponseHash = encrypt(paddedHash, aesKey);
    QString respXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&serverchallengeresp=" +
                                                    encryptedChallengeResponseHash.toHex(),
                                                    REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(respXml);
    if (NvHTTP::getXmlString(respXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #3";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray pairingSecret = NvHTTP::getXmlStringFromHex(respXml, "pairingsecret");
    QByteArray serverSecret = pairingSecret.left(16);
    QByteArray serverSignature = pairingSecret.mid(16);

    if (!verifySignature(serverSecret,
                         serverSignature,
                         serverCertStr))
    {
        qCritical() << "MITM detected";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray expectedResponseData;
    expectedResponseData.append(randomChallenge);
    expectedResponseData.append(getSignatureFromPemCert(serverCertStr));
    expectedResponseData.append(serverSecret);
    if (QCryptographicHash::hash(expectedResponseData, hashAlgo) != serverResponse)
    {
        qCritical() << "Incorrect PIN";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::PIN_WRONG;
    }

    QByteArray clientPairingSecret;
    clientPairingSecret.append(clientSecretData);
    clientPairingSecret.append(signMessage(clientSecretData));

    QString secretRespXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                          "pair",
                                                          "devicename=roth&updateState=1&clientpairingsecret=" +
                                                          clientPairingSecret.toHex(),
                                                          REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(secretRespXml);
    if (NvHTTP::getXmlString(secretRespXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #4";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QString pairChallengeXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttps,
                                                             "pair",
                                                             "devicename=roth&updateState=1&phrase=pairchallenge",
                                                             REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(pairChallengeXml);
    if (NvHTTP::getXmlString(pairChallengeXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #5";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    serverCert = std::move(unverifiedServerCert);
    return PairState::PAIRED;
```
**File:** app/backend/nvhttp.cpp (L43-46)
```cpp
void NvHTTP::setServerCert(QSslCertificate serverCert)
{
    m_ServerCert = serverCert;
}
```
**File:** app/backend/nvhttp.cpp (L419-439)
```cpp
void NvHTTP::handleSslErrors(QNetworkReply* reply, const QList<QSslError>& errors)
{
    bool ignoreErrors = true;

    if (m_ServerCert.isNull()) {
        // We should never make an HTTPS request without a cert
        Q_ASSERT(!m_ServerCert.isNull());
        return;
    }

    for (const QSslError& error : errors) {
        if (m_ServerCert != error.certificate()) {
            ignoreErrors = false;
            break;
        }
    }

    if (ignoreErrors) {
        reply->ignoreSslErrors(errors);
    }
}
```
**File:** app/backend/nvcomputer.h (L113-113)
```text
    QSslCertificate serverCert;
```
**File:** app/backend/computermanager.cpp (L599-603)
```cpp
           case NvPairingManager::PairState::PAIRED:
               // Persist the newly pinned server certificate for this host
               m_ComputerManager->saveHost(m_Computer);

               emit pairingCompleted(m_Computer, nullptr);
```
## Q7
When the client has launched/started the game and begun streaming before disconnecting, how does the client recover the connection?
### Answer
You're asking about how Moonlight handles connection recovery when a streaming session disconnects after it has already started.

## Answer

When a streaming session disconnects, Moonlight determines whether to call `/launch` or `/resume` based on the `currentgame` value from the host's `/serverinfo` response. moonlight-qt:1586-1586 

### Resume vs Launch Decision

In `Session::startConnectionAsync()`, the code checks if `m_Computer->currentgame` is non-zero (indicating a game is already running on the host): moonlight-qt:1556-1557 

If the game is already running, it calls `NvHTTP::startApp()` with the `"resume"` parameter instead of `"launch"`: moonlight-qt:1586-1593 

```cpp
http.startApp(m_Computer->currentgame != 0 ? "resume" : "launch",
              m_Computer->isNvidiaServerSoftware,
              m_App.id, &m_StreamConfig,
              enableGameOptimizations,
              m_Preferences->playAudioOnHost,
              m_InputHandler->getAttachedGamepadMask(),
              !m_Preferences->multiController,
              rtspSessionUrl);
```

### How Resume Works

The `/resume` endpoint tells the host to reconnect to an existing game session rather than starting a new one.<cite /> This preserves the game state and allows the client to rejoin the same streaming session.<cite />

The same connection establishment process follows after calling `/resume` - the RTSP session URL is obtained from the response and passed to `LiStartConnection()` to establish the streaming connection. moonlight-qt:1678-1680 

### State Detection

The host's state is tracked through periodic `/serverinfo` polling, which updates the `currentgame` field in the `NvComputer` object.<cite /> When the state shows `SUNSHINE_SERVER_BUSY` (as in your earlier example) with a non-zero `currentgame` value, Moonlight knows a game is already running and will use resume instead of launch.<cite />

## Notes

The resume functionality allows seamless reconnection to an existing game session without restarting the game on the host. This is particularly useful for temporary network interruptions or when the client application crashes but the host game continues running. The same certificate authentication and connection establishment process is used for both launch and resume operations.

Wiki pages you might want to explore:
- [User Interface System (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2)
- [Streaming Core (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#4)
### Citations
**File:** app/streaming/session.cpp (L1556-1557)
```cpp
    Q_ASSERT(m_Computer->currentGameId == 0 ||
             m_Computer->currentGameId == m_App.id);
```
**File:** app/streaming/session.cpp (L1586-1593)
```cpp
        http.startApp(m_Computer->currentGameId != 0 ? "resume" : "launch",
                      m_Computer->isNvidiaServerSoftware,
                      m_App.id, &m_StreamConfig,
                      enableGameOptimizations,
                      m_Preferences->playAudioOnHost,
                      m_InputHandler->getAttachedGamepadMask(),
                      !m_Preferences->multiController,
                      rtspSessionUrl);
```
**File:** app/streaming/session.cpp (L1678-1680)
```cpp
    int err = LiStartConnection(&hostInfo, &m_StreamConfig, &k_ConnCallbacks,
                                &m_VideoCallbacks, &m_AudioCallbacks,
                                NULL, 0, NULL, 0);
```
## Q8
How does the client terminate the connection?
### Answer
You're asking about how Moonlight terminates a streaming connection when the user wants to disconnect.

## Answer

Moonlight provides multiple ways to terminate a streaming connection:

### User-Initiated Disconnection

Users can disconnect from an active streaming session using keyboard shortcuts or gamepad button combinations. The UI displays a tip showing these options: **Ctrl+Alt+Shift+Q** for keyboard or **Start+Select+L1+R1** for gamepad. moonlight-qt:167-168 

### Connection Termination Flow

When a connection terminates, the `Session::clConnectionTerminated()` callback is invoked with an error code. moonlight-qt:98-155  This callback:

1. **Performs port testing** to diagnose connectivity issues if the termination was unexpected moonlight-qt:100-101 

2. **Determines if termination was graceful** - If the error code is `ML_ERROR_GRACEFUL_TERMINATION`, no error dialog is shown moonlight-qt:105-106 

3. **Displays error messages** for unexpected terminations (network issues, video encoding errors, etc.) moonlight-qt:108-144 

4. **Pushes a quit event** to the SDL event loop to exit the streaming session moonlight-qt:150-154 

### UI Cleanup After Termination

After the session ends, the `StreamSegue::sessionFinished()` method handles cleanup: moonlight-qt:73-108 

1. **Re-enables gamepad navigation** for the UI moonlight-qt:79-80 

2. **Pops the stream view** from the navigation stack to return to the previous screen moonlight-qt:93-94 

3. **Shows the main window** again moonlight-qt:96-97 

4. **Displays any error dialogs** if the termination was unexpected moonlight-qt:103-106 

The session object is then garbage collected to free resources. moonlight-qt:110-116 

### Quitting Running Apps

Moonlight can also terminate a running game on the host without streaming it. The `ComputerManager::quitRunningApp()` method creates a `PendingQuitTask` that sends a quit request to the host server. moonlight-qt:675-682  This is used when users want to stop a game remotely without connecting to it.

## Notes

The termination process distinguishes between graceful disconnections (user-initiated) and unexpected terminations (network errors, encoding failures). For unexpected terminations, Moonlight performs network diagnostics and displays helpful error messages to guide troubleshooting. The same cleanup process applies whether the user disconnects manually or the connection fails unexpectedly.

Wiki pages you might want to explore:
- [User Interface System (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2)
- [PC Discovery View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.1)
### Citations
**File:** app/gui/StreamSegue.qml (L73-108)
```text
    function sessionFinished(portTestResult)
    {
        if (portTestResult !== 0 && portTestResult !== -1 && streamSegueErrorDialog.text) {
            streamSegueErrorDialog.text += "\n\n" + qsTr("This PC's Internet connection is blocking Moonlight. Streaming over the Internet may not work while connected to this network.")
        }

        // Re-enable GUI gamepad usage now
        SdlGamepadKeyNavigation.enable()

        if (quitAfter) {
            if (streamSegueErrorDialog.text) {
                // Quit when the error dialog is acknowledged
                streamSegueErrorDialog.quitAfter = quitAfter
                streamSegueErrorDialog.open()
            }
            else {
                // Quit immediately
                Qt.quit()
            }
        } else {
            // Exit this view
            stackView.pop()

            // Show the Qt window again after streaming
            window.visible = true

            // Display any launch errors. We do this after
            // the Qt UI is visible again to prevent losing
            // focus on the dialog which would impact gamepad
            // users.
            if (streamSegueErrorDialog.text) {
                streamSegueErrorDialog.quitAfter = quitAfter
                streamSegueErrorDialog.open()
            }
        }
    }
```
**File:** app/gui/StreamSegue.qml (L110-116)
```text
    function sessionReadyForDeletion()
    {
        // Garbage collect the Session object since it's pretty heavyweight
        // and keeps other libraries (like SDL_TTF) around until it is deleted.
        session = null
        gc()
    }
```
**File:** app/gui/StreamSegue.qml (L167-168)
```text
            hintText.text = qsTr("Tip:") + " " + qsTr("Press %1 to disconnect your session").arg(SdlGamepadKeyNavigation.getConnectedGamepads() > 0 ?
                                                  qsTr("Start+Select+L1+R1") : qsTr("Ctrl+Alt+Shift+Q"))
```
**File:** app/streaming/session.cpp (L98-155)
```cpp
void Session::clConnectionTerminated(int errorCode)
{
    unsigned int portFlags = LiGetPortFlagsFromTerminationErrorCode(errorCode);
    s_ActiveSession->m_PortTestResults = LiTestClientConnectivity(CONN_TEST_SERVER, 443, portFlags);

    // Display the termination dialog if this was not intended
    switch (errorCode) {
    case ML_ERROR_GRACEFUL_TERMINATION:
        break;

    case ML_ERROR_NO_VIDEO_TRAFFIC:
        s_ActiveSession->m_UnexpectedTermination = true;

        char ports[128];
        SDL_assert(portFlags != 0);
        LiStringifyPortFlags(portFlags, ", ", ports, sizeof(ports));
        emit s_ActiveSession->displayLaunchError(tr("No video received from host.") + "\n\n"+
                                                 tr("Check your firewall and port forwarding rules for port(s): %1").arg(ports));
        break;

    case ML_ERROR_NO_VIDEO_FRAME:
        s_ActiveSession->m_UnexpectedTermination = true;
        emit s_ActiveSession->displayLaunchError(tr("Your network connection isn't performing well. Reduce your video bitrate setting or try a faster connection."));
        break;

    case ML_ERROR_PROTECTED_CONTENT:
    case ML_ERROR_UNEXPECTED_EARLY_TERMINATION:
        s_ActiveSession->m_UnexpectedTermination = true;
        emit s_ActiveSession->displayLaunchError(tr("Something went wrong on your host PC when starting the stream.") + "\n\n" +
                                                 tr("Make sure you don't have any DRM-protected content open on your host PC. You can also try restarting your host PC."));
        break;

    case ML_ERROR_FRAME_CONVERSION:
        s_ActiveSession->m_UnexpectedTermination = true;
        emit s_ActiveSession->displayLaunchError(tr("The host PC reported a fatal video encoding error.") + "\n\n" +
                                                 tr("Try disabling HDR mode, changing the streaming resolution, or changing your host PC's display resolution."));
        break;

    default:
        s_ActiveSession->m_UnexpectedTermination = true;

        // We'll assume large errors are hex values
        bool hexError = qAbs(errorCode) > 1000;
        emit s_ActiveSession->displayLaunchError(tr("Connection terminated") + "\n\n" +
                                                 tr("Error code: %1").arg(errorCode, hexError ? 8 : 0, hexError ? 16 : 10, QChar('0')));
        break;
    }

    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION,
                 "Connection terminated: %d",
                 errorCode);

    // Push a quit event to the main loop
    SDL_Event event;
    event.type = SDL_QUIT;
    event.quit.timestamp = SDL_GetTicks();
    SDL_PushEvent(&event);
}
```
**File:** app/backend/computermanager.cpp (L675-682)
```cpp
void ComputerManager::quitRunningApp(NvComputer* computer)
{
    QWriteLocker lock(&computer->lock);
    computer->pendingQuit = true;

    PendingQuitTask* quit = new PendingQuitTask(this, computer);
    QThreadPool::globalInstance()->start(quit);
}
```
## Q9
Please list all the APIs used for the client and server interaction, including their purposes and required parameters, and list the APIs needed for the entire process from adding a computer to selecting one in the app list and starting a connection to ending the connection.
### Answer
Based on my analysis of the Moonlight codebase, here are all the client-server interaction APIs used throughout the entire process:

## 1. **Adding a Computer**

### Server Discovery - `serverinfo` API
**Purpose**: Discover and retrieve information about the host PC, including pairing status, current game, server version, and HTTPS port. moonlight-qt:124-187 

**Required Parameters**:
- `uniqueid`: Common UID for Moonlight clients (fixed: "0123456789ABCDEF")
- `uuid`: Random UUID for the request

**Protocol**: HTTP initially (before pairing), then HTTPS (after pairing)

### Pairing - 5-Phase Cryptographic Handshake

**Purpose**: Establish trust between client and host PC through certificate exchange and PIN verification. moonlight-qt:191-355 

**Phase 1 - Get Server Certificate**:
- Endpoint: `pair`
- Parameters:
  - `devicename=roth`
  - `updateState=1`
  - `phrase=getservercert`
  - `salt`: 16-byte random salt (hex)
  - `clientcert`: Client certificate (hex)

**Phase 2 - Client Challenge**:
- Endpoint: `pair`
- Parameters:
  - `devicename=roth`
  - `updateState=1`
  - `clientchallenge`: Encrypted 16-byte challenge (hex)

**Phase 3 - Server Challenge Response**:
- Endpoint: `pair`
- Parameters:
  - `devicename=roth`
  - `updateState=1`
  - `serverchallengeresp`: Encrypted challenge response hash (hex)

**Phase 4 - Client Pairing Secret**:
- Endpoint: `pair`
- Parameters:
  - `devicename=roth`
  - `updateState=1`
  - `clientpairingsecret`: Client secret + signature (hex)

**Phase 5 - Final Challenge (HTTPS)**:
- Endpoint: `pair`
- Parameters:
  - `devicename=roth`
  - `updateState=1`
  - `phrase=pairchallenge`

**Protocol**: HTTP for phases 1-4, HTTPS for phase 5

## 2. **Selecting an App**

### App List - `applist` API
**Purpose**: Retrieve the list of available applications on the host PC. moonlight-qt:288-328 

**Required Parameters**:
- `uniqueid`: "0123456789ABCDEF"
- `uuid`: Random UUID

**Protocol**: HTTPS (requires prior pairing)

**Response**: XML with app information including:
- `AppTitle`: Application name
- `ID`: Application ID
- `IsHdrSupported`: HDR capability
- `IsAppCollectorGame`: Whether it's an App Collector game

### Box Art - `getBoxArt` API
**Purpose**: Download application cover art/thumbnails. moonlight-qt:178-179 moonlight-qt:107-129 

**Required Parameters**:
- `appId`: Application ID

**Protocol**: HTTPS
**Response**: Image data (various formats, cached as PNG locally)

## 3. **Starting a Streaming Connection**

### Launch/Resume - `launch` or `resume` API
**Purpose**: Start a new streaming session or resume an existing one. moonlight-qt:190-236 moonlight-qt:1582-1600 

**Endpoint**: `launch` (new session) or `resume` (existing session)

**Required Parameters**:
- `uniqueid`: "0123456789ABCDEF"
- `uuid`: Random UUID
- `appid`: Application ID to launch
- `mode`: Resolution and FPS (format: `{width}x{height}x{fps}`)
- `additionalStates=1`: Enable additional states
- `sops`: Stream optimization settings (0 or 1)
- `rikey`: Remote input AES key (hex)
- `rikeyid`: Remote input key ID
- `hdrMode`: HDR mode flag (included if HDR supported)
- `clientHdrCapVersion`, `clientHdrCapSupportedFlagsInUint32`, `clientHdrCapMetaDataId`, `clientHdrCapDisplayData`: HDR capability parameters (if HDR mode)
- `localAudioPlayMode`: Play audio on host (0 or 1)
- `surroundAudioInfo`: Surround audio configuration
- `remoteControllersBitmap`: Gamepad mask
- `gcmap`: Gamepad controller map
- `gcpersist`: Persist game controllers on disconnect (0 or 1)
- Additional parameters from `LiGetLaunchUrlQueryParameters()`

**Protocol**: HTTPS

**Response**: XML containing `sessionUrl0` (RTSP session URL)

**Decision Logic**: The verb is determined based on whether a game is currently running: moonlight-qt:1586-1593 

## 4. **Ending a Streaming Connection**

### Quit App - `cancel` API
**Purpose**: Terminate the currently running application on the host PC. moonlight-qt:238-259 

**Required Parameters**:
- `uniqueid`: "0123456789ABCDEF"
- `uuid`: Random UUID

**Protocol**: HTTPS

**Timeout**: 30 seconds

**Note**: The quit operation is optional based on user preferences: moonlight-qt:1554-1558 

## Additional APIs

### Wake-on-LAN
**Purpose**: Wake up a sleeping/powered-off host PC. moonlight-qt:1-50 

**Protocol**: UDP magic packets sent to multiple addresses and ports (9, 47009, and dynamic ports 47998-48010)

### Unpair - `unpair` API
**Purpose**: Remove pairing relationship (used during pairing failures). moonlight-qt:232-234 

**Required Parameters**: Standard uniqueid and uuid

**Protocol**: HTTP

## Notes

- All HTTP/HTTPS requests use a common `uniqueid` of "0123456789ABCDEF" to allow Moonlight clients to manage each other's sessions
- Each request includes a random `uuid` parameter generated via `QUuid::createUuid()`
- Certificate pinning is implemented for HTTPS connections to prevent MITM attacks
- Timeouts vary by operation: 2s (fast-fail), 5s (normal), 30s (resume/quit), 120s (launch)
- The base URL format is `http(s)://{host}:{port}/{command}?{parameters}`
### Citations
**File:** app/backend/nvhttp.cpp (L124-187)
```cpp
NvHTTP::getServerInfo(NvLogLevel logLevel, bool fastFail)
{
    QString serverInfo;

    // Check if we have a pinned cert and HTTPS port for this host yet
    if (!m_ServerCert.isNull() && httpsPort() != 0)
    {
        try
        {
            // Always try HTTPS first, since it properly reports
            // pairing status (and a few other attributes).
            serverInfo = openConnectionToString(m_BaseUrlHttps,
                                                "serverinfo",
                                                nullptr,
                                                fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                                logLevel);
            // Throws if the request failed
            verifyResponseStatus(serverInfo);
        }
        catch (const GfeHttpResponseException& e)
        {
            if (e.getStatusCode() == 401)
            {
                // Certificate validation error, fallback to HTTP
                serverInfo = openConnectionToString(m_BaseUrlHttp,
                                                    "serverinfo",
                                                    nullptr,
                                                    fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                                    logLevel);
                verifyResponseStatus(serverInfo);
            }
            else
            {
                // Rethrow real errors
                throw e;
            }
        }
    }
    else
    {
        // Only use HTTP prior to pairing or fetching HTTPS port
        serverInfo = openConnectionToString(m_BaseUrlHttp,
                                            "serverinfo",
                                            nullptr,
                                            fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                            logLevel);
        verifyResponseStatus(serverInfo);

        // Populate the HTTPS port
        uint16_t httpsPort = getXmlString(serverInfo, "HttpsPort").toUShort();
        if (httpsPort == 0) {
            httpsPort = DEFAULT_HTTPS_PORT;
        }
        setHttpsPort(httpsPort);

        // If we just needed to determine the HTTPS port, we'll try again over
        // HTTPS now that we have the port number
        if (!m_ServerCert.isNull()) {
            return getServerInfo(logLevel, fastFail);
        }
    }

    return serverInfo;
}
```
**File:** app/backend/nvhttp.cpp (L190-236)
```cpp
NvHTTP::startApp(QString verb,
                 bool isGfe,
                 int appId,
                 PSTREAM_CONFIGURATION streamConfig,
                 bool sops,
                 bool localAudio,
                 int gamepadMask,
                 bool persistGameControllersOnDisconnect,
                 QString& rtspSessionUrl)
{
    int riKeyId;

    memcpy(&riKeyId, streamConfig->remoteInputAesIv, sizeof(riKeyId));
    riKeyId = qFromBigEndian(riKeyId);

    QString response =
            openConnectionToString(m_BaseUrlHttps,
                                   verb,
                                   "appid="+QString::number(appId)+
                                   "&mode="+QString::number(streamConfig->width)+"x"+
                                   QString::number(streamConfig->height)+"x"+
                                   // Using an FPS value over 60 causes SOPS to default to 720p60,
                                   // so force it to 0 to ensure the correct resolution is set. We
                                   // used to use 60 here but that locked the frame rate to 60 FPS
                                   // on GFE 3.20.3. We don't need this hack for Sunshine.
                                   QString::number((streamConfig->fps > 60 && isGfe) ? 0 : streamConfig->fps)+
                                   "&additionalStates=1&sops="+QString::number(sops ? 1 : 0)+
                                   "&rikey="+QByteArray(streamConfig->remoteInputAesKey, sizeof(streamConfig->remoteInputAesKey)).toHex()+
                                   "&rikeyid="+QString::number(riKeyId)+
                                   ((streamConfig->supportedVideoFormats & VIDEO_FORMAT_MASK_10BIT) ?
                                       "&hdrMode=1&clientHdrCapVersion=0&clientHdrCapSupportedFlagsInUint32=0&clientHdrCapMetaDataId=NV_STATIC_METADATA_TYPE_1&clientHdrCapDisplayData=0x0x0x0x0x0x0x0x0x0x0" :
                                        "")+
                                   "&localAudioPlayMode="+QString::number(localAudio ? 1 : 0)+
                                   "&surroundAudioInfo="+QString::number(SURROUNDAUDIOINFO_FROM_AUDIO_CONFIGURATION(streamConfig->audioConfiguration))+
                                   "&remoteControllersBitmap="+QString::number(gamepadMask)+
                                   "&gcmap="+QString::number(gamepadMask)+
                                   "&gcpersist="+QString::number(persistGameControllersOnDisconnect ? 1 : 0)+
                                   LiGetLaunchUrlQueryParameters(),
                                   LAUNCH_TIMEOUT_MS);

    qInfo() << "Launch response:" << response;

    // Throws if the request failed
    verifyResponseStatus(response);

    rtspSessionUrl = getXmlString(response, "sessionUrl0");
}
```
**File:** app/backend/nvhttp.cpp (L238-259)
```cpp
void
NvHTTP::quitApp()
{
    QString response =
            openConnectionToString(m_BaseUrlHttps,
                                   "cancel",
                                   nullptr,
                                   QUIT_TIMEOUT_MS);

    qInfo() << "Quit response:" << response;

    // Throws if the request failed
    verifyResponseStatus(response);

    // Newer GFE versions will just return success even if quitting fails
    // if we're not the original requester.
    if (getCurrentGame(getServerInfo(NvHTTP::NVLL_ERROR)) != 0) {
        // Generate a synthetic GfeResponseException letting the caller know
        // that they can't kill someone else's stream.
        throw GfeHttpResponseException(599, "");
    }
}
```
**File:** app/backend/nvhttp.cpp (L288-328)
```cpp
QVector<NvApp>
NvHTTP::getAppList()
{
    QString appxml = openConnectionToString(m_BaseUrlHttps,
                                            "applist",
                                            nullptr,
                                            REQUEST_TIMEOUT_MS,
                                            NvLogLevel::NVLL_ERROR);
    verifyResponseStatus(appxml);

    QXmlStreamReader xmlReader(appxml);
    QVector<NvApp> apps;
    while (!xmlReader.atEnd()) {
        while (xmlReader.readNextStartElement()) {
            auto name = xmlReader.name();
            if (name == QString("App")) {
                // We must have a valid app before advancing to the next one
                if (!apps.isEmpty() && !apps.last().isInitialized()) {
                    qWarning() << "Invalid applist XML";
                    Q_ASSERT(false);
                    return QVector<NvApp>();
                }
                apps.append(NvApp());
            }
            else if (name == QString("AppTitle")) {
                apps.last().name = xmlReader.readElementText();
            }
            else if (name == QString("ID")) {
                apps.last().id = xmlReader.readElementText().toInt();
            }
            else if (name == QString("IsHdrSupported")) {
                apps.last().hdrSupported = xmlReader.readElementText() == "1";
            }
            else if (name == QString("IsAppCollectorGame")) {
                apps.last().isAppCollectorGame = xmlReader.readElementText() == "1";
            }
        }
    }

    return apps;
}
```
**File:** app/backend/nvpairingmanager.cpp (L191-355)
```cpp
NvPairingManager::pair(QString appVersion, QString pin, QSslCertificate& serverCert)
{
    int serverMajorVersion = NvHTTP::parseQuad(appVersion).at(0);
    qInfo() << "Pairing with server generation:" << serverMajorVersion;

    QCryptographicHash::Algorithm hashAlgo;
    int hashLength;
    if (serverMajorVersion >= 7)
    {
        // Gen 7+ uses SHA-256 hashing
        hashAlgo = QCryptographicHash::Sha256;
        hashLength = 32;
    }
    else
    {
        // Prior to Gen 7 uses SHA-1 hashing
        hashAlgo = QCryptographicHash::Sha1;
        hashLength = 20;
    }

    QByteArray salt = generateRandomBytes(16);
    QByteArray saltedPin = saltPin(salt, pin);

    QByteArray aesKey = QCryptographicHash::hash(saltedPin, hashAlgo).constData();
    aesKey.truncate(16);

    QString getCert = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&phrase=getservercert&salt=" +
                                                    salt.toHex() + "&clientcert=" + IdentityManager::get()->getCertificate().toHex(),
                                                    0);
    NvHTTP::verifyResponseStatus(getCert);
    if (NvHTTP::getXmlString(getCert, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #1";
        return PairState::FAILED;
    }

    QByteArray serverCertStr = NvHTTP::getXmlStringFromHex(getCert, "plaincert");
    if (serverCertStr == nullptr)
    {
        qCritical() << "Server likely already pairing";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::ALREADY_IN_PROGRESS;
    }

    QSslCertificate unverifiedServerCert = QSslCertificate(serverCertStr);
    if (unverifiedServerCert.isNull()) {
        Q_ASSERT(!unverifiedServerCert.isNull());

        qCritical() << "Failed to parse plaincert";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    // Pin this cert for TLS until pairing is complete. If successful, we will propagate
    // the cert into the NvComputer object and persist it.
    m_Http.setServerCert(unverifiedServerCert);

    QByteArray randomChallenge = generateRandomBytes(16);
    QByteArray encryptedChallenge = encrypt(randomChallenge, aesKey);
    QString challengeXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                         "pair",
                                                         "devicename=roth&updateState=1&clientchallenge=" +
                                                         encryptedChallenge.toHex(),
                                                         REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(challengeXml);
    if (NvHTTP::getXmlString(challengeXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #2";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray challengeResponseData = decrypt(m_Http.getXmlStringFromHex(challengeXml, "challengeresponse"), aesKey);
    QByteArray clientSecretData = generateRandomBytes(16);
    QByteArray challengeResponse;
    QByteArray serverResponse(challengeResponseData.data(), hashLength);

#if (OPENSSL_VERSION_NUMBER < 0x10002000L)
    ASN1_BIT_STRING *asnSignature = m_Cert->signature;
#elif (OPENSSL_VERSION_NUMBER < 0x10100000L)
    ASN1_BIT_STRING *asnSignature;
    X509_get0_signature(&asnSignature, NULL, m_Cert);
#else
    const ASN1_BIT_STRING *asnSignature;
    X509_get0_signature(&asnSignature, NULL, m_Cert);
#endif

    challengeResponse.append(challengeResponseData.data() + hashLength, 16);
    challengeResponse.append(reinterpret_cast<char*>(asnSignature->data), asnSignature->length);
    challengeResponse.append(clientSecretData);

    QByteArray paddedHash = QCryptographicHash::hash(challengeResponse, hashAlgo);
    paddedHash.resize(32);
    QByteArray encryptedChallengeResponseHash = encrypt(paddedHash, aesKey);
    QString respXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&serverchallengeresp=" +
                                                    encryptedChallengeResponseHash.toHex(),
                                                    REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(respXml);
    if (NvHTTP::getXmlString(respXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #3";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray pairingSecret = NvHTTP::getXmlStringFromHex(respXml, "pairingsecret");
    QByteArray serverSecret = pairingSecret.left(16);
    QByteArray serverSignature = pairingSecret.mid(16);

    if (!verifySignature(serverSecret,
                         serverSignature,
                         serverCertStr))
    {
        qCritical() << "MITM detected";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray expectedResponseData;
    expectedResponseData.append(randomChallenge);
    expectedResponseData.append(getSignatureFromPemCert(serverCertStr));
    expectedResponseData.append(serverSecret);
    if (QCryptographicHash::hash(expectedResponseData, hashAlgo) != serverResponse)
    {
        qCritical() << "Incorrect PIN";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::PIN_WRONG;
    }

    QByteArray clientPairingSecret;
    clientPairingSecret.append(clientSecretData);
    clientPairingSecret.append(signMessage(clientSecretData));

    QString secretRespXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                          "pair",
                                                          "devicename=roth&updateState=1&clientpairingsecret=" +
                                                          clientPairingSecret.toHex(),
                                                          REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(secretRespXml);
    if (NvHTTP::getXmlString(secretRespXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #4";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QString pairChallengeXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttps,
                                                             "pair",
                                                             "devicename=roth&updateState=1&phrase=pairchallenge",
                                                             REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(pairChallengeXml);
    if (NvHTTP::getXmlString(pairChallengeXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #5";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    serverCert = std::move(unverifiedServerCert);
    return PairState::PAIRED;
}
```
**File:** app/backend/nvhttp.h (L178-179)
```text
    QImage
    getBoxArt(int appId);
```
**File:** app/backend/boxartmanager.cpp (L107-129)
```cpp
QUrl BoxArtManager::loadBoxArtFromNetwork(NvComputer* computer, int appId)
{
    NvHTTP http(computer);

    QString cachePath = getFilePathForBoxArt(computer, appId);
    QImage image;
    try {
        image = http.getBoxArt(appId);
    } catch (...) {}

    // Cache the box art on disk if it loaded
    if (!image.isNull()) {
        if (image.save(cachePath)) {
            return QUrl::fromLocalFile(cachePath);
        }
        else {
            // A failed save() may leave a zero byte file. Make sure that's removed.
            QFile(cachePath).remove();
        }
    }

    return QUrl();
}
```
**File:** app/streaming/session.cpp (L1554-1558)
```cpp
    // The UI should have ensured the old game was already quit
    // if we decide to stream a different game.
    Q_ASSERT(m_Computer->currentGameId == 0 ||
             m_Computer->currentGameId == m_App.id);

```
**File:** app/streaming/session.cpp (L1582-1600)
```cpp
    QString rtspSessionUrl;

    try {
        NvHTTP http(m_Computer);
        http.startApp(m_Computer->currentGameId != 0 ? "resume" : "launch",
                      m_Computer->isNvidiaServerSoftware,
                      m_App.id, &m_StreamConfig,
                      enableGameOptimizations,
                      m_Preferences->playAudioOnHost,
                      m_InputHandler->getAttachedGamepadMask(),
                      !m_Preferences->multiController,
                      rtspSessionUrl);
    } catch (const GfeHttpResponseException& e) {
        emit displayLaunchError(tr("Host returned error: %1").arg(e.toQString()));
        return false;
    } catch (const QtNetworkReplyException& e) {
        emit displayLaunchError(e.toQString());
        return false;
    }
```
**File:** app/backend/nvcomputer.cpp (L1-50)
```cpp
#include "nvcomputer.h"
#include "nvapp.h"
#include "settings/compatfetcher.h"

#include <QUdpSocket>
#include <QHostInfo>
#include <QNetworkInterface>
#include <QNetworkProxy>

#define SER_NAME "hostname"
#define SER_UUID "uuid"
#define SER_MAC "mac"
#define SER_LOCALADDR "localaddress"
#define SER_LOCALPORT "localport"
#define SER_REMOTEADDR "remoteaddress"
#define SER_REMOTEPORT "remoteport"
#define SER_MANUALADDR "manualaddress"
#define SER_MANUALPORT "manualport"
#define SER_IPV6ADDR "ipv6address"
#define SER_IPV6PORT "ipv6port"
#define SER_APPLIST "apps"
#define SER_SRVCERT "srvcert"
#define SER_CUSTOMNAME "customname"
#define SER_NVIDIASOFTWARE "nvidiasw"

NvComputer::NvComputer(QSettings& settings)
{
    this->name = settings.value(SER_NAME).toString();
    this->uuid = settings.value(SER_UUID).toString();
    this->hasCustomName = settings.value(SER_CUSTOMNAME).toBool();
    this->macAddress = settings.value(SER_MAC).toByteArray();
    this->localAddress = NvAddress(settings.value(SER_LOCALADDR).toString(),
                                   settings.value(SER_LOCALPORT, QVariant(DEFAULT_HTTP_PORT)).toUInt());
    this->remoteAddress = NvAddress(settings.value(SER_REMOTEADDR).toString(),
                                    settings.value(SER_REMOTEPORT, QVariant(DEFAULT_HTTP_PORT)).toUInt());
    this->ipv6Address = NvAddress(settings.value(SER_IPV6ADDR).toString(),
                                  settings.value(SER_IPV6PORT, QVariant(DEFAULT_HTTP_PORT)).toUInt());
    this->manualAddress = NvAddress(settings.value(SER_MANUALADDR).toString(),
                                    settings.value(SER_MANUALPORT, QVariant(DEFAULT_HTTP_PORT)).toUInt());
    this->serverCert = QSslCertificate(settings.value(SER_SRVCERT).toByteArray());
    this->isNvidiaServerSoftware = settings.value(SER_NVIDIASOFTWARE).toBool();

    int appCount = settings.beginReadArray(SER_APPLIST);
    this->appList.reserve(appCount);
    for (int i = 0; i < appCount; i++) {
        settings.setArrayIndex(i);

        NvApp app(settings);
        this->appList.append(app);
    }
```
## Q10
The server completes the pairing by inputting the PIN code displayed by the client. How does the client wait for the server's response to complete the pairing during the time the PIN code is generated and the user inputs the PIN on the server side?
### Answer
You're asking about how the Moonlight client waits for the server to complete pairing after displaying the PIN code to the user.

## Answer

The client doesn't actively poll or wait for the server's response during pairing. Instead, the pairing process is **synchronous and blocking** - the client sends requests sequentially through all 5 phases and waits for each response before proceeding to the next phase.

### Pairing Execution Flow

When the user clicks on an unpaired PC, the client generates a PIN and displays it in a dialog: moonlight-qt:239-246 

The pairing task runs in a background thread via `PendingPairingTask`: moonlight-qt:564-582 

### The Blocking Nature of Pairing

Inside `NvPairingManager::pair()`, each phase makes an HTTP/HTTPS request and **blocks waiting for the response** before proceeding: moonlight-qt:217-227 

The server validates the PIN during Phase 3 (server challenge response). If the user hasn't entered the PIN yet on the server side, the server simply doesn't respond or returns an error, causing the pairing to fail: moonlight-qt:287-298 

### PIN Validation

The PIN validation happens when the client sends the encrypted challenge response hash in Phase 3. The server decrypts this using the PIN-derived key and verifies it matches the expected value: moonlight-qt:313-322 

If the PIN is incorrect (user entered wrong PIN on server), the server returns a response that causes the client to detect `PIN_WRONG` state: moonlight-qt:585-586 

### UI Feedback

While pairing is in progress, the dialog remains open showing the PIN: moonlight-qt:302-310 

When pairing completes (successfully or with error), the `pairingCompleted` signal is emitted, which closes the dialog: moonlight-qt:47-58 

## Notes

The pairing process uses HTTP request timeouts (defined as `REQUEST_TIMEOUT_MS`) to prevent indefinite waiting. If the user takes too long to enter the PIN on the server, the HTTP request will timeout and pairing will fail. The client doesn't implement any retry logic or polling mechanism - it's a single synchronous attempt that either succeeds or fails based on the server's responses to the 5-phase handshake.

Wiki pages you might want to explore:
- [User Interface System (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2)
- [PC Discovery View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.1)
### Citations
**File:** app/gui/PcView.qml (L47-58)
```text
    function pairingComplete(error)
    {
        // Close the PIN dialog
        pairDialog.close()

        // Display a failed dialog if we got an error
        if (error !== undefined) {
            errorDialog.text = error
            errorDialog.helpText = ""
            errorDialog.open()
        }
    }
```
**File:** app/gui/PcView.qml (L239-246)
```text
                    var pin = computerModel.generatePinString()

                    // Kick off pairing in the background
                    computerModel.pairComputer(index, pin)

                    // Display the pairing dialog
                    pairDialog.pin = pin
                    pairDialog.open()
```
**File:** app/gui/PcView.qml (L302-310)
```text
        // don't allow edits to the rest of the window while open
        property string pin : "0000"
        text:qsTr("Please enter %1 on your host PC. This dialog will close when pairing is completed.").arg(pin)+"\n\n"+
             qsTr("If your host PC is running Sunshine, navigate to the Sunshine web UI to enter the PIN.")
        standardButtons: Dialog.Cancel
        onRejected: {
            // FIXME: We should interrupt pairing here
        }
    }
```
**File:** app/backend/computermanager.cpp (L564-582)
```cpp
    PendingPairingTask(ComputerManager* computerManager, NvComputer* computer, QString pin)
        : m_ComputerManager(computerManager),
          m_Computer(computer),
          m_Pin(pin)
    {
        connect(this, &PendingPairingTask::pairingCompleted,
                computerManager, &ComputerManager::pairingCompleted);
    }

signals:
    void pairingCompleted(NvComputer* computer, QString error);

private:
    void run()
    {
        NvPairingManager pairingManager(m_Computer);

        try {
           NvPairingManager::PairState result = pairingManager.pair(m_Computer->appVersion, m_Pin, m_Computer->serverCert);
```
**File:** app/backend/computermanager.cpp (L585-586)
```cpp
           case NvPairingManager::PairState::PIN_WRONG:
               emit pairingCompleted(m_Computer, tr("The PIN from the PC didn't match. Please try again."));
```
**File:** app/backend/nvpairingmanager.cpp (L217-227)
```cpp
    QString getCert = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&phrase=getservercert&salt=" +
                                                    salt.toHex() + "&clientcert=" + IdentityManager::get()->getCertificate().toHex(),
                                                    0);
    NvHTTP::verifyResponseStatus(getCert);
    if (NvHTTP::getXmlString(getCert, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #1";
        return PairState::FAILED;
    }
```
**File:** app/backend/nvpairingmanager.cpp (L287-298)
```cpp
    QString respXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&serverchallengeresp=" +
                                                    encryptedChallengeResponseHash.toHex(),
                                                    REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(respXml);
    if (NvHTTP::getXmlString(respXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #3";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }
```
**File:** app/backend/nvpairingmanager.cpp (L313-322)
```cpp
    QByteArray expectedResponseData;
    expectedResponseData.append(randomChallenge);
    expectedResponseData.append(getSignatureFromPemCert(serverCertStr));
    expectedResponseData.append(serverSecret);
    if (QCryptographicHash::hash(expectedResponseData, hashAlgo) != serverResponse)
    {
        qCritical() << "Incorrect PIN";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::PIN_WRONG;
    }
```
# DeepWiki Q&A with Code Context for Repository: moonlight-stream/moonlight-qt
## Q1
how to get /launch and /serverinfo info from server?
### Answer
Based on the code context, you're asking about how Moonlight retrieves `/launch` and `/serverinfo` information from the host server.

## Answer

Moonlight uses the `NvHTTP` class to communicate with the host server and retrieve information through HTTP/HTTPS endpoints. moonlight-qt:124-187 

### Getting `/serverinfo`

The `NvHTTP::getServerInfo()` method fetches server information: moonlight-qt:124-140 

The method first attempts to use HTTPS if a pinned certificate is available, then falls back to HTTP if needed. moonlight-qt:143-160  If no certificate exists yet, it uses HTTP initially to fetch the HTTPS port, then retries over HTTPS. moonlight-qt:162-183 

This is called during PC discovery when adding a new host: moonlight-qt:809-818 

The response is then used to create or update an `NvComputer` object: moonlight-qt:820-821 

### Getting `/launch` info

The `/launch` endpoint is called via `NvHTTP::startApp()` when starting a streaming session: moonlight-qt:1585-1593 

This happens in `Session::startConnectionAsync()` after the user selects an app to stream. moonlight-qt:1548-1600  The method passes streaming configuration parameters and receives back an RTSP session URL that's used to establish the actual streaming connection. moonlight-qt:1582-1593 

## Notes

The `NvHTTP` class handles all HTTP/HTTPS communication with the host server, including certificate pinning for security. The `/serverinfo` endpoint is polled regularly to monitor PC status, while `/launch` (or `/resume`) is only called when initiating a streaming session. Both endpoints use the base URL constructed from the host's address and appropriate port (HTTP 47989 or HTTPS 47984 by default).

Wiki pages you might want to explore:
- [User Interface System (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2)
- [PC Discovery View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.1)
### Citations
**File:** app/backend/nvhttp.cpp (L124-187)
```cpp
NvHTTP::getServerInfo(NvLogLevel logLevel, bool fastFail)
{
    QString serverInfo;

    // Check if we have a pinned cert and HTTPS port for this host yet
    if (!m_ServerCert.isNull() && httpsPort() != 0)
    {
        try
        {
            // Always try HTTPS first, since it properly reports
            // pairing status (and a few other attributes).
            serverInfo = openConnectionToString(m_BaseUrlHttps,
                                                "serverinfo",
                                                nullptr,
                                                fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                                logLevel);
            // Throws if the request failed
            verifyResponseStatus(serverInfo);
        }
        catch (const GfeHttpResponseException& e)
        {
            if (e.getStatusCode() == 401)
            {
                // Certificate validation error, fallback to HTTP
                serverInfo = openConnectionToString(m_BaseUrlHttp,
                                                    "serverinfo",
                                                    nullptr,
                                                    fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                                    logLevel);
                verifyResponseStatus(serverInfo);
            }
            else
            {
                // Rethrow real errors
                throw e;
            }
        }
    }
    else
    {
        // Only use HTTP prior to pairing or fetching HTTPS port
        serverInfo = openConnectionToString(m_BaseUrlHttp,
                                            "serverinfo",
                                            nullptr,
                                            fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                            logLevel);
        verifyResponseStatus(serverInfo);

        // Populate the HTTPS port
        uint16_t httpsPort = getXmlString(serverInfo, "HttpsPort").toUShort();
        if (httpsPort == 0) {
            httpsPort = DEFAULT_HTTPS_PORT;
        }
        setHttpsPort(httpsPort);

        // If we just needed to determine the HTTPS port, we'll try again over
        // HTTPS now that we have the port number
        if (!m_ServerCert.isNull()) {
            return getServerInfo(logLevel, fastFail);
        }
    }

    return serverInfo;
}
```
**File:** app/backend/computermanager.cpp (L809-818)
```cpp
        // Perform initial serverinfo fetch over HTTP since we don't know which cert to use
        QString serverInfo = fetchServerInfo(http);
        if (serverInfo.isEmpty() && !m_MdnsIpv6Address.isNull()) {
            // Retry using the global IPv6 address if the IPv4 or link-local IPv6 address fails
            http.setAddress(m_MdnsIpv6Address);
            serverInfo = fetchServerInfo(http);
        }
        if (serverInfo.isEmpty()) {
            return;
        }
```
**File:** app/backend/computermanager.cpp (L820-821)
```cpp
        // Create initial newComputer using HTTP serverinfo with no pinned cert
        NvComputer* newComputer = new NvComputer(http, serverInfo);
```
**File:** app/streaming/session.cpp (L1548-1600)
```cpp
bool Session::startConnectionAsync()
{
    // Wait 1.5 seconds before connecting to let the user
    // have time to read any messages present on the segue
    SDL_Delay(1500);

    // The UI should have ensured the old game was already quit
    // if we decide to stream a different game.
    Q_ASSERT(m_Computer->currentGameId == 0 ||
             m_Computer->currentGameId == m_App.id);

    bool enableGameOptimizations;
    if (m_Computer->isNvidiaServerSoftware) {
        // GFE will set all settings to 720p60 if it doesn't recognize
        // the chosen resolution. Avoid that by disabling SOPS when it
        // is not streaming a supported resolution.
        enableGameOptimizations = false;
        for (const NvDisplayMode &mode : m_Computer->displayModes) {
            if (mode.width == m_StreamConfig.width &&
                    mode.height == m_StreamConfig.height) {
                SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION,
                            "Found host supported resolution: %dx%d",
                            mode.width, mode.height);
                enableGameOptimizations = m_Preferences->gameOptimizations;
                break;
            }
        }
    }
    else {
        // Always send SOPS to Sunshine because we may repurpose the
        // option to control whether the display mode is adjusted
        enableGameOptimizations = m_Preferences->gameOptimizations;
    }

    QString rtspSessionUrl;

    try {
        NvHTTP http(m_Computer);
        http.startApp(m_Computer->currentGameId != 0 ? "resume" : "launch",
                      m_Computer->isNvidiaServerSoftware,
                      m_App.id, &m_StreamConfig,
                      enableGameOptimizations,
                      m_Preferences->playAudioOnHost,
                      m_InputHandler->getAttachedGamepadMask(),
                      !m_Preferences->multiController,
                      rtspSessionUrl);
    } catch (const GfeHttpResponseException& e) {
        emit displayLaunchError(tr("Host returned error: %1").arg(e.toQString()));
        return false;
    } catch (const QtNetworkReplyException& e) {
        emit displayLaunchError(e.toQString());
        return false;
    }
```
## Q2
How to parse the information returned by the above 2 interfaces and provide it to the function for establishing a streaming connection?
### Answer
You're asking about how Moonlight parses the responses from `/serverinfo` and `/launch` endpoints and uses that information to establish a streaming connection.

## Answer

### Parsing `/serverinfo` Response

The `/serverinfo` response is parsed to create/update an `NvComputer` object that stores host capabilities. moonlight-qt:754-782  The `NvHTTP::getServerInfo()` method returns an XML string that gets parsed to extract server properties like:<cite />

- Server codec mode support (`serverCodecModeSupport`)
- GFE version (`gfeVersion`)
- App version (`appVersion`)
- Display modes
- Current game ID

These properties are stored in the `NvComputer` object and later used during session validation and configuration.<cite />

### Parsing `/launch` Response and Establishing Connection

When starting a stream, `NvHTTP::startApp()` is called with the `STREAM_CONFIGURATION` structure containing all streaming parameters (resolution, FPS, bitrate, codec preferences, etc.). moonlight-qt:189-236  The method constructs a URL with query parameters including:<cite />

- Resolution and FPS (`mode` parameter)
- HDR settings
- Audio configuration
- Gamepad mask
- Remote input encryption keys

The response is parsed to extract the `rtspSessionUrl` using `getXmlString(response, "sessionUrl0")`. moonlight-qt:235-235 

### Providing Information to Connection Function

After receiving the `/launch` response, the parsed information is used to populate a `SERVER_INFORMATION` structure: moonlight-qt:1602-1624 

```cpp
SERVER_INFORMATION hostInfo;
hostInfo.address = hostnameStr.data();
hostInfo.serverInfoAppVersion = siAppVersion.data();
hostInfo.serverCodecModeSupport = m_Computer->serverCodecModeSupport;
hostInfo.serverInfoGfeVersion = siGfeVersion.data();
hostInfo.rtspSessionUrl = rtspSessionUrlStr.data();
```

This structure, along with the `STREAM_CONFIGURATION` and callback structures, is passed to `LiStartConnection()` to establish the actual streaming connection: moonlight-qt:1678-1685 

The `LiStartConnection()` function (from the moonlight-common-c library) uses:
- The RTSP session URL from `/launch` response to establish the RTSP control channel
- Server codec support from `/serverinfo` to negotiate video formats
- Stream configuration to set up video/audio decoders

### Validation Before Connection

Before calling `LiStartConnection()`, the session validates that the host supports the requested features by checking `m_Computer->serverCodecModeSupport` against the requested video formats. moonlight-qt:1117-1152  For example, it verifies YUV 4:4:4 support and adjusts the supported video formats list accordingly.<cite />

## Notes

The parsing happens in two stages: first during PC discovery (parsing `/serverinfo` into `NvComputer` properties), then during session start (parsing `/launch` response for RTSP URL). The `NvComputer` object acts as a bridge, storing server capabilities that are later referenced when configuring the `SERVER_INFORMATION` structure for `LiStartConnection()`. The actual XML parsing is handled by helper functions like `getXmlString()` in the `NvHTTP` class.

Wiki pages you might want to explore:
- [Settings View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.2)
- [Input Handling (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#4.7)
### Citations
**File:** app/backend/computermanager.cpp (L754-782)
```cpp
    QString fetchServerInfo(NvHTTP& http)
    {
        QString serverInfo;

        // Do nothing if we're quitting
        if (m_AboutToQuit) {
            return QString();
        }

        try {
            // There's a race condition between GameStream servers reporting presence over
            // mDNS and the HTTPS server being ready to respond to our queries. To work
            // around this issue, we will issue the request again after a few seconds if
            // we see a ServiceUnavailableError error.
            try {
                serverInfo = http.getServerInfo(NvHTTP::NVLL_VERBOSE);
            } catch (const QtNetworkReplyException& e) {
                if (e.getError() == QNetworkReply::ServiceUnavailableError) {
                    qWarning() << "Retrying request in 5 seconds after ServiceUnavailableError";
                    QThread::sleep(5);
                    serverInfo = http.getServerInfo(NvHTTP::NVLL_VERBOSE);
                    qInfo() << "Retry successful";
                }
                else {
                    // Rethrow other errors
                    throw e;
                }
            }
            return serverInfo;
```
**File:** app/backend/nvhttp.cpp (L189-236)
```cpp
void
NvHTTP::startApp(QString verb,
                 bool isGfe,
                 int appId,
                 PSTREAM_CONFIGURATION streamConfig,
                 bool sops,
                 bool localAudio,
                 int gamepadMask,
                 bool persistGameControllersOnDisconnect,
                 QString& rtspSessionUrl)
{
    int riKeyId;

    memcpy(&riKeyId, streamConfig->remoteInputAesIv, sizeof(riKeyId));
    riKeyId = qFromBigEndian(riKeyId);

    QString response =
            openConnectionToString(m_BaseUrlHttps,
                                   verb,
                                   "appid="+QString::number(appId)+
                                   "&mode="+QString::number(streamConfig->width)+"x"+
                                   QString::number(streamConfig->height)+"x"+
                                   // Using an FPS value over 60 causes SOPS to default to 720p60,
                                   // so force it to 0 to ensure the correct resolution is set. We
                                   // used to use 60 here but that locked the frame rate to 60 FPS
                                   // on GFE 3.20.3. We don't need this hack for Sunshine.
                                   QString::number((streamConfig->fps > 60 && isGfe) ? 0 : streamConfig->fps)+
                                   "&additionalStates=1&sops="+QString::number(sops ? 1 : 0)+
                                   "&rikey="+QByteArray(streamConfig->remoteInputAesKey, sizeof(streamConfig->remoteInputAesKey)).toHex()+
                                   "&rikeyid="+QString::number(riKeyId)+
                                   ((streamConfig->supportedVideoFormats & VIDEO_FORMAT_MASK_10BIT) ?
                                       "&hdrMode=1&clientHdrCapVersion=0&clientHdrCapSupportedFlagsInUint32=0&clientHdrCapMetaDataId=NV_STATIC_METADATA_TYPE_1&clientHdrCapDisplayData=0x0x0x0x0x0x0x0x0x0x0" :
                                        "")+
                                   "&localAudioPlayMode="+QString::number(localAudio ? 1 : 0)+
                                   "&surroundAudioInfo="+QString::number(SURROUNDAUDIOINFO_FROM_AUDIO_CONFIGURATION(streamConfig->audioConfiguration))+
                                   "&remoteControllersBitmap="+QString::number(gamepadMask)+
                                   "&gcmap="+QString::number(gamepadMask)+
                                   "&gcpersist="+QString::number(persistGameControllersOnDisconnect ? 1 : 0)+
                                   LiGetLaunchUrlQueryParameters(),
                                   LAUNCH_TIMEOUT_MS);

    qInfo() << "Launch response:" << response;

    // Throws if the request failed
    verifyResponseStatus(response);

    rtspSessionUrl = getXmlString(response, "sessionUrl0");
}
```
**File:** app/streaming/session.cpp (L1117-1152)
```cpp
    if (m_Preferences->enableYUV444) {
        if (!(m_Computer->serverCodecModeSupport & SCM_MASK_YUV444)) {
            emitLaunchWarning(tr("Your host PC doesn't support YUV 4:4:4 streaming."));
            m_SupportedVideoFormats.removeByMask(VIDEO_FORMAT_MASK_YUV444);
        }
        else {
            m_SupportedVideoFormats.removeByMask(~m_SupportedVideoFormats.maskByServerCodecModes(m_Computer->serverCodecModeSupport));

            if (!m_SupportedVideoFormats.isEmpty() &&
                !(m_SupportedVideoFormats.front() & VIDEO_FORMAT_MASK_YUV444)) {
                emitLaunchWarning(tr("Your host PC doesn't support YUV 4:4:4 streaming for selected video codec."));
            }
            else if (m_Preferences->videoDecoderSelection != StreamingPreferences::VDS_FORCE_SOFTWARE) {
                while (!m_SupportedVideoFormats.isEmpty() &&
                       (m_SupportedVideoFormats.front() & VIDEO_FORMAT_MASK_YUV444) &&
                       getDecoderAvailability(testWindow,
                                              m_Preferences->videoDecoderSelection,
                                              m_SupportedVideoFormats.front(),
                                              m_StreamConfig.width,
                                              m_StreamConfig.height,
                                              m_StreamConfig.fps) != DecoderAvailability::Hardware) {
                    if (m_Preferences->videoDecoderSelection == StreamingPreferences::VDS_FORCE_HARDWARE) {
                        m_SupportedVideoFormats.removeFirst();
                    }
                    else {
                        emitLaunchWarning(tr("Using software decoding due to your selection to force YUV 4:4:4 without GPU support. This may cause poor streaming performance."));
                        break;
                    }
                }
                if (!m_SupportedVideoFormats.isEmpty() &&
                    !(m_SupportedVideoFormats.front() & VIDEO_FORMAT_MASK_YUV444)) {
                    emitLaunchWarning(tr("This PC's GPU doesn't support YUV 4:4:4 decoding for selected video codec."));
                }
            }
        }
    }
```
**File:** app/streaming/session.cpp (L1602-1624)
```cpp
    QByteArray hostnameStr = m_Computer->activeAddress.address().toLatin1();
    QByteArray siAppVersion = m_Computer->appVersion.toLatin1();

    SERVER_INFORMATION hostInfo;
    hostInfo.address = hostnameStr.data();
    hostInfo.serverInfoAppVersion = siAppVersion.data();
    hostInfo.serverCodecModeSupport = m_Computer->serverCodecModeSupport;

    // Older GFE versions didn't have this field
    QByteArray siGfeVersion;
    if (!m_Computer->gfeVersion.isEmpty()) {
        siGfeVersion = m_Computer->gfeVersion.toLatin1();
    }
    if (!siGfeVersion.isEmpty()) {
        hostInfo.serverInfoGfeVersion = siGfeVersion.data();
    }

    // Older GFE and Sunshine versions didn't have this field
    QByteArray rtspSessionUrlStr;
    if (!rtspSessionUrl.isEmpty()) {
        rtspSessionUrlStr = rtspSessionUrl.toLatin1();
        hostInfo.rtspSessionUrl = rtspSessionUrlStr.data();
    }
```
**File:** app/streaming/session.cpp (L1678-1685)
```cpp
    int err = LiStartConnection(&hostInfo, &m_StreamConfig, &k_ConnCallbacks,
                                &m_VideoCallbacks, &m_AudioCallbacks,
                                NULL, 0, NULL, 0);
    if (err != 0) {
        // We already displayed an error dialog in the stage failure
        // listener.
        return false;
    }
```
## Q3
how to get "Remote input encryption keys"
### Answer
You're asking about how Moonlight generates the "Remote input encryption keys" that are sent to the host server during the `/launch` request.

## Answer

The remote input encryption keys (`rikey` and `rikeyid`) are randomly generated AES encryption keys used to secure input data sent from the client to the host during streaming. moonlight-qt:692-696 

### Key Generation

During session initialization in `Session::initialize()`, Moonlight generates these keys using OpenSSL's cryptographically secure random number generator:

```cpp
RAND_bytes(reinterpret_cast<unsigned char*>(m_StreamConfig.remoteInputAesKey),
           sizeof(m_StreamConfig.remoteInputAesKey));

// Only the first 4 bytes are populated in the RI key IV
RAND_bytes(reinterpret_cast<unsigned char*>(m_StreamConfig.remoteInputAesIv), 4);
``` moonlight-qt:692-696 

The `remoteInputAesKey` is a full AES key (16 bytes), while `remoteInputAesIv` only uses the first 4 bytes as an initialization vector. moonlight-qt:692-696 

### Sending Keys to Host

These generated keys are then sent to the host server when calling the `/launch` endpoint in `NvHTTP::startApp()`. moonlight-qt:200-218  The method:

1. Extracts the key ID from the IV by reading the first 4 bytes as a big-endian integer moonlight-qt:200-203 
2. Converts the AES key to hexadecimal format using `QByteArray(...).toHex()` moonlight-qt:217-217 
3. Includes both values as query parameters: `rikey=<hex_key>&rikeyid=<key_id>` moonlight-qt:217-218 

### Security Considerations

For security, these keys are automatically redacted from log files to prevent exposure. moonlight-qt:108-110  The logging system uses regex patterns to strip `rikey` and `rikeyid` values before writing to logs. moonlight-qt:88-88 

## Notes

The remote input encryption is part of Moonlight's security features to protect input data (keyboard, mouse, gamepad) transmitted during streaming. The keys are generated fresh for each streaming session and are stored in the `STREAM_CONFIGURATION` structure (`m_StreamConfig`) which is later passed to `LiStartConnection()` to establish the connection. moonlight-qt:1584-1593 

Wiki pages you might want to explore:
- [PC Discovery View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.1)
### Citations
**File:** app/streaming/session.cpp (L692-696)
```cpp
    RAND_bytes(reinterpret_cast<unsigned char*>(m_StreamConfig.remoteInputAesKey),
               sizeof(m_StreamConfig.remoteInputAesKey));

    // Only the first 4 bytes are populated in the RI key IV
    RAND_bytes(reinterpret_cast<unsigned char*>(m_StreamConfig.remoteInputAesIv), 4);
```
**File:** app/streaming/session.cpp (L1584-1593)
```cpp
    try {
        NvHTTP http(m_Computer);
        http.startApp(m_Computer->currentGameId != 0 ? "resume" : "launch",
                      m_Computer->isNvidiaServerSoftware,
                      m_App.id, &m_StreamConfig,
                      enableGameOptimizations,
                      m_Preferences->playAudioOnHost,
                      m_InputHandler->getAttachedGamepadMask(),
                      !m_Preferences->multiController,
                      rtspSessionUrl);
```
**File:** app/backend/nvhttp.cpp (L200-218)
```cpp
    int riKeyId;

    memcpy(&riKeyId, streamConfig->remoteInputAesIv, sizeof(riKeyId));
    riKeyId = qFromBigEndian(riKeyId);

    QString response =
            openConnectionToString(m_BaseUrlHttps,
                                   verb,
                                   "appid="+QString::number(appId)+
                                   "&mode="+QString::number(streamConfig->width)+"x"+
                                   QString::number(streamConfig->height)+"x"+
                                   // Using an FPS value over 60 causes SOPS to default to 720p60,
                                   // so force it to 0 to ensure the correct resolution is set. We
                                   // used to use 60 here but that locked the frame rate to 60 FPS
                                   // on GFE 3.20.3. We don't need this hack for Sunshine.
                                   QString::number((streamConfig->fps > 60 && isGfe) ? 0 : streamConfig->fps)+
                                   "&additionalStates=1&sops="+QString::number(sops ? 1 : 0)+
                                   "&rikey="+QByteArray(streamConfig->remoteInputAesKey, sizeof(streamConfig->remoteInputAesKey)).toHex()+
                                   "&rikeyid="+QString::number(riKeyId)+
```
**File:** app/main.cpp (L108-110)
```cpp
    // Strip session encryption keys and IVs from the logs
    message.replace(k_RikeyRegex, "&rikey=REDACTED");
    message.replace(k_RikeyIdRegex, "&rikeyid=REDACTED");
```
**File:** app/deploy/linux/com.moonlight_stream.Moonlight.appdata.xml (L88-88)
```text
					<li>Per-session keys (rikey and rikeyid values) are now automatically stripped from logs</li>
```
## Q4
<?xml version="1.0" encoding="utf-8"?>
<root status_code="200">
  <hostname>Html5syt</hostname>
  <appversion>7.1.431.-1</appversion>
<GfeVersion>3.23.0.74</GfeVersion>
  <uniqueid>F98186B1-DE02-2328-279E-0A461FBCEC47</uniqueid>
  <HttpsPort>47984</HttpsPort>
  <ExternalPort>47989</ExternalPort>
<MaxLumaPixelsHEVC>1869449984</MaxLumaPixelsHEVC>
  <mac>00:00:00:00:00:00</mac>
  <LocalIP>127.0.0.1</LocalIP>
  <ServerCodecModeSupport>257</ServerCodecModeSupport>
<PairStatus>0</PairStatus>
  <currentgame>1191261554</currentgame>
  <state>SUNSHINE_SERVER_BUSY</state>
</root>
This is a response from a serverinfo, please tell me which parameters are used to establish the connection in it?
### Answer
You're asking which parameters from the `/serverinfo` XML response are used when establishing a streaming connection in Moonlight.

## Answer

From the `/serverinfo` response you provided, the following parameters are used to establish the streaming connection:

### Parameters Used in Connection Establishment

**`ServerCodecModeSupport` (value: 257)** - This is stored in the `NvComputer` object and later passed to `LiStartConnection()` via the `SERVER_INFORMATION` structure. moonlight-qt:1608-1608  It indicates which video codecs and formats the host supports, and is used to negotiate the video format during connection setup. moonlight-qt:1608-1608 

**`appversion` (value: 7.1.431.-1)** - This is stored as `m_Computer->appVersion` and passed to `LiStartConnection()` as `hostInfo.serverInfoAppVersion`. moonlight-qt:1603-1607  The connection library uses this to determine host capabilities and compatibility. moonlight-qt:1603-1607 

**`GfeVersion` (value: 3.23.0.74)** - This is stored as `m_Computer->gfeVersion` and passed to `LiStartConnection()` as `hostInfo.serverInfoGfeVersion`. moonlight-qt:1611-1617  It's used to determine if the host is running GFE or Sunshine and adjust behavior accordingly. moonlight-qt:1560-1580 

**`LocalIP` (value: 127.0.0.1)** - The host's address is used to construct the base URLs for HTTP/HTTPS communication and is passed to `LiStartConnection()` as `hostInfo.address`. moonlight-qt:1602-1606 

**`HttpsPort` (value: 47984)** - Used to construct the HTTPS base URL for secure communication with the host, including the `/launch` endpoint call. moonlight-qt:173-177 

### Parameters NOT Directly Used in Connection

The following parameters are informational but not directly passed to the connection function:

- `hostname`, `uniqueid`, `ExternalPort`, `MaxLumaPixelsHEVC`, `mac` - These are stored in the `NvComputer` object for display and management purposes but aren't passed to `LiStartConnection()`.<cite />
- `PairStatus` - Used to determine if pairing is needed before streaming, but not used during connection establishment.<cite />
- `currentgame` and `state` - Used to determine if the host is already streaming, which affects whether to call `/launch` or `/resume`. moonlight-qt:1586-1586 

## Notes

The `state` value "SUNSHINE_SERVER_BUSY" indicates the host is currently streaming (as confirmed by the non-zero `currentgame` value). moonlight-qt:112-116  In this case, Moonlight would call `/resume` instead of `/launch` if you're trying to connect to the same game. moonlight-qt:1586-1586  The `ServerCodecModeSupport` value of 257 indicates support for H.264 (bit 0) and H.265/HEVC (bit 8).<cite />

Wiki pages you might want to explore:
- [PC Discovery View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.1)
### Citations
**File:** app/streaming/session.cpp (L1560-1580)
```cpp
    if (m_Computer->isNvidiaServerSoftware) {
        // GFE will set all settings to 720p60 if it doesn't recognize
        // the chosen resolution. Avoid that by disabling SOPS when it
        // is not streaming a supported resolution.
        enableGameOptimizations = false;
        for (const NvDisplayMode &mode : m_Computer->displayModes) {
            if (mode.width == m_StreamConfig.width &&
                    mode.height == m_StreamConfig.height) {
                SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION,
                            "Found host supported resolution: %dx%d",
                            mode.width, mode.height);
                enableGameOptimizations = m_Preferences->gameOptimizations;
                break;
            }
        }
    }
    else {
        // Always send SOPS to Sunshine because we may repurpose the
        // option to control whether the display mode is adjusted
        enableGameOptimizations = m_Preferences->gameOptimizations;
    }
```
**File:** app/streaming/session.cpp (L1586-1586)
```cpp
        http.startApp(m_Computer->currentGameId != 0 ? "resume" : "launch",
```
**File:** app/streaming/session.cpp (L1602-1607)
```cpp
    QByteArray hostnameStr = m_Computer->activeAddress.address().toLatin1();
    QByteArray siAppVersion = m_Computer->appVersion.toLatin1();

    SERVER_INFORMATION hostInfo;
    hostInfo.address = hostnameStr.data();
    hostInfo.serverInfoAppVersion = siAppVersion.data();
```
**File:** app/streaming/session.cpp (L1608-1608)
```cpp
    hostInfo.serverCodecModeSupport = m_Computer->serverCodecModeSupport;
```
**File:** app/streaming/session.cpp (L1611-1617)
```cpp
    QByteArray siGfeVersion;
    if (!m_Computer->gfeVersion.isEmpty()) {
        siGfeVersion = m_Computer->gfeVersion.toLatin1();
    }
    if (!siGfeVersion.isEmpty()) {
        hostInfo.serverInfoGfeVersion = siGfeVersion.data();
    }
```
**File:** app/backend/nvhttp.cpp (L112-116)
```cpp
    QString serverState = getXmlString(serverInfo, "state");
    if (serverState != nullptr && serverState.endsWith("_SERVER_BUSY"))
    {
        return getXmlString(serverInfo, "currentgame").toInt();
    }
```
**File:** app/backend/nvhttp.cpp (L173-177)
```cpp
        uint16_t httpsPort = getXmlString(serverInfo, "HttpsPort").toUShort();
        if (httpsPort == 0) {
            httpsPort = DEFAULT_HTTPS_PORT;
        }
        setHttpsPort(httpsPort);
```
## Q5
When I call the /launch interface, the server requires me to provide a client certificate. How can I obtain this certificate?
### Answer
Moonlight obtains and provides client certificates through a multi-step process involving certificate generation, pairing, and SSL configuration:

## Client Certificate Generation

When Moonlight first launches, the `IdentityManager` class automatically generates a self-signed 2048-bit RSA certificate and private key pair if none exist. moonlight-qt:29-110 

These credentials are stored persistently in QSettings and cached in memory for reuse. moonlight-qt:112-139 

## Attaching Certificates to Requests

For every HTTPS request (including `/launch`), Moonlight attaches the client certificate through the `IdentityManager::getSslConfig()` method, which returns a `QSslConfiguration` containing both the client certificate and private key. moonlight-qt:184-191 

This SSL configuration is applied to all network requests in the `openConnection` method via `request.setSslConfiguration()`. moonlight-qt:486-489 

## The `/launch` Interface Specifically

When the `startApp` method is called to launch a game, it makes an HTTPS request to the `/launch` endpoint using the base HTTPS URL. moonlight-qt:205-228 

This request goes through `openConnection`, which automatically includes the client certificate for mutual TLS authentication with the host server.

## Pairing Process for Mutual Trust

Before the client certificate can be used for authentication, a pairing process must occur. During pairing, the client sends its certificate to the server and receives the server's certificate in return. moonlight-qt:217-248 

The server certificate is then pinned and stored in the `NvComputer` object for future SSL validation. moonlight-qt:419-439 

## Certificate Validation

If there's an SSL handshake failure or certificate mismatch (error 401), Moonlight falls back to HTTP and can re-initiate pairing to obtain updated certificates. moonlight-qt:143-160 

## Notes

- The client certificate uses a common name of "NVIDIA GameStream Client" moonlight-qt:70-74 
- The certificate has a 20-year validity period moonlight-qt:51-66 
- The `/launch` endpoint uses a 120-second timeout compared to the standard 5-second timeout for other requests moonlight-qt:15-19 
- Certificate pinning prevents man-in-the-middle attacks by ensuring SSL errors are only ignored if they match the previously paired server certificate moonlight-qt:429-434
### Citations
**File:** app/backend/identitymanager.cpp (L29-110)
```cpp
void IdentityManager::createCredentials(QSettings& settings)
{
    X509* cert = X509_new();
    THROW_BAD_ALLOC_IF_NULL(cert);

    EVP_PKEY_CTX* ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_RSA, NULL);
    THROW_BAD_ALLOC_IF_NULL(ctx);

    EVP_PKEY_keygen_init(ctx);
    EVP_PKEY_CTX_set_rsa_keygen_bits(ctx, 2048);

    // pk must be initialized on input
    EVP_PKEY* pk = NULL;
    EVP_PKEY_keygen(ctx, &pk);

    EVP_PKEY_CTX_free(ctx);
    THROW_BAD_ALLOC_IF_NULL(pk);

    X509_set_version(cert, 2);
    ASN1_INTEGER_set(X509_get_serialNumber(cert), 0);
#if OPENSSL_VERSION_NUMBER < 0x10100000L
    X509_gmtime_adj(X509_get_notBefore(cert), 0);
    X509_gmtime_adj(X509_get_notAfter(cert), 60 * 60 * 24 * 365 * 20); // 20 yrs
#else
    ASN1_TIME* before = ASN1_STRING_dup(X509_get0_notBefore(cert));
    THROW_BAD_ALLOC_IF_NULL(before);
    ASN1_TIME* after = ASN1_STRING_dup(X509_get0_notAfter(cert));
    THROW_BAD_ALLOC_IF_NULL(after);

    X509_gmtime_adj(before, 0);
    X509_gmtime_adj(after, 60 * 60 * 24 * 365 * 20); // 20 yrs

    X509_set1_notBefore(cert, before);
    X509_set1_notAfter(cert, after);

    ASN1_STRING_free(before);
    ASN1_STRING_free(after);
#endif

    X509_set_pubkey(cert, pk);

    X509_NAME* name = X509_get_subject_name(cert);
    X509_NAME_add_entry_by_txt(name, "CN", MBSTRING_ASC,
                               reinterpret_cast<unsigned char *>(const_cast<char*>("NVIDIA GameStream Client")),
                               -1, -1, 0);
    X509_set_issuer_name(cert, name);

    X509_sign(cert, pk, EVP_sha256());

    BIO* biokey = BIO_new(BIO_s_mem());
    THROW_BAD_ALLOC_IF_NULL(biokey);
    PEM_write_bio_PrivateKey(biokey, pk, NULL, NULL, 0, NULL, NULL);

    BIO* biocert = BIO_new(BIO_s_mem());
    THROW_BAD_ALLOC_IF_NULL(biocert);
    PEM_write_bio_X509(biocert, cert);

    BUF_MEM* mem;
    BIO_get_mem_ptr(biokey, &mem);
    m_CachedPrivateKey = QByteArray(mem->data, (int)mem->length);

    BIO_get_mem_ptr(biocert, &mem);
    m_CachedPemCert = QByteArray(mem->data, (int)mem->length);

    X509_free(cert);
    EVP_PKEY_free(pk);
    BIO_free(biokey);
    BIO_free(biocert);

    // Check that the new keypair is valid before persisting it
    if (getSslCertificate().isNull()) {
        qFatal("Newly generated certificate is unreadable");
    }
    if (getSslKey().isNull()) {
        qFatal("Newly generated private key is unreadable");
    }

    settings.setValue(SER_CERT, m_CachedPemCert);
    settings.setValue(SER_KEY, m_CachedPrivateKey);

    qInfo() << "Wrote new identity credentials to settings";
}
```
**File:** app/backend/identitymanager.cpp (L112-139)
```cpp
IdentityManager::IdentityManager()
{
    QSettings settings;

    m_CachedPemCert = settings.value(SER_CERT).toByteArray();
    m_CachedPrivateKey = settings.value(SER_KEY).toByteArray();

    if (m_CachedPemCert.isEmpty() || m_CachedPrivateKey.isEmpty()) {
        qInfo() << "No existing credentials found";
        createCredentials(settings);
    }
    else if (getSslCertificate().isNull()) {
        qWarning() << "Certificate is unreadable";
        createCredentials(settings);
    }
    else if (getSslKey().isNull()) {
        qWarning() << "Private key is unreadable";
        createCredentials(settings);
    }

    // We should have valid credentials now. If not, we're screwed
    if (getSslCertificate().isNull()) {
        qFatal("Certificate is unreadable");
    }
    if (getSslKey().isNull()) {
        qFatal("Private key is unreadable");
    }
}
```
**File:** app/backend/identitymanager.cpp (L184-191)
```cpp
QSslConfiguration
IdentityManager::getSslConfig()
{
    QSslConfiguration sslConfig(QSslConfiguration::defaultConfiguration());
    sslConfig.setLocalCertificate(getSslCertificate());
    sslConfig.setPrivateKey(getSslKey());
    return sslConfig;
}
```
**File:** app/backend/nvhttp.cpp (L15-19)
```cpp
#define FAST_FAIL_TIMEOUT_MS 2000
#define REQUEST_TIMEOUT_MS 5000
#define LAUNCH_TIMEOUT_MS 120000
#define RESUME_TIMEOUT_MS 30000
#define QUIT_TIMEOUT_MS 30000
```
**File:** app/backend/nvhttp.cpp (L143-160)
```cpp
        catch (const GfeHttpResponseException& e)
        {
            if (e.getStatusCode() == 401)
            {
                // Certificate validation error, fallback to HTTP
                serverInfo = openConnectionToString(m_BaseUrlHttp,
                                                    "serverinfo",
                                                    nullptr,
                                                    fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                                    logLevel);
                verifyResponseStatus(serverInfo);
            }
            else
            {
                // Rethrow real errors
                throw e;
            }
        }
```
**File:** app/backend/nvhttp.cpp (L205-228)
```cpp
    QString response =
            openConnectionToString(m_BaseUrlHttps,
                                   verb,
                                   "appid="+QString::number(appId)+
                                   "&mode="+QString::number(streamConfig->width)+"x"+
                                   QString::number(streamConfig->height)+"x"+
                                   // Using an FPS value over 60 causes SOPS to default to 720p60,
                                   // so force it to 0 to ensure the correct resolution is set. We
                                   // used to use 60 here but that locked the frame rate to 60 FPS
                                   // on GFE 3.20.3. We don't need this hack for Sunshine.
                                   QString::number((streamConfig->fps > 60 && isGfe) ? 0 : streamConfig->fps)+
                                   "&additionalStates=1&sops="+QString::number(sops ? 1 : 0)+
                                   "&rikey="+QByteArray(streamConfig->remoteInputAesKey, sizeof(streamConfig->remoteInputAesKey)).toHex()+
                                   "&rikeyid="+QString::number(riKeyId)+
                                   ((streamConfig->supportedVideoFormats & VIDEO_FORMAT_MASK_10BIT) ?
                                       "&hdrMode=1&clientHdrCapVersion=0&clientHdrCapSupportedFlagsInUint32=0&clientHdrCapMetaDataId=NV_STATIC_METADATA_TYPE_1&clientHdrCapDisplayData=0x0x0x0x0x0x0x0x0x0x0" :
                                        "")+
                                   "&localAudioPlayMode="+QString::number(localAudio ? 1 : 0)+
                                   "&surroundAudioInfo="+QString::number(SURROUNDAUDIOINFO_FROM_AUDIO_CONFIGURATION(streamConfig->audioConfiguration))+
                                   "&remoteControllersBitmap="+QString::number(gamepadMask)+
                                   "&gcmap="+QString::number(gamepadMask)+
                                   "&gcpersist="+QString::number(persistGameControllersOnDisconnect ? 1 : 0)+
                                   LiGetLaunchUrlQueryParameters(),
                                   LAUNCH_TIMEOUT_MS);
```
**File:** app/backend/nvhttp.cpp (L419-439)
```cpp
void NvHTTP::handleSslErrors(QNetworkReply* reply, const QList<QSslError>& errors)
{
    bool ignoreErrors = true;

    if (m_ServerCert.isNull()) {
        // We should never make an HTTPS request without a cert
        Q_ASSERT(!m_ServerCert.isNull());
        return;
    }

    for (const QSslError& error : errors) {
        if (m_ServerCert != error.certificate()) {
            ignoreErrors = false;
            break;
        }
    }

    if (ignoreErrors) {
        reply->ignoreSslErrors(errors);
    }
}
```
**File:** app/backend/nvhttp.cpp (L486-489)
```cpp
    QNetworkRequest request(url);

    // Add our client certificate
    request.setSslConfiguration(IdentityManager::get()->getSslConfig());
```
**File:** app/backend/nvpairingmanager.cpp (L217-248)
```cpp
    QString getCert = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&phrase=getservercert&salt=" +
                                                    salt.toHex() + "&clientcert=" + IdentityManager::get()->getCertificate().toHex(),
                                                    0);
    NvHTTP::verifyResponseStatus(getCert);
    if (NvHTTP::getXmlString(getCert, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #1";
        return PairState::FAILED;
    }

    QByteArray serverCertStr = NvHTTP::getXmlStringFromHex(getCert, "plaincert");
    if (serverCertStr == nullptr)
    {
        qCritical() << "Server likely already pairing";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::ALREADY_IN_PROGRESS;
    }

    QSslCertificate unverifiedServerCert = QSslCertificate(serverCertStr);
    if (unverifiedServerCert.isNull()) {
        Q_ASSERT(!unverifiedServerCert.isNull());

        qCritical() << "Failed to parse plaincert";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    // Pin this cert for TLS until pairing is complete. If successful, we will propagate
    // the cert into the NvComputer object and persist it.
    m_Http.setServerCert(unverifiedServerCert);
```
## Q6
How to pair up computer?
### Answer
The pairing process in Moonlight uses a 5-phase handshake protocol to securely exchange certificates between the client and server. Here's how it works:

## Client Certificate Generation and Storage

The client certificate is a self-signed X.509 certificate that is generated when Moonlight first runs. It uses a 2048-bit RSA key pair with SHA-256 signature and has a 20-year validity period. moonlight-qt:29-110 

The certificate and private key are stored in QSettings and cached in memory for subsequent use. moonlight-qt:112-139 

## The 5-Phase Pairing Process

The pairing process is implemented in the `NvPairingManager::pair()` method: moonlight-qt:191-354 

### Phase 1: Certificate Exchange

The client sends its certificate to the server as a hex-encoded string in the `clientcert` parameter of an HTTP request. At the same time, it receives the server's certificate in the response: moonlight-qt:217-227 

The server returns its certificate in the `plaincert` field of the XML response: moonlight-qt:229-244 

### Phase 2-5: Challenge-Response Authentication

Once the server certificate is received, it is immediately pinned to the HTTP client for all subsequent HTTPS requests: moonlight-qt:246-248 

The remaining phases involve encrypted challenge-response exchanges and signature verification to authenticate both parties and validate the PIN.

## Certificate Pinning

The `setServerCert()` method stores the server certificate for use in HTTPS connections: moonlight-qt:43-46 

During HTTPS connections, the `handleSslErrors()` method verifies that the server certificate matches the pinned certificate, preventing man-in-the-middle attacks: moonlight-qt:419-439 

## Persisting the Server Certificate

After successful pairing, the server certificate is stored in the `NvComputer` object: moonlight-qt:113-113 

The certificate is then persisted to settings by calling `saveHost()`: moonlight-qt:599-603 

## Notes

The pairing process uses AES-128-ECB encryption for challenge exchanges, with the encryption key derived from a salted PIN hash (SHA-256 for Gen 7+ servers, SHA-1 for older versions). The client certificate is sent as plain hex-encoded PEM data in Phase 1, while the server certificate is also returned as hex-encoded PEM. This certificate exchange happens over HTTP initially, but all subsequent pairing phases use HTTPS with the newly pinned certificate to ensure secure communication.
### Citations
**File:** app/backend/identitymanager.cpp (L29-110)
```cpp
void IdentityManager::createCredentials(QSettings& settings)
{
    X509* cert = X509_new();
    THROW_BAD_ALLOC_IF_NULL(cert);

    EVP_PKEY_CTX* ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_RSA, NULL);
    THROW_BAD_ALLOC_IF_NULL(ctx);

    EVP_PKEY_keygen_init(ctx);
    EVP_PKEY_CTX_set_rsa_keygen_bits(ctx, 2048);

    // pk must be initialized on input
    EVP_PKEY* pk = NULL;
    EVP_PKEY_keygen(ctx, &pk);

    EVP_PKEY_CTX_free(ctx);
    THROW_BAD_ALLOC_IF_NULL(pk);

    X509_set_version(cert, 2);
    ASN1_INTEGER_set(X509_get_serialNumber(cert), 0);
#if OPENSSL_VERSION_NUMBER < 0x10100000L
    X509_gmtime_adj(X509_get_notBefore(cert), 0);
    X509_gmtime_adj(X509_get_notAfter(cert), 60 * 60 * 24 * 365 * 20); // 20 yrs
#else
    ASN1_TIME* before = ASN1_STRING_dup(X509_get0_notBefore(cert));
    THROW_BAD_ALLOC_IF_NULL(before);
    ASN1_TIME* after = ASN1_STRING_dup(X509_get0_notAfter(cert));
    THROW_BAD_ALLOC_IF_NULL(after);

    X509_gmtime_adj(before, 0);
    X509_gmtime_adj(after, 60 * 60 * 24 * 365 * 20); // 20 yrs

    X509_set1_notBefore(cert, before);
    X509_set1_notAfter(cert, after);

    ASN1_STRING_free(before);
    ASN1_STRING_free(after);
#endif

    X509_set_pubkey(cert, pk);

    X509_NAME* name = X509_get_subject_name(cert);
    X509_NAME_add_entry_by_txt(name, "CN", MBSTRING_ASC,
                               reinterpret_cast<unsigned char *>(const_cast<char*>("NVIDIA GameStream Client")),
                               -1, -1, 0);
    X509_set_issuer_name(cert, name);

    X509_sign(cert, pk, EVP_sha256());

    BIO* biokey = BIO_new(BIO_s_mem());
    THROW_BAD_ALLOC_IF_NULL(biokey);
    PEM_write_bio_PrivateKey(biokey, pk, NULL, NULL, 0, NULL, NULL);

    BIO* biocert = BIO_new(BIO_s_mem());
    THROW_BAD_ALLOC_IF_NULL(biocert);
    PEM_write_bio_X509(biocert, cert);

    BUF_MEM* mem;
    BIO_get_mem_ptr(biokey, &mem);
    m_CachedPrivateKey = QByteArray(mem->data, (int)mem->length);

    BIO_get_mem_ptr(biocert, &mem);
    m_CachedPemCert = QByteArray(mem->data, (int)mem->length);

    X509_free(cert);
    EVP_PKEY_free(pk);
    BIO_free(biokey);
    BIO_free(biocert);

    // Check that the new keypair is valid before persisting it
    if (getSslCertificate().isNull()) {
        qFatal("Newly generated certificate is unreadable");
    }
    if (getSslKey().isNull()) {
        qFatal("Newly generated private key is unreadable");
    }

    settings.setValue(SER_CERT, m_CachedPemCert);
    settings.setValue(SER_KEY, m_CachedPrivateKey);

    qInfo() << "Wrote new identity credentials to settings";
}
```
**File:** app/backend/identitymanager.cpp (L112-139)
```cpp
IdentityManager::IdentityManager()
{
    QSettings settings;

    m_CachedPemCert = settings.value(SER_CERT).toByteArray();
    m_CachedPrivateKey = settings.value(SER_KEY).toByteArray();

    if (m_CachedPemCert.isEmpty() || m_CachedPrivateKey.isEmpty()) {
        qInfo() << "No existing credentials found";
        createCredentials(settings);
    }
    else if (getSslCertificate().isNull()) {
        qWarning() << "Certificate is unreadable";
        createCredentials(settings);
    }
    else if (getSslKey().isNull()) {
        qWarning() << "Private key is unreadable";
        createCredentials(settings);
    }

    // We should have valid credentials now. If not, we're screwed
    if (getSslCertificate().isNull()) {
        qFatal("Certificate is unreadable");
    }
    if (getSslKey().isNull()) {
        qFatal("Private key is unreadable");
    }
}
```
**File:** app/backend/nvpairingmanager.cpp (L191-354)
```cpp
NvPairingManager::pair(QString appVersion, QString pin, QSslCertificate& serverCert)
{
    int serverMajorVersion = NvHTTP::parseQuad(appVersion).at(0);
    qInfo() << "Pairing with server generation:" << serverMajorVersion;

    QCryptographicHash::Algorithm hashAlgo;
    int hashLength;
    if (serverMajorVersion >= 7)
    {
        // Gen 7+ uses SHA-256 hashing
        hashAlgo = QCryptographicHash::Sha256;
        hashLength = 32;
    }
    else
    {
        // Prior to Gen 7 uses SHA-1 hashing
        hashAlgo = QCryptographicHash::Sha1;
        hashLength = 20;
    }

    QByteArray salt = generateRandomBytes(16);
    QByteArray saltedPin = saltPin(salt, pin);

    QByteArray aesKey = QCryptographicHash::hash(saltedPin, hashAlgo).constData();
    aesKey.truncate(16);

    QString getCert = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&phrase=getservercert&salt=" +
                                                    salt.toHex() + "&clientcert=" + IdentityManager::get()->getCertificate().toHex(),
                                                    0);
    NvHTTP::verifyResponseStatus(getCert);
    if (NvHTTP::getXmlString(getCert, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #1";
        return PairState::FAILED;
    }

    QByteArray serverCertStr = NvHTTP::getXmlStringFromHex(getCert, "plaincert");
    if (serverCertStr == nullptr)
    {
        qCritical() << "Server likely already pairing";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::ALREADY_IN_PROGRESS;
    }

    QSslCertificate unverifiedServerCert = QSslCertificate(serverCertStr);
    if (unverifiedServerCert.isNull()) {
        Q_ASSERT(!unverifiedServerCert.isNull());

        qCritical() << "Failed to parse plaincert";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    // Pin this cert for TLS until pairing is complete. If successful, we will propagate
    // the cert into the NvComputer object and persist it.
    m_Http.setServerCert(unverifiedServerCert);

    QByteArray randomChallenge = generateRandomBytes(16);
    QByteArray encryptedChallenge = encrypt(randomChallenge, aesKey);
    QString challengeXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                         "pair",
                                                         "devicename=roth&updateState=1&clientchallenge=" +
                                                         encryptedChallenge.toHex(),
                                                         REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(challengeXml);
    if (NvHTTP::getXmlString(challengeXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #2";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray challengeResponseData = decrypt(m_Http.getXmlStringFromHex(challengeXml, "challengeresponse"), aesKey);
    QByteArray clientSecretData = generateRandomBytes(16);
    QByteArray challengeResponse;
    QByteArray serverResponse(challengeResponseData.data(), hashLength);

#if (OPENSSL_VERSION_NUMBER < 0x10002000L)
    ASN1_BIT_STRING *asnSignature = m_Cert->signature;
#elif (OPENSSL_VERSION_NUMBER < 0x10100000L)
    ASN1_BIT_STRING *asnSignature;
    X509_get0_signature(&asnSignature, NULL, m_Cert);
#else
    const ASN1_BIT_STRING *asnSignature;
    X509_get0_signature(&asnSignature, NULL, m_Cert);
#endif

    challengeResponse.append(challengeResponseData.data() + hashLength, 16);
    challengeResponse.append(reinterpret_cast<char*>(asnSignature->data), asnSignature->length);
    challengeResponse.append(clientSecretData);

    QByteArray paddedHash = QCryptographicHash::hash(challengeResponse, hashAlgo);
    paddedHash.resize(32);
    QByteArray encryptedChallengeResponseHash = encrypt(paddedHash, aesKey);
    QString respXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&serverchallengeresp=" +
                                                    encryptedChallengeResponseHash.toHex(),
                                                    REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(respXml);
    if (NvHTTP::getXmlString(respXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #3";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray pairingSecret = NvHTTP::getXmlStringFromHex(respXml, "pairingsecret");
    QByteArray serverSecret = pairingSecret.left(16);
    QByteArray serverSignature = pairingSecret.mid(16);

    if (!verifySignature(serverSecret,
                         serverSignature,
                         serverCertStr))
    {
        qCritical() << "MITM detected";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray expectedResponseData;
    expectedResponseData.append(randomChallenge);
    expectedResponseData.append(getSignatureFromPemCert(serverCertStr));
    expectedResponseData.append(serverSecret);
    if (QCryptographicHash::hash(expectedResponseData, hashAlgo) != serverResponse)
    {
        qCritical() << "Incorrect PIN";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::PIN_WRONG;
    }

    QByteArray clientPairingSecret;
    clientPairingSecret.append(clientSecretData);
    clientPairingSecret.append(signMessage(clientSecretData));

    QString secretRespXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                          "pair",
                                                          "devicename=roth&updateState=1&clientpairingsecret=" +
                                                          clientPairingSecret.toHex(),
                                                          REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(secretRespXml);
    if (NvHTTP::getXmlString(secretRespXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #4";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QString pairChallengeXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttps,
                                                             "pair",
                                                             "devicename=roth&updateState=1&phrase=pairchallenge",
                                                             REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(pairChallengeXml);
    if (NvHTTP::getXmlString(pairChallengeXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #5";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    serverCert = std::move(unverifiedServerCert);
    return PairState::PAIRED;
```
**File:** app/backend/nvhttp.cpp (L43-46)
```cpp
void NvHTTP::setServerCert(QSslCertificate serverCert)
{
    m_ServerCert = serverCert;
}
```
**File:** app/backend/nvhttp.cpp (L419-439)
```cpp
void NvHTTP::handleSslErrors(QNetworkReply* reply, const QList<QSslError>& errors)
{
    bool ignoreErrors = true;

    if (m_ServerCert.isNull()) {
        // We should never make an HTTPS request without a cert
        Q_ASSERT(!m_ServerCert.isNull());
        return;
    }

    for (const QSslError& error : errors) {
        if (m_ServerCert != error.certificate()) {
            ignoreErrors = false;
            break;
        }
    }

    if (ignoreErrors) {
        reply->ignoreSslErrors(errors);
    }
}
```
**File:** app/backend/nvcomputer.h (L113-113)
```text
    QSslCertificate serverCert;
```
**File:** app/backend/computermanager.cpp (L599-603)
```cpp
           case NvPairingManager::PairState::PAIRED:
               // Persist the newly pinned server certificate for this host
               m_ComputerManager->saveHost(m_Computer);

               emit pairingCompleted(m_Computer, nullptr);
```
## Q7
When the client has launched/started the game and begun streaming before disconnecting, how does the client recover the connection?
### Answer
You're asking about how Moonlight handles connection recovery when a streaming session disconnects after it has already started.

## Answer

When a streaming session disconnects, Moonlight determines whether to call `/launch` or `/resume` based on the `currentgame` value from the host's `/serverinfo` response. moonlight-qt:1586-1586 

### Resume vs Launch Decision

In `Session::startConnectionAsync()`, the code checks if `m_Computer->currentgame` is non-zero (indicating a game is already running on the host): moonlight-qt:1556-1557 

If the game is already running, it calls `NvHTTP::startApp()` with the `"resume"` parameter instead of `"launch"`: moonlight-qt:1586-1593 

```cpp
http.startApp(m_Computer->currentgame != 0 ? "resume" : "launch",
              m_Computer->isNvidiaServerSoftware,
              m_App.id, &m_StreamConfig,
              enableGameOptimizations,
              m_Preferences->playAudioOnHost,
              m_InputHandler->getAttachedGamepadMask(),
              !m_Preferences->multiController,
              rtspSessionUrl);
```

### How Resume Works

The `/resume` endpoint tells the host to reconnect to an existing game session rather than starting a new one.<cite /> This preserves the game state and allows the client to rejoin the same streaming session.<cite />

The same connection establishment process follows after calling `/resume` - the RTSP session URL is obtained from the response and passed to `LiStartConnection()` to establish the streaming connection. moonlight-qt:1678-1680 

### State Detection

The host's state is tracked through periodic `/serverinfo` polling, which updates the `currentgame` field in the `NvComputer` object.<cite /> When the state shows `SUNSHINE_SERVER_BUSY` (as in your earlier example) with a non-zero `currentgame` value, Moonlight knows a game is already running and will use resume instead of launch.<cite />

## Notes

The resume functionality allows seamless reconnection to an existing game session without restarting the game on the host. This is particularly useful for temporary network interruptions or when the client application crashes but the host game continues running. The same certificate authentication and connection establishment process is used for both launch and resume operations.

Wiki pages you might want to explore:
- [User Interface System (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2)
- [Streaming Core (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#4)
### Citations
**File:** app/streaming/session.cpp (L1556-1557)
```cpp
    Q_ASSERT(m_Computer->currentGameId == 0 ||
             m_Computer->currentGameId == m_App.id);
```
**File:** app/streaming/session.cpp (L1586-1593)
```cpp
        http.startApp(m_Computer->currentGameId != 0 ? "resume" : "launch",
                      m_Computer->isNvidiaServerSoftware,
                      m_App.id, &m_StreamConfig,
                      enableGameOptimizations,
                      m_Preferences->playAudioOnHost,
                      m_InputHandler->getAttachedGamepadMask(),
                      !m_Preferences->multiController,
                      rtspSessionUrl);
```
**File:** app/streaming/session.cpp (L1678-1680)
```cpp
    int err = LiStartConnection(&hostInfo, &m_StreamConfig, &k_ConnCallbacks,
                                &m_VideoCallbacks, &m_AudioCallbacks,
                                NULL, 0, NULL, 0);
```
## Q8
How does the client terminate the connection?
### Answer
You're asking about how Moonlight terminates a streaming connection when the user wants to disconnect.

## Answer

Moonlight provides multiple ways to terminate a streaming connection:

### User-Initiated Disconnection

Users can disconnect from an active streaming session using keyboard shortcuts or gamepad button combinations. The UI displays a tip showing these options: **Ctrl+Alt+Shift+Q** for keyboard or **Start+Select+L1+R1** for gamepad. moonlight-qt:167-168 

### Connection Termination Flow

When a connection terminates, the `Session::clConnectionTerminated()` callback is invoked with an error code. moonlight-qt:98-155  This callback:

1. **Performs port testing** to diagnose connectivity issues if the termination was unexpected moonlight-qt:100-101 

2. **Determines if termination was graceful** - If the error code is `ML_ERROR_GRACEFUL_TERMINATION`, no error dialog is shown moonlight-qt:105-106 

3. **Displays error messages** for unexpected terminations (network issues, video encoding errors, etc.) moonlight-qt:108-144 

4. **Pushes a quit event** to the SDL event loop to exit the streaming session moonlight-qt:150-154 

### UI Cleanup After Termination

After the session ends, the `StreamSegue::sessionFinished()` method handles cleanup: moonlight-qt:73-108 

1. **Re-enables gamepad navigation** for the UI moonlight-qt:79-80 

2. **Pops the stream view** from the navigation stack to return to the previous screen moonlight-qt:93-94 

3. **Shows the main window** again moonlight-qt:96-97 

4. **Displays any error dialogs** if the termination was unexpected moonlight-qt:103-106 

The session object is then garbage collected to free resources. moonlight-qt:110-116 

### Quitting Running Apps

Moonlight can also terminate a running game on the host without streaming it. The `ComputerManager::quitRunningApp()` method creates a `PendingQuitTask` that sends a quit request to the host server. moonlight-qt:675-682  This is used when users want to stop a game remotely without connecting to it.

## Notes

The termination process distinguishes between graceful disconnections (user-initiated) and unexpected terminations (network errors, encoding failures). For unexpected terminations, Moonlight performs network diagnostics and displays helpful error messages to guide troubleshooting. The same cleanup process applies whether the user disconnects manually or the connection fails unexpectedly.

Wiki pages you might want to explore:
- [User Interface System (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2)
- [PC Discovery View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.1)
### Citations
**File:** app/gui/StreamSegue.qml (L73-108)
```text
    function sessionFinished(portTestResult)
    {
        if (portTestResult !== 0 && portTestResult !== -1 && streamSegueErrorDialog.text) {
            streamSegueErrorDialog.text += "\n\n" + qsTr("This PC's Internet connection is blocking Moonlight. Streaming over the Internet may not work while connected to this network.")
        }

        // Re-enable GUI gamepad usage now
        SdlGamepadKeyNavigation.enable()

        if (quitAfter) {
            if (streamSegueErrorDialog.text) {
                // Quit when the error dialog is acknowledged
                streamSegueErrorDialog.quitAfter = quitAfter
                streamSegueErrorDialog.open()
            }
            else {
                // Quit immediately
                Qt.quit()
            }
        } else {
            // Exit this view
            stackView.pop()

            // Show the Qt window again after streaming
            window.visible = true

            // Display any launch errors. We do this after
            // the Qt UI is visible again to prevent losing
            // focus on the dialog which would impact gamepad
            // users.
            if (streamSegueErrorDialog.text) {
                streamSegueErrorDialog.quitAfter = quitAfter
                streamSegueErrorDialog.open()
            }
        }
    }
```
**File:** app/gui/StreamSegue.qml (L110-116)
```text
    function sessionReadyForDeletion()
    {
        // Garbage collect the Session object since it's pretty heavyweight
        // and keeps other libraries (like SDL_TTF) around until it is deleted.
        session = null
        gc()
    }
```
**File:** app/gui/StreamSegue.qml (L167-168)
```text
            hintText.text = qsTr("Tip:") + " " + qsTr("Press %1 to disconnect your session").arg(SdlGamepadKeyNavigation.getConnectedGamepads() > 0 ?
                                                  qsTr("Start+Select+L1+R1") : qsTr("Ctrl+Alt+Shift+Q"))
```
**File:** app/streaming/session.cpp (L98-155)
```cpp
void Session::clConnectionTerminated(int errorCode)
{
    unsigned int portFlags = LiGetPortFlagsFromTerminationErrorCode(errorCode);
    s_ActiveSession->m_PortTestResults = LiTestClientConnectivity(CONN_TEST_SERVER, 443, portFlags);

    // Display the termination dialog if this was not intended
    switch (errorCode) {
    case ML_ERROR_GRACEFUL_TERMINATION:
        break;

    case ML_ERROR_NO_VIDEO_TRAFFIC:
        s_ActiveSession->m_UnexpectedTermination = true;

        char ports[128];
        SDL_assert(portFlags != 0);
        LiStringifyPortFlags(portFlags, ", ", ports, sizeof(ports));
        emit s_ActiveSession->displayLaunchError(tr("No video received from host.") + "\n\n"+
                                                 tr("Check your firewall and port forwarding rules for port(s): %1").arg(ports));
        break;

    case ML_ERROR_NO_VIDEO_FRAME:
        s_ActiveSession->m_UnexpectedTermination = true;
        emit s_ActiveSession->displayLaunchError(tr("Your network connection isn't performing well. Reduce your video bitrate setting or try a faster connection."));
        break;

    case ML_ERROR_PROTECTED_CONTENT:
    case ML_ERROR_UNEXPECTED_EARLY_TERMINATION:
        s_ActiveSession->m_UnexpectedTermination = true;
        emit s_ActiveSession->displayLaunchError(tr("Something went wrong on your host PC when starting the stream.") + "\n\n" +
                                                 tr("Make sure you don't have any DRM-protected content open on your host PC. You can also try restarting your host PC."));
        break;

    case ML_ERROR_FRAME_CONVERSION:
        s_ActiveSession->m_UnexpectedTermination = true;
        emit s_ActiveSession->displayLaunchError(tr("The host PC reported a fatal video encoding error.") + "\n\n" +
                                                 tr("Try disabling HDR mode, changing the streaming resolution, or changing your host PC's display resolution."));
        break;

    default:
        s_ActiveSession->m_UnexpectedTermination = true;

        // We'll assume large errors are hex values
        bool hexError = qAbs(errorCode) > 1000;
        emit s_ActiveSession->displayLaunchError(tr("Connection terminated") + "\n\n" +
                                                 tr("Error code: %1").arg(errorCode, hexError ? 8 : 0, hexError ? 16 : 10, QChar('0')));
        break;
    }

    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION,
                 "Connection terminated: %d",
                 errorCode);

    // Push a quit event to the main loop
    SDL_Event event;
    event.type = SDL_QUIT;
    event.quit.timestamp = SDL_GetTicks();
    SDL_PushEvent(&event);
}
```
**File:** app/backend/computermanager.cpp (L675-682)
```cpp
void ComputerManager::quitRunningApp(NvComputer* computer)
{
    QWriteLocker lock(&computer->lock);
    computer->pendingQuit = true;

    PendingQuitTask* quit = new PendingQuitTask(this, computer);
    QThreadPool::globalInstance()->start(quit);
}
```
## Q9
Please list all the APIs used for the client and server interaction, including their purposes and required parameters, and list the APIs needed for the entire process from adding a computer to selecting one in the app list and starting a connection to ending the connection.
### Answer
Based on my analysis of the Moonlight codebase, here are all the client-server interaction APIs used throughout the entire process:

## 1. **Adding a Computer**

### Server Discovery - `serverinfo` API
**Purpose**: Discover and retrieve information about the host PC, including pairing status, current game, server version, and HTTPS port. moonlight-qt:124-187 

**Required Parameters**:
- `uniqueid`: Common UID for Moonlight clients (fixed: "0123456789ABCDEF")
- `uuid`: Random UUID for the request

**Protocol**: HTTP initially (before pairing), then HTTPS (after pairing)

### Pairing - 5-Phase Cryptographic Handshake

**Purpose**: Establish trust between client and host PC through certificate exchange and PIN verification. moonlight-qt:191-355 

**Phase 1 - Get Server Certificate**:
- Endpoint: `pair`
- Parameters:
  - `devicename=roth`
  - `updateState=1`
  - `phrase=getservercert`
  - `salt`: 16-byte random salt (hex)
  - `clientcert`: Client certificate (hex)

**Phase 2 - Client Challenge**:
- Endpoint: `pair`
- Parameters:
  - `devicename=roth`
  - `updateState=1`
  - `clientchallenge`: Encrypted 16-byte challenge (hex)

**Phase 3 - Server Challenge Response**:
- Endpoint: `pair`
- Parameters:
  - `devicename=roth`
  - `updateState=1`
  - `serverchallengeresp`: Encrypted challenge response hash (hex)

**Phase 4 - Client Pairing Secret**:
- Endpoint: `pair`
- Parameters:
  - `devicename=roth`
  - `updateState=1`
  - `clientpairingsecret`: Client secret + signature (hex)

**Phase 5 - Final Challenge (HTTPS)**:
- Endpoint: `pair`
- Parameters:
  - `devicename=roth`
  - `updateState=1`
  - `phrase=pairchallenge`

**Protocol**: HTTP for phases 1-4, HTTPS for phase 5

## 2. **Selecting an App**

### App List - `applist` API
**Purpose**: Retrieve the list of available applications on the host PC. moonlight-qt:288-328 

**Required Parameters**:
- `uniqueid`: "0123456789ABCDEF"
- `uuid`: Random UUID

**Protocol**: HTTPS (requires prior pairing)

**Response**: XML with app information including:
- `AppTitle`: Application name
- `ID`: Application ID
- `IsHdrSupported`: HDR capability
- `IsAppCollectorGame`: Whether it's an App Collector game

### Box Art - `getBoxArt` API
**Purpose**: Download application cover art/thumbnails. moonlight-qt:178-179 moonlight-qt:107-129 

**Required Parameters**:
- `appId`: Application ID

**Protocol**: HTTPS
**Response**: Image data (various formats, cached as PNG locally)

## 3. **Starting a Streaming Connection**

### Launch/Resume - `launch` or `resume` API
**Purpose**: Start a new streaming session or resume an existing one. moonlight-qt:190-236 moonlight-qt:1582-1600 

**Endpoint**: `launch` (new session) or `resume` (existing session)

**Required Parameters**:
- `uniqueid`: "0123456789ABCDEF"
- `uuid`: Random UUID
- `appid`: Application ID to launch
- `mode`: Resolution and FPS (format: `{width}x{height}x{fps}`)
- `additionalStates=1`: Enable additional states
- `sops`: Stream optimization settings (0 or 1)
- `rikey`: Remote input AES key (hex)
- `rikeyid`: Remote input key ID
- `hdrMode`: HDR mode flag (included if HDR supported)
- `clientHdrCapVersion`, `clientHdrCapSupportedFlagsInUint32`, `clientHdrCapMetaDataId`, `clientHdrCapDisplayData`: HDR capability parameters (if HDR mode)
- `localAudioPlayMode`: Play audio on host (0 or 1)
- `surroundAudioInfo`: Surround audio configuration
- `remoteControllersBitmap`: Gamepad mask
- `gcmap`: Gamepad controller map
- `gcpersist`: Persist game controllers on disconnect (0 or 1)
- Additional parameters from `LiGetLaunchUrlQueryParameters()`

**Protocol**: HTTPS

**Response**: XML containing `sessionUrl0` (RTSP session URL)

**Decision Logic**: The verb is determined based on whether a game is currently running: moonlight-qt:1586-1593 

## 4. **Ending a Streaming Connection**

### Quit App - `cancel` API
**Purpose**: Terminate the currently running application on the host PC. moonlight-qt:238-259 

**Required Parameters**:
- `uniqueid`: "0123456789ABCDEF"
- `uuid`: Random UUID

**Protocol**: HTTPS

**Timeout**: 30 seconds

**Note**: The quit operation is optional based on user preferences: moonlight-qt:1554-1558 

## Additional APIs

### Wake-on-LAN
**Purpose**: Wake up a sleeping/powered-off host PC. moonlight-qt:1-50 

**Protocol**: UDP magic packets sent to multiple addresses and ports (9, 47009, and dynamic ports 47998-48010)

### Unpair - `unpair` API
**Purpose**: Remove pairing relationship (used during pairing failures). moonlight-qt:232-234 

**Required Parameters**: Standard uniqueid and uuid

**Protocol**: HTTP

## Notes

- All HTTP/HTTPS requests use a common `uniqueid` of "0123456789ABCDEF" to allow Moonlight clients to manage each other's sessions
- Each request includes a random `uuid` parameter generated via `QUuid::createUuid()`
- Certificate pinning is implemented for HTTPS connections to prevent MITM attacks
- Timeouts vary by operation: 2s (fast-fail), 5s (normal), 30s (resume/quit), 120s (launch)
- The base URL format is `http(s)://{host}:{port}/{command}?{parameters}`
### Citations
**File:** app/backend/nvhttp.cpp (L124-187)
```cpp
NvHTTP::getServerInfo(NvLogLevel logLevel, bool fastFail)
{
    QString serverInfo;

    // Check if we have a pinned cert and HTTPS port for this host yet
    if (!m_ServerCert.isNull() && httpsPort() != 0)
    {
        try
        {
            // Always try HTTPS first, since it properly reports
            // pairing status (and a few other attributes).
            serverInfo = openConnectionToString(m_BaseUrlHttps,
                                                "serverinfo",
                                                nullptr,
                                                fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                                logLevel);
            // Throws if the request failed
            verifyResponseStatus(serverInfo);
        }
        catch (const GfeHttpResponseException& e)
        {
            if (e.getStatusCode() == 401)
            {
                // Certificate validation error, fallback to HTTP
                serverInfo = openConnectionToString(m_BaseUrlHttp,
                                                    "serverinfo",
                                                    nullptr,
                                                    fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                                    logLevel);
                verifyResponseStatus(serverInfo);
            }
            else
            {
                // Rethrow real errors
                throw e;
            }
        }
    }
    else
    {
        // Only use HTTP prior to pairing or fetching HTTPS port
        serverInfo = openConnectionToString(m_BaseUrlHttp,
                                            "serverinfo",
                                            nullptr,
                                            fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                            logLevel);
        verifyResponseStatus(serverInfo);

        // Populate the HTTPS port
        uint16_t httpsPort = getXmlString(serverInfo, "HttpsPort").toUShort();
        if (httpsPort == 0) {
            httpsPort = DEFAULT_HTTPS_PORT;
        }
        setHttpsPort(httpsPort);

        // If we just needed to determine the HTTPS port, we'll try again over
        // HTTPS now that we have the port number
        if (!m_ServerCert.isNull()) {
            return getServerInfo(logLevel, fastFail);
        }
    }

    return serverInfo;
}
```
**File:** app/backend/nvhttp.cpp (L190-236)
```cpp
NvHTTP::startApp(QString verb,
                 bool isGfe,
                 int appId,
                 PSTREAM_CONFIGURATION streamConfig,
                 bool sops,
                 bool localAudio,
                 int gamepadMask,
                 bool persistGameControllersOnDisconnect,
                 QString& rtspSessionUrl)
{
    int riKeyId;

    memcpy(&riKeyId, streamConfig->remoteInputAesIv, sizeof(riKeyId));
    riKeyId = qFromBigEndian(riKeyId);

    QString response =
            openConnectionToString(m_BaseUrlHttps,
                                   verb,
                                   "appid="+QString::number(appId)+
                                   "&mode="+QString::number(streamConfig->width)+"x"+
                                   QString::number(streamConfig->height)+"x"+
                                   // Using an FPS value over 60 causes SOPS to default to 720p60,
                                   // so force it to 0 to ensure the correct resolution is set. We
                                   // used to use 60 here but that locked the frame rate to 60 FPS
                                   // on GFE 3.20.3. We don't need this hack for Sunshine.
                                   QString::number((streamConfig->fps > 60 && isGfe) ? 0 : streamConfig->fps)+
                                   "&additionalStates=1&sops="+QString::number(sops ? 1 : 0)+
                                   "&rikey="+QByteArray(streamConfig->remoteInputAesKey, sizeof(streamConfig->remoteInputAesKey)).toHex()+
                                   "&rikeyid="+QString::number(riKeyId)+
                                   ((streamConfig->supportedVideoFormats & VIDEO_FORMAT_MASK_10BIT) ?
                                       "&hdrMode=1&clientHdrCapVersion=0&clientHdrCapSupportedFlagsInUint32=0&clientHdrCapMetaDataId=NV_STATIC_METADATA_TYPE_1&clientHdrCapDisplayData=0x0x0x0x0x0x0x0x0x0x0" :
                                        "")+
                                   "&localAudioPlayMode="+QString::number(localAudio ? 1 : 0)+
                                   "&surroundAudioInfo="+QString::number(SURROUNDAUDIOINFO_FROM_AUDIO_CONFIGURATION(streamConfig->audioConfiguration))+
                                   "&remoteControllersBitmap="+QString::number(gamepadMask)+
                                   "&gcmap="+QString::number(gamepadMask)+
                                   "&gcpersist="+QString::number(persistGameControllersOnDisconnect ? 1 : 0)+
                                   LiGetLaunchUrlQueryParameters(),
                                   LAUNCH_TIMEOUT_MS);

    qInfo() << "Launch response:" << response;

    // Throws if the request failed
    verifyResponseStatus(response);

    rtspSessionUrl = getXmlString(response, "sessionUrl0");
}
```
**File:** app/backend/nvhttp.cpp (L238-259)
```cpp
void
NvHTTP::quitApp()
{
    QString response =
            openConnectionToString(m_BaseUrlHttps,
                                   "cancel",
                                   nullptr,
                                   QUIT_TIMEOUT_MS);

    qInfo() << "Quit response:" << response;

    // Throws if the request failed
    verifyResponseStatus(response);

    // Newer GFE versions will just return success even if quitting fails
    // if we're not the original requester.
    if (getCurrentGame(getServerInfo(NvHTTP::NVLL_ERROR)) != 0) {
        // Generate a synthetic GfeResponseException letting the caller know
        // that they can't kill someone else's stream.
        throw GfeHttpResponseException(599, "");
    }
}
```
**File:** app/backend/nvhttp.cpp (L288-328)
```cpp
QVector<NvApp>
NvHTTP::getAppList()
{
    QString appxml = openConnectionToString(m_BaseUrlHttps,
                                            "applist",
                                            nullptr,
                                            REQUEST_TIMEOUT_MS,
                                            NvLogLevel::NVLL_ERROR);
    verifyResponseStatus(appxml);

    QXmlStreamReader xmlReader(appxml);
    QVector<NvApp> apps;
    while (!xmlReader.atEnd()) {
        while (xmlReader.readNextStartElement()) {
            auto name = xmlReader.name();
            if (name == QString("App")) {
                // We must have a valid app before advancing to the next one
                if (!apps.isEmpty() && !apps.last().isInitialized()) {
                    qWarning() << "Invalid applist XML";
                    Q_ASSERT(false);
                    return QVector<NvApp>();
                }
                apps.append(NvApp());
            }
            else if (name == QString("AppTitle")) {
                apps.last().name = xmlReader.readElementText();
            }
            else if (name == QString("ID")) {
                apps.last().id = xmlReader.readElementText().toInt();
            }
            else if (name == QString("IsHdrSupported")) {
                apps.last().hdrSupported = xmlReader.readElementText() == "1";
            }
            else if (name == QString("IsAppCollectorGame")) {
                apps.last().isAppCollectorGame = xmlReader.readElementText() == "1";
            }
        }
    }

    return apps;
}
```
**File:** app/backend/nvpairingmanager.cpp (L191-355)
```cpp
NvPairingManager::pair(QString appVersion, QString pin, QSslCertificate& serverCert)
{
    int serverMajorVersion = NvHTTP::parseQuad(appVersion).at(0);
    qInfo() << "Pairing with server generation:" << serverMajorVersion;

    QCryptographicHash::Algorithm hashAlgo;
    int hashLength;
    if (serverMajorVersion >= 7)
    {
        // Gen 7+ uses SHA-256 hashing
        hashAlgo = QCryptographicHash::Sha256;
        hashLength = 32;
    }
    else
    {
        // Prior to Gen 7 uses SHA-1 hashing
        hashAlgo = QCryptographicHash::Sha1;
        hashLength = 20;
    }

    QByteArray salt = generateRandomBytes(16);
    QByteArray saltedPin = saltPin(salt, pin);

    QByteArray aesKey = QCryptographicHash::hash(saltedPin, hashAlgo).constData();
    aesKey.truncate(16);

    QString getCert = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&phrase=getservercert&salt=" +
                                                    salt.toHex() + "&clientcert=" + IdentityManager::get()->getCertificate().toHex(),
                                                    0);
    NvHTTP::verifyResponseStatus(getCert);
    if (NvHTTP::getXmlString(getCert, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #1";
        return PairState::FAILED;
    }

    QByteArray serverCertStr = NvHTTP::getXmlStringFromHex(getCert, "plaincert");
    if (serverCertStr == nullptr)
    {
        qCritical() << "Server likely already pairing";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::ALREADY_IN_PROGRESS;
    }

    QSslCertificate unverifiedServerCert = QSslCertificate(serverCertStr);
    if (unverifiedServerCert.isNull()) {
        Q_ASSERT(!unverifiedServerCert.isNull());

        qCritical() << "Failed to parse plaincert";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    // Pin this cert for TLS until pairing is complete. If successful, we will propagate
    // the cert into the NvComputer object and persist it.
    m_Http.setServerCert(unverifiedServerCert);

    QByteArray randomChallenge = generateRandomBytes(16);
    QByteArray encryptedChallenge = encrypt(randomChallenge, aesKey);
    QString challengeXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                         "pair",
                                                         "devicename=roth&updateState=1&clientchallenge=" +
                                                         encryptedChallenge.toHex(),
                                                         REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(challengeXml);
    if (NvHTTP::getXmlString(challengeXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #2";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray challengeResponseData = decrypt(m_Http.getXmlStringFromHex(challengeXml, "challengeresponse"), aesKey);
    QByteArray clientSecretData = generateRandomBytes(16);
    QByteArray challengeResponse;
    QByteArray serverResponse(challengeResponseData.data(), hashLength);

#if (OPENSSL_VERSION_NUMBER < 0x10002000L)
    ASN1_BIT_STRING *asnSignature = m_Cert->signature;
#elif (OPENSSL_VERSION_NUMBER < 0x10100000L)
    ASN1_BIT_STRING *asnSignature;
    X509_get0_signature(&asnSignature, NULL, m_Cert);
#else
    const ASN1_BIT_STRING *asnSignature;
    X509_get0_signature(&asnSignature, NULL, m_Cert);
#endif

    challengeResponse.append(challengeResponseData.data() + hashLength, 16);
    challengeResponse.append(reinterpret_cast<char*>(asnSignature->data), asnSignature->length);
    challengeResponse.append(clientSecretData);

    QByteArray paddedHash = QCryptographicHash::hash(challengeResponse, hashAlgo);
    paddedHash.resize(32);
    QByteArray encryptedChallengeResponseHash = encrypt(paddedHash, aesKey);
    QString respXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&serverchallengeresp=" +
                                                    encryptedChallengeResponseHash.toHex(),
                                                    REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(respXml);
    if (NvHTTP::getXmlString(respXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #3";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray pairingSecret = NvHTTP::getXmlStringFromHex(respXml, "pairingsecret");
    QByteArray serverSecret = pairingSecret.left(16);
    QByteArray serverSignature = pairingSecret.mid(16);

    if (!verifySignature(serverSecret,
                         serverSignature,
                         serverCertStr))
    {
        qCritical() << "MITM detected";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray expectedResponseData;
    expectedResponseData.append(randomChallenge);
    expectedResponseData.append(getSignatureFromPemCert(serverCertStr));
    expectedResponseData.append(serverSecret);
    if (QCryptographicHash::hash(expectedResponseData, hashAlgo) != serverResponse)
    {
        qCritical() << "Incorrect PIN";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::PIN_WRONG;
    }

    QByteArray clientPairingSecret;
    clientPairingSecret.append(clientSecretData);
    clientPairingSecret.append(signMessage(clientSecretData));

    QString secretRespXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                          "pair",
                                                          "devicename=roth&updateState=1&clientpairingsecret=" +
                                                          clientPairingSecret.toHex(),
                                                          REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(secretRespXml);
    if (NvHTTP::getXmlString(secretRespXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #4";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QString pairChallengeXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttps,
                                                             "pair",
                                                             "devicename=roth&updateState=1&phrase=pairchallenge",
                                                             REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(pairChallengeXml);
    if (NvHTTP::getXmlString(pairChallengeXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #5";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    serverCert = std::move(unverifiedServerCert);
    return PairState::PAIRED;
}
```
**File:** app/backend/nvhttp.h (L178-179)
```text
    QImage
    getBoxArt(int appId);
```
**File:** app/backend/boxartmanager.cpp (L107-129)
```cpp
QUrl BoxArtManager::loadBoxArtFromNetwork(NvComputer* computer, int appId)
{
    NvHTTP http(computer);

    QString cachePath = getFilePathForBoxArt(computer, appId);
    QImage image;
    try {
        image = http.getBoxArt(appId);
    } catch (...) {}

    // Cache the box art on disk if it loaded
    if (!image.isNull()) {
        if (image.save(cachePath)) {
            return QUrl::fromLocalFile(cachePath);
        }
        else {
            // A failed save() may leave a zero byte file. Make sure that's removed.
            QFile(cachePath).remove();
        }
    }

    return QUrl();
}
```
**File:** app/streaming/session.cpp (L1554-1558)
```cpp
    // The UI should have ensured the old game was already quit
    // if we decide to stream a different game.
    Q_ASSERT(m_Computer->currentGameId == 0 ||
             m_Computer->currentGameId == m_App.id);

```
**File:** app/streaming/session.cpp (L1582-1600)
```cpp
    QString rtspSessionUrl;

    try {
        NvHTTP http(m_Computer);
        http.startApp(m_Computer->currentGameId != 0 ? "resume" : "launch",
                      m_Computer->isNvidiaServerSoftware,
                      m_App.id, &m_StreamConfig,
                      enableGameOptimizations,
                      m_Preferences->playAudioOnHost,
                      m_InputHandler->getAttachedGamepadMask(),
                      !m_Preferences->multiController,
                      rtspSessionUrl);
    } catch (const GfeHttpResponseException& e) {
        emit displayLaunchError(tr("Host returned error: %1").arg(e.toQString()));
        return false;
    } catch (const QtNetworkReplyException& e) {
        emit displayLaunchError(e.toQString());
        return false;
    }
```
**File:** app/backend/nvcomputer.cpp (L1-50)
```cpp
#include "nvcomputer.h"
#include "nvapp.h"
#include "settings/compatfetcher.h"

#include <QUdpSocket>
#include <QHostInfo>
#include <QNetworkInterface>
#include <QNetworkProxy>

#define SER_NAME "hostname"
#define SER_UUID "uuid"
#define SER_MAC "mac"
#define SER_LOCALADDR "localaddress"
#define SER_LOCALPORT "localport"
#define SER_REMOTEADDR "remoteaddress"
#define SER_REMOTEPORT "remoteport"
#define SER_MANUALADDR "manualaddress"
#define SER_MANUALPORT "manualport"
#define SER_IPV6ADDR "ipv6address"
#define SER_IPV6PORT "ipv6port"
#define SER_APPLIST "apps"
#define SER_SRVCERT "srvcert"
#define SER_CUSTOMNAME "customname"
#define SER_NVIDIASOFTWARE "nvidiasw"

NvComputer::NvComputer(QSettings& settings)
{
    this->name = settings.value(SER_NAME).toString();
    this->uuid = settings.value(SER_UUID).toString();
    this->hasCustomName = settings.value(SER_CUSTOMNAME).toBool();
    this->macAddress = settings.value(SER_MAC).toByteArray();
    this->localAddress = NvAddress(settings.value(SER_LOCALADDR).toString(),
                                   settings.value(SER_LOCALPORT, QVariant(DEFAULT_HTTP_PORT)).toUInt());
    this->remoteAddress = NvAddress(settings.value(SER_REMOTEADDR).toString(),
                                    settings.value(SER_REMOTEPORT, QVariant(DEFAULT_HTTP_PORT)).toUInt());
    this->ipv6Address = NvAddress(settings.value(SER_IPV6ADDR).toString(),
                                  settings.value(SER_IPV6PORT, QVariant(DEFAULT_HTTP_PORT)).toUInt());
    this->manualAddress = NvAddress(settings.value(SER_MANUALADDR).toString(),
                                    settings.value(SER_MANUALPORT, QVariant(DEFAULT_HTTP_PORT)).toUInt());
    this->serverCert = QSslCertificate(settings.value(SER_SRVCERT).toByteArray());
    this->isNvidiaServerSoftware = settings.value(SER_NVIDIASOFTWARE).toBool();

    int appCount = settings.beginReadArray(SER_APPLIST);
    this->appList.reserve(appCount);
    for (int i = 0; i < appCount; i++) {
        settings.setArrayIndex(i);

        NvApp app(settings);
        this->appList.append(app);
    }
```
## Q10
The server completes the pairing by inputting the PIN code displayed by the client. How does the client wait for the server's response to complete the pairing during the time the PIN code is generated and the user inputs the PIN on the server side?
### Answer
You're asking about how the Moonlight client waits for the server to complete pairing after displaying the PIN code to the user.

## Answer

The client doesn't actively poll or wait for the server's response during pairing. Instead, the pairing process is **synchronous and blocking** - the client sends requests sequentially through all 5 phases and waits for each response before proceeding to the next phase.

### Pairing Execution Flow

When the user clicks on an unpaired PC, the client generates a PIN and displays it in a dialog: moonlight-qt:239-246 

The pairing task runs in a background thread via `PendingPairingTask`: moonlight-qt:564-582 

### The Blocking Nature of Pairing

Inside `NvPairingManager::pair()`, each phase makes an HTTP/HTTPS request and **blocks waiting for the response** before proceeding: moonlight-qt:217-227 

The server validates the PIN during Phase 3 (server challenge response). If the user hasn't entered the PIN yet on the server side, the server simply doesn't respond or returns an error, causing the pairing to fail: moonlight-qt:287-298 

### PIN Validation

The PIN validation happens when the client sends the encrypted challenge response hash in Phase 3. The server decrypts this using the PIN-derived key and verifies it matches the expected value: moonlight-qt:313-322 

If the PIN is incorrect (user entered wrong PIN on server), the server returns a response that causes the client to detect `PIN_WRONG` state: moonlight-qt:585-586 

### UI Feedback

While pairing is in progress, the dialog remains open showing the PIN: moonlight-qt:302-310 

When pairing completes (successfully or with error), the `pairingCompleted` signal is emitted, which closes the dialog: moonlight-qt:47-58 

## Notes

The pairing process uses HTTP request timeouts (defined as `REQUEST_TIMEOUT_MS`) to prevent indefinite waiting. If the user takes too long to enter the PIN on the server, the HTTP request will timeout and pairing will fail. The client doesn't implement any retry logic or polling mechanism - it's a single synchronous attempt that either succeeds or fails based on the server's responses to the 5-phase handshake.

Wiki pages you might want to explore:
- [User Interface System (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2)
- [PC Discovery View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.1)
### Citations
**File:** app/gui/PcView.qml (L47-58)
```text
    function pairingComplete(error)
    {
        // Close the PIN dialog
        pairDialog.close()

        // Display a failed dialog if we got an error
        if (error !== undefined) {
            errorDialog.text = error
            errorDialog.helpText = ""
            errorDialog.open()
        }
    }
```
**File:** app/gui/PcView.qml (L239-246)
```text
                    var pin = computerModel.generatePinString()

                    // Kick off pairing in the background
                    computerModel.pairComputer(index, pin)

                    // Display the pairing dialog
                    pairDialog.pin = pin
                    pairDialog.open()
```
**File:** app/gui/PcView.qml (L302-310)
```text
        // don't allow edits to the rest of the window while open
        property string pin : "0000"
        text:qsTr("Please enter %1 on your host PC. This dialog will close when pairing is completed.").arg(pin)+"\n\n"+
             qsTr("If your host PC is running Sunshine, navigate to the Sunshine web UI to enter the PIN.")
        standardButtons: Dialog.Cancel
        onRejected: {
            // FIXME: We should interrupt pairing here
        }
    }
```
**File:** app/backend/computermanager.cpp (L564-582)
```cpp
    PendingPairingTask(ComputerManager* computerManager, NvComputer* computer, QString pin)
        : m_ComputerManager(computerManager),
          m_Computer(computer),
          m_Pin(pin)
    {
        connect(this, &PendingPairingTask::pairingCompleted,
                computerManager, &ComputerManager::pairingCompleted);
    }

signals:
    void pairingCompleted(NvComputer* computer, QString error);

private:
    void run()
    {
        NvPairingManager pairingManager(m_Computer);

        try {
           NvPairingManager::PairState result = pairingManager.pair(m_Computer->appVersion, m_Pin, m_Computer->serverCert);
```
**File:** app/backend/computermanager.cpp (L585-586)
```cpp
           case NvPairingManager::PairState::PIN_WRONG:
               emit pairingCompleted(m_Computer, tr("The PIN from the PC didn't match. Please try again."));
```
**File:** app/backend/nvpairingmanager.cpp (L217-227)
```cpp
    QString getCert = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&phrase=getservercert&salt=" +
                                                    salt.toHex() + "&clientcert=" + IdentityManager::get()->getCertificate().toHex(),
                                                    0);
    NvHTTP::verifyResponseStatus(getCert);
    if (NvHTTP::getXmlString(getCert, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #1";
        return PairState::FAILED;
    }
```
**File:** app/backend/nvpairingmanager.cpp (L287-298)
```cpp
    QString respXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&serverchallengeresp=" +
                                                    encryptedChallengeResponseHash.toHex(),
                                                    REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(respXml);
    if (NvHTTP::getXmlString(respXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #3";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }
```
**File:** app/backend/nvpairingmanager.cpp (L313-322)
```cpp
    QByteArray expectedResponseData;
    expectedResponseData.append(randomChallenge);
    expectedResponseData.append(getSignatureFromPemCert(serverCertStr));
    expectedResponseData.append(serverSecret);
    if (QCryptographicHash::hash(expectedResponseData, hashAlgo) != serverResponse)
    {
        qCritical() << "Incorrect PIN";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::PIN_WRONG;
    }
```
# DeepWiki Q&A with Code Context for Repository: moonlight-stream/moonlight-qt
## Q1
how to get /launch and /serverinfo info from server?
### Answer
Based on the code context, you're asking about how Moonlight retrieves `/launch` and `/serverinfo` information from the host server.

## Answer

Moonlight uses the `NvHTTP` class to communicate with the host server and retrieve information through HTTP/HTTPS endpoints. moonlight-qt:124-187 

### Getting `/serverinfo`

The `NvHTTP::getServerInfo()` method fetches server information: moonlight-qt:124-140 

The method first attempts to use HTTPS if a pinned certificate is available, then falls back to HTTP if needed. moonlight-qt:143-160  If no certificate exists yet, it uses HTTP initially to fetch the HTTPS port, then retries over HTTPS. moonlight-qt:162-183 

This is called during PC discovery when adding a new host: moonlight-qt:809-818 

The response is then used to create or update an `NvComputer` object: moonlight-qt:820-821 

### Getting `/launch` info

The `/launch` endpoint is called via `NvHTTP::startApp()` when starting a streaming session: moonlight-qt:1585-1593 

This happens in `Session::startConnectionAsync()` after the user selects an app to stream. moonlight-qt:1548-1600  The method passes streaming configuration parameters and receives back an RTSP session URL that's used to establish the actual streaming connection. moonlight-qt:1582-1593 

## Notes

The `NvHTTP` class handles all HTTP/HTTPS communication with the host server, including certificate pinning for security. The `/serverinfo` endpoint is polled regularly to monitor PC status, while `/launch` (or `/resume`) is only called when initiating a streaming session. Both endpoints use the base URL constructed from the host's address and appropriate port (HTTP 47989 or HTTPS 47984 by default).

Wiki pages you might want to explore:
- [User Interface System (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2)
- [PC Discovery View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.1)
### Citations
**File:** app/backend/nvhttp.cpp (L124-187)
```cpp
NvHTTP::getServerInfo(NvLogLevel logLevel, bool fastFail)
{
    QString serverInfo;

    // Check if we have a pinned cert and HTTPS port for this host yet
    if (!m_ServerCert.isNull() && httpsPort() != 0)
    {
        try
        {
            // Always try HTTPS first, since it properly reports
            // pairing status (and a few other attributes).
            serverInfo = openConnectionToString(m_BaseUrlHttps,
                                                "serverinfo",
                                                nullptr,
                                                fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                                logLevel);
            // Throws if the request failed
            verifyResponseStatus(serverInfo);
        }
        catch (const GfeHttpResponseException& e)
        {
            if (e.getStatusCode() == 401)
            {
                // Certificate validation error, fallback to HTTP
                serverInfo = openConnectionToString(m_BaseUrlHttp,
                                                    "serverinfo",
                                                    nullptr,
                                                    fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                                    logLevel);
                verifyResponseStatus(serverInfo);
            }
            else
            {
                // Rethrow real errors
                throw e;
            }
        }
    }
    else
    {
        // Only use HTTP prior to pairing or fetching HTTPS port
        serverInfo = openConnectionToString(m_BaseUrlHttp,
                                            "serverinfo",
                                            nullptr,
                                            fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                            logLevel);
        verifyResponseStatus(serverInfo);

        // Populate the HTTPS port
        uint16_t httpsPort = getXmlString(serverInfo, "HttpsPort").toUShort();
        if (httpsPort == 0) {
            httpsPort = DEFAULT_HTTPS_PORT;
        }
        setHttpsPort(httpsPort);

        // If we just needed to determine the HTTPS port, we'll try again over
        // HTTPS now that we have the port number
        if (!m_ServerCert.isNull()) {
            return getServerInfo(logLevel, fastFail);
        }
    }

    return serverInfo;
}
```
**File:** app/backend/computermanager.cpp (L809-818)
```cpp
        // Perform initial serverinfo fetch over HTTP since we don't know which cert to use
        QString serverInfo = fetchServerInfo(http);
        if (serverInfo.isEmpty() && !m_MdnsIpv6Address.isNull()) {
            // Retry using the global IPv6 address if the IPv4 or link-local IPv6 address fails
            http.setAddress(m_MdnsIpv6Address);
            serverInfo = fetchServerInfo(http);
        }
        if (serverInfo.isEmpty()) {
            return;
        }
```
**File:** app/backend/computermanager.cpp (L820-821)
```cpp
        // Create initial newComputer using HTTP serverinfo with no pinned cert
        NvComputer* newComputer = new NvComputer(http, serverInfo);
```
**File:** app/streaming/session.cpp (L1548-1600)
```cpp
bool Session::startConnectionAsync()
{
    // Wait 1.5 seconds before connecting to let the user
    // have time to read any messages present on the segue
    SDL_Delay(1500);

    // The UI should have ensured the old game was already quit
    // if we decide to stream a different game.
    Q_ASSERT(m_Computer->currentGameId == 0 ||
             m_Computer->currentGameId == m_App.id);

    bool enableGameOptimizations;
    if (m_Computer->isNvidiaServerSoftware) {
        // GFE will set all settings to 720p60 if it doesn't recognize
        // the chosen resolution. Avoid that by disabling SOPS when it
        // is not streaming a supported resolution.
        enableGameOptimizations = false;
        for (const NvDisplayMode &mode : m_Computer->displayModes) {
            if (mode.width == m_StreamConfig.width &&
                    mode.height == m_StreamConfig.height) {
                SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION,
                            "Found host supported resolution: %dx%d",
                            mode.width, mode.height);
                enableGameOptimizations = m_Preferences->gameOptimizations;
                break;
            }
        }
    }
    else {
        // Always send SOPS to Sunshine because we may repurpose the
        // option to control whether the display mode is adjusted
        enableGameOptimizations = m_Preferences->gameOptimizations;
    }

    QString rtspSessionUrl;

    try {
        NvHTTP http(m_Computer);
        http.startApp(m_Computer->currentGameId != 0 ? "resume" : "launch",
                      m_Computer->isNvidiaServerSoftware,
                      m_App.id, &m_StreamConfig,
                      enableGameOptimizations,
                      m_Preferences->playAudioOnHost,
                      m_InputHandler->getAttachedGamepadMask(),
                      !m_Preferences->multiController,
                      rtspSessionUrl);
    } catch (const GfeHttpResponseException& e) {
        emit displayLaunchError(tr("Host returned error: %1").arg(e.toQString()));
        return false;
    } catch (const QtNetworkReplyException& e) {
        emit displayLaunchError(e.toQString());
        return false;
    }
```
## Q2
How to parse the information returned by the above 2 interfaces and provide it to the function for establishing a streaming connection?
### Answer
You're asking about how Moonlight parses the responses from `/serverinfo` and `/launch` endpoints and uses that information to establish a streaming connection.

## Answer

### Parsing `/serverinfo` Response

The `/serverinfo` response is parsed to create/update an `NvComputer` object that stores host capabilities. moonlight-qt:754-782  The `NvHTTP::getServerInfo()` method returns an XML string that gets parsed to extract server properties like:<cite />

- Server codec mode support (`serverCodecModeSupport`)
- GFE version (`gfeVersion`)
- App version (`appVersion`)
- Display modes
- Current game ID

These properties are stored in the `NvComputer` object and later used during session validation and configuration.<cite />

### Parsing `/launch` Response and Establishing Connection

When starting a stream, `NvHTTP::startApp()` is called with the `STREAM_CONFIGURATION` structure containing all streaming parameters (resolution, FPS, bitrate, codec preferences, etc.). moonlight-qt:189-236  The method constructs a URL with query parameters including:<cite />

- Resolution and FPS (`mode` parameter)
- HDR settings
- Audio configuration
- Gamepad mask
- Remote input encryption keys

The response is parsed to extract the `rtspSessionUrl` using `getXmlString(response, "sessionUrl0")`. moonlight-qt:235-235 

### Providing Information to Connection Function

After receiving the `/launch` response, the parsed information is used to populate a `SERVER_INFORMATION` structure: moonlight-qt:1602-1624 

```cpp
SERVER_INFORMATION hostInfo;
hostInfo.address = hostnameStr.data();
hostInfo.serverInfoAppVersion = siAppVersion.data();
hostInfo.serverCodecModeSupport = m_Computer->serverCodecModeSupport;
hostInfo.serverInfoGfeVersion = siGfeVersion.data();
hostInfo.rtspSessionUrl = rtspSessionUrlStr.data();
```

This structure, along with the `STREAM_CONFIGURATION` and callback structures, is passed to `LiStartConnection()` to establish the actual streaming connection: moonlight-qt:1678-1685 

The `LiStartConnection()` function (from the moonlight-common-c library) uses:
- The RTSP session URL from `/launch` response to establish the RTSP control channel
- Server codec support from `/serverinfo` to negotiate video formats
- Stream configuration to set up video/audio decoders

### Validation Before Connection

Before calling `LiStartConnection()`, the session validates that the host supports the requested features by checking `m_Computer->serverCodecModeSupport` against the requested video formats. moonlight-qt:1117-1152  For example, it verifies YUV 4:4:4 support and adjusts the supported video formats list accordingly.<cite />

## Notes

The parsing happens in two stages: first during PC discovery (parsing `/serverinfo` into `NvComputer` properties), then during session start (parsing `/launch` response for RTSP URL). The `NvComputer` object acts as a bridge, storing server capabilities that are later referenced when configuring the `SERVER_INFORMATION` structure for `LiStartConnection()`. The actual XML parsing is handled by helper functions like `getXmlString()` in the `NvHTTP` class.

Wiki pages you might want to explore:
- [Settings View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.2)
- [Input Handling (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#4.7)
### Citations
**File:** app/backend/computermanager.cpp (L754-782)
```cpp
    QString fetchServerInfo(NvHTTP& http)
    {
        QString serverInfo;

        // Do nothing if we're quitting
        if (m_AboutToQuit) {
            return QString();
        }

        try {
            // There's a race condition between GameStream servers reporting presence over
            // mDNS and the HTTPS server being ready to respond to our queries. To work
            // around this issue, we will issue the request again after a few seconds if
            // we see a ServiceUnavailableError error.
            try {
                serverInfo = http.getServerInfo(NvHTTP::NVLL_VERBOSE);
            } catch (const QtNetworkReplyException& e) {
                if (e.getError() == QNetworkReply::ServiceUnavailableError) {
                    qWarning() << "Retrying request in 5 seconds after ServiceUnavailableError";
                    QThread::sleep(5);
                    serverInfo = http.getServerInfo(NvHTTP::NVLL_VERBOSE);
                    qInfo() << "Retry successful";
                }
                else {
                    // Rethrow other errors
                    throw e;
                }
            }
            return serverInfo;
```
**File:** app/backend/nvhttp.cpp (L189-236)
```cpp
void
NvHTTP::startApp(QString verb,
                 bool isGfe,
                 int appId,
                 PSTREAM_CONFIGURATION streamConfig,
                 bool sops,
                 bool localAudio,
                 int gamepadMask,
                 bool persistGameControllersOnDisconnect,
                 QString& rtspSessionUrl)
{
    int riKeyId;

    memcpy(&riKeyId, streamConfig->remoteInputAesIv, sizeof(riKeyId));
    riKeyId = qFromBigEndian(riKeyId);

    QString response =
            openConnectionToString(m_BaseUrlHttps,
                                   verb,
                                   "appid="+QString::number(appId)+
                                   "&mode="+QString::number(streamConfig->width)+"x"+
                                   QString::number(streamConfig->height)+"x"+
                                   // Using an FPS value over 60 causes SOPS to default to 720p60,
                                   // so force it to 0 to ensure the correct resolution is set. We
                                   // used to use 60 here but that locked the frame rate to 60 FPS
                                   // on GFE 3.20.3. We don't need this hack for Sunshine.
                                   QString::number((streamConfig->fps > 60 && isGfe) ? 0 : streamConfig->fps)+
                                   "&additionalStates=1&sops="+QString::number(sops ? 1 : 0)+
                                   "&rikey="+QByteArray(streamConfig->remoteInputAesKey, sizeof(streamConfig->remoteInputAesKey)).toHex()+
                                   "&rikeyid="+QString::number(riKeyId)+
                                   ((streamConfig->supportedVideoFormats & VIDEO_FORMAT_MASK_10BIT) ?
                                       "&hdrMode=1&clientHdrCapVersion=0&clientHdrCapSupportedFlagsInUint32=0&clientHdrCapMetaDataId=NV_STATIC_METADATA_TYPE_1&clientHdrCapDisplayData=0x0x0x0x0x0x0x0x0x0x0" :
                                        "")+
                                   "&localAudioPlayMode="+QString::number(localAudio ? 1 : 0)+
                                   "&surroundAudioInfo="+QString::number(SURROUNDAUDIOINFO_FROM_AUDIO_CONFIGURATION(streamConfig->audioConfiguration))+
                                   "&remoteControllersBitmap="+QString::number(gamepadMask)+
                                   "&gcmap="+QString::number(gamepadMask)+
                                   "&gcpersist="+QString::number(persistGameControllersOnDisconnect ? 1 : 0)+
                                   LiGetLaunchUrlQueryParameters(),
                                   LAUNCH_TIMEOUT_MS);

    qInfo() << "Launch response:" << response;

    // Throws if the request failed
    verifyResponseStatus(response);

    rtspSessionUrl = getXmlString(response, "sessionUrl0");
}
```
**File:** app/streaming/session.cpp (L1117-1152)
```cpp
    if (m_Preferences->enableYUV444) {
        if (!(m_Computer->serverCodecModeSupport & SCM_MASK_YUV444)) {
            emitLaunchWarning(tr("Your host PC doesn't support YUV 4:4:4 streaming."));
            m_SupportedVideoFormats.removeByMask(VIDEO_FORMAT_MASK_YUV444);
        }
        else {
            m_SupportedVideoFormats.removeByMask(~m_SupportedVideoFormats.maskByServerCodecModes(m_Computer->serverCodecModeSupport));

            if (!m_SupportedVideoFormats.isEmpty() &&
                !(m_SupportedVideoFormats.front() & VIDEO_FORMAT_MASK_YUV444)) {
                emitLaunchWarning(tr("Your host PC doesn't support YUV 4:4:4 streaming for selected video codec."));
            }
            else if (m_Preferences->videoDecoderSelection != StreamingPreferences::VDS_FORCE_SOFTWARE) {
                while (!m_SupportedVideoFormats.isEmpty() &&
                       (m_SupportedVideoFormats.front() & VIDEO_FORMAT_MASK_YUV444) &&
                       getDecoderAvailability(testWindow,
                                              m_Preferences->videoDecoderSelection,
                                              m_SupportedVideoFormats.front(),
                                              m_StreamConfig.width,
                                              m_StreamConfig.height,
                                              m_StreamConfig.fps) != DecoderAvailability::Hardware) {
                    if (m_Preferences->videoDecoderSelection == StreamingPreferences::VDS_FORCE_HARDWARE) {
                        m_SupportedVideoFormats.removeFirst();
                    }
                    else {
                        emitLaunchWarning(tr("Using software decoding due to your selection to force YUV 4:4:4 without GPU support. This may cause poor streaming performance."));
                        break;
                    }
                }
                if (!m_SupportedVideoFormats.isEmpty() &&
                    !(m_SupportedVideoFormats.front() & VIDEO_FORMAT_MASK_YUV444)) {
                    emitLaunchWarning(tr("This PC's GPU doesn't support YUV 4:4:4 decoding for selected video codec."));
                }
            }
        }
    }
```
**File:** app/streaming/session.cpp (L1602-1624)
```cpp
    QByteArray hostnameStr = m_Computer->activeAddress.address().toLatin1();
    QByteArray siAppVersion = m_Computer->appVersion.toLatin1();

    SERVER_INFORMATION hostInfo;
    hostInfo.address = hostnameStr.data();
    hostInfo.serverInfoAppVersion = siAppVersion.data();
    hostInfo.serverCodecModeSupport = m_Computer->serverCodecModeSupport;

    // Older GFE versions didn't have this field
    QByteArray siGfeVersion;
    if (!m_Computer->gfeVersion.isEmpty()) {
        siGfeVersion = m_Computer->gfeVersion.toLatin1();
    }
    if (!siGfeVersion.isEmpty()) {
        hostInfo.serverInfoGfeVersion = siGfeVersion.data();
    }

    // Older GFE and Sunshine versions didn't have this field
    QByteArray rtspSessionUrlStr;
    if (!rtspSessionUrl.isEmpty()) {
        rtspSessionUrlStr = rtspSessionUrl.toLatin1();
        hostInfo.rtspSessionUrl = rtspSessionUrlStr.data();
    }
```
**File:** app/streaming/session.cpp (L1678-1685)
```cpp
    int err = LiStartConnection(&hostInfo, &m_StreamConfig, &k_ConnCallbacks,
                                &m_VideoCallbacks, &m_AudioCallbacks,
                                NULL, 0, NULL, 0);
    if (err != 0) {
        // We already displayed an error dialog in the stage failure
        // listener.
        return false;
    }
```
## Q3
how to get "Remote input encryption keys"
### Answer
You're asking about how Moonlight generates the "Remote input encryption keys" that are sent to the host server during the `/launch` request.

## Answer

The remote input encryption keys (`rikey` and `rikeyid`) are randomly generated AES encryption keys used to secure input data sent from the client to the host during streaming. moonlight-qt:692-696 

### Key Generation

During session initialization in `Session::initialize()`, Moonlight generates these keys using OpenSSL's cryptographically secure random number generator:

```cpp
RAND_bytes(reinterpret_cast<unsigned char*>(m_StreamConfig.remoteInputAesKey),
           sizeof(m_StreamConfig.remoteInputAesKey));

// Only the first 4 bytes are populated in the RI key IV
RAND_bytes(reinterpret_cast<unsigned char*>(m_StreamConfig.remoteInputAesIv), 4);
``` moonlight-qt:692-696 

The `remoteInputAesKey` is a full AES key (16 bytes), while `remoteInputAesIv` only uses the first 4 bytes as an initialization vector. moonlight-qt:692-696 

### Sending Keys to Host

These generated keys are then sent to the host server when calling the `/launch` endpoint in `NvHTTP::startApp()`. moonlight-qt:200-218  The method:

1. Extracts the key ID from the IV by reading the first 4 bytes as a big-endian integer moonlight-qt:200-203 
2. Converts the AES key to hexadecimal format using `QByteArray(...).toHex()` moonlight-qt:217-217 
3. Includes both values as query parameters: `rikey=<hex_key>&rikeyid=<key_id>` moonlight-qt:217-218 

### Security Considerations

For security, these keys are automatically redacted from log files to prevent exposure. moonlight-qt:108-110  The logging system uses regex patterns to strip `rikey` and `rikeyid` values before writing to logs. moonlight-qt:88-88 

## Notes

The remote input encryption is part of Moonlight's security features to protect input data (keyboard, mouse, gamepad) transmitted during streaming. The keys are generated fresh for each streaming session and are stored in the `STREAM_CONFIGURATION` structure (`m_StreamConfig`) which is later passed to `LiStartConnection()` to establish the connection. moonlight-qt:1584-1593 

Wiki pages you might want to explore:
- [PC Discovery View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.1)
### Citations
**File:** app/streaming/session.cpp (L692-696)
```cpp
    RAND_bytes(reinterpret_cast<unsigned char*>(m_StreamConfig.remoteInputAesKey),
               sizeof(m_StreamConfig.remoteInputAesKey));

    // Only the first 4 bytes are populated in the RI key IV
    RAND_bytes(reinterpret_cast<unsigned char*>(m_StreamConfig.remoteInputAesIv), 4);
```
**File:** app/streaming/session.cpp (L1584-1593)
```cpp
    try {
        NvHTTP http(m_Computer);
        http.startApp(m_Computer->currentGameId != 0 ? "resume" : "launch",
                      m_Computer->isNvidiaServerSoftware,
                      m_App.id, &m_StreamConfig,
                      enableGameOptimizations,
                      m_Preferences->playAudioOnHost,
                      m_InputHandler->getAttachedGamepadMask(),
                      !m_Preferences->multiController,
                      rtspSessionUrl);
```
**File:** app/backend/nvhttp.cpp (L200-218)
```cpp
    int riKeyId;

    memcpy(&riKeyId, streamConfig->remoteInputAesIv, sizeof(riKeyId));
    riKeyId = qFromBigEndian(riKeyId);

    QString response =
            openConnectionToString(m_BaseUrlHttps,
                                   verb,
                                   "appid="+QString::number(appId)+
                                   "&mode="+QString::number(streamConfig->width)+"x"+
                                   QString::number(streamConfig->height)+"x"+
                                   // Using an FPS value over 60 causes SOPS to default to 720p60,
                                   // so force it to 0 to ensure the correct resolution is set. We
                                   // used to use 60 here but that locked the frame rate to 60 FPS
                                   // on GFE 3.20.3. We don't need this hack for Sunshine.
                                   QString::number((streamConfig->fps > 60 && isGfe) ? 0 : streamConfig->fps)+
                                   "&additionalStates=1&sops="+QString::number(sops ? 1 : 0)+
                                   "&rikey="+QByteArray(streamConfig->remoteInputAesKey, sizeof(streamConfig->remoteInputAesKey)).toHex()+
                                   "&rikeyid="+QString::number(riKeyId)+
```
**File:** app/main.cpp (L108-110)
```cpp
    // Strip session encryption keys and IVs from the logs
    message.replace(k_RikeyRegex, "&rikey=REDACTED");
    message.replace(k_RikeyIdRegex, "&rikeyid=REDACTED");
```
**File:** app/deploy/linux/com.moonlight_stream.Moonlight.appdata.xml (L88-88)
```text
					<li>Per-session keys (rikey and rikeyid values) are now automatically stripped from logs</li>
```
## Q4
<?xml version="1.0" encoding="utf-8"?>
<root status_code="200">
  <hostname>Html5syt</hostname>
  <appversion>7.1.431.-1</appversion>
<GfeVersion>3.23.0.74</GfeVersion>
  <uniqueid>F98186B1-DE02-2328-279E-0A461FBCEC47</uniqueid>
  <HttpsPort>47984</HttpsPort>
  <ExternalPort>47989</ExternalPort>
<MaxLumaPixelsHEVC>1869449984</MaxLumaPixelsHEVC>
  <mac>00:00:00:00:00:00</mac>
  <LocalIP>127.0.0.1</LocalIP>
  <ServerCodecModeSupport>257</ServerCodecModeSupport>
<PairStatus>0</PairStatus>
  <currentgame>1191261554</currentgame>
  <state>SUNSHINE_SERVER_BUSY</state>
</root>
This is a response from a serverinfo, please tell me which parameters are used to establish the connection in it?
### Answer
You're asking which parameters from the `/serverinfo` XML response are used when establishing a streaming connection in Moonlight.

## Answer

From the `/serverinfo` response you provided, the following parameters are used to establish the streaming connection:

### Parameters Used in Connection Establishment

**`ServerCodecModeSupport` (value: 257)** - This is stored in the `NvComputer` object and later passed to `LiStartConnection()` via the `SERVER_INFORMATION` structure. moonlight-qt:1608-1608  It indicates which video codecs and formats the host supports, and is used to negotiate the video format during connection setup. moonlight-qt:1608-1608 

**`appversion` (value: 7.1.431.-1)** - This is stored as `m_Computer->appVersion` and passed to `LiStartConnection()` as `hostInfo.serverInfoAppVersion`. moonlight-qt:1603-1607  The connection library uses this to determine host capabilities and compatibility. moonlight-qt:1603-1607 

**`GfeVersion` (value: 3.23.0.74)** - This is stored as `m_Computer->gfeVersion` and passed to `LiStartConnection()` as `hostInfo.serverInfoGfeVersion`. moonlight-qt:1611-1617  It's used to determine if the host is running GFE or Sunshine and adjust behavior accordingly. moonlight-qt:1560-1580 

**`LocalIP` (value: 127.0.0.1)** - The host's address is used to construct the base URLs for HTTP/HTTPS communication and is passed to `LiStartConnection()` as `hostInfo.address`. moonlight-qt:1602-1606 

**`HttpsPort` (value: 47984)** - Used to construct the HTTPS base URL for secure communication with the host, including the `/launch` endpoint call. moonlight-qt:173-177 

### Parameters NOT Directly Used in Connection

The following parameters are informational but not directly passed to the connection function:

- `hostname`, `uniqueid`, `ExternalPort`, `MaxLumaPixelsHEVC`, `mac` - These are stored in the `NvComputer` object for display and management purposes but aren't passed to `LiStartConnection()`.<cite />
- `PairStatus` - Used to determine if pairing is needed before streaming, but not used during connection establishment.<cite />
- `currentgame` and `state` - Used to determine if the host is already streaming, which affects whether to call `/launch` or `/resume`. moonlight-qt:1586-1586 

## Notes

The `state` value "SUNSHINE_SERVER_BUSY" indicates the host is currently streaming (as confirmed by the non-zero `currentgame` value). moonlight-qt:112-116  In this case, Moonlight would call `/resume` instead of `/launch` if you're trying to connect to the same game. moonlight-qt:1586-1586  The `ServerCodecModeSupport` value of 257 indicates support for H.264 (bit 0) and H.265/HEVC (bit 8).<cite />

Wiki pages you might want to explore:
- [PC Discovery View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.1)
### Citations
**File:** app/streaming/session.cpp (L1560-1580)
```cpp
    if (m_Computer->isNvidiaServerSoftware) {
        // GFE will set all settings to 720p60 if it doesn't recognize
        // the chosen resolution. Avoid that by disabling SOPS when it
        // is not streaming a supported resolution.
        enableGameOptimizations = false;
        for (const NvDisplayMode &mode : m_Computer->displayModes) {
            if (mode.width == m_StreamConfig.width &&
                    mode.height == m_StreamConfig.height) {
                SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION,
                            "Found host supported resolution: %dx%d",
                            mode.width, mode.height);
                enableGameOptimizations = m_Preferences->gameOptimizations;
                break;
            }
        }
    }
    else {
        // Always send SOPS to Sunshine because we may repurpose the
        // option to control whether the display mode is adjusted
        enableGameOptimizations = m_Preferences->gameOptimizations;
    }
```
**File:** app/streaming/session.cpp (L1586-1586)
```cpp
        http.startApp(m_Computer->currentGameId != 0 ? "resume" : "launch",
```
**File:** app/streaming/session.cpp (L1602-1607)
```cpp
    QByteArray hostnameStr = m_Computer->activeAddress.address().toLatin1();
    QByteArray siAppVersion = m_Computer->appVersion.toLatin1();

    SERVER_INFORMATION hostInfo;
    hostInfo.address = hostnameStr.data();
    hostInfo.serverInfoAppVersion = siAppVersion.data();
```
**File:** app/streaming/session.cpp (L1608-1608)
```cpp
    hostInfo.serverCodecModeSupport = m_Computer->serverCodecModeSupport;
```
**File:** app/streaming/session.cpp (L1611-1617)
```cpp
    QByteArray siGfeVersion;
    if (!m_Computer->gfeVersion.isEmpty()) {
        siGfeVersion = m_Computer->gfeVersion.toLatin1();
    }
    if (!siGfeVersion.isEmpty()) {
        hostInfo.serverInfoGfeVersion = siGfeVersion.data();
    }
```
**File:** app/backend/nvhttp.cpp (L112-116)
```cpp
    QString serverState = getXmlString(serverInfo, "state");
    if (serverState != nullptr && serverState.endsWith("_SERVER_BUSY"))
    {
        return getXmlString(serverInfo, "currentgame").toInt();
    }
```
**File:** app/backend/nvhttp.cpp (L173-177)
```cpp
        uint16_t httpsPort = getXmlString(serverInfo, "HttpsPort").toUShort();
        if (httpsPort == 0) {
            httpsPort = DEFAULT_HTTPS_PORT;
        }
        setHttpsPort(httpsPort);
```
## Q5
When I call the /launch interface, the server requires me to provide a client certificate. How can I obtain this certificate?
### Answer
Moonlight obtains and provides client certificates through a multi-step process involving certificate generation, pairing, and SSL configuration:

## Client Certificate Generation

When Moonlight first launches, the `IdentityManager` class automatically generates a self-signed 2048-bit RSA certificate and private key pair if none exist. moonlight-qt:29-110 

These credentials are stored persistently in QSettings and cached in memory for reuse. moonlight-qt:112-139 

## Attaching Certificates to Requests

For every HTTPS request (including `/launch`), Moonlight attaches the client certificate through the `IdentityManager::getSslConfig()` method, which returns a `QSslConfiguration` containing both the client certificate and private key. moonlight-qt:184-191 

This SSL configuration is applied to all network requests in the `openConnection` method via `request.setSslConfiguration()`. moonlight-qt:486-489 

## The `/launch` Interface Specifically

When the `startApp` method is called to launch a game, it makes an HTTPS request to the `/launch` endpoint using the base HTTPS URL. moonlight-qt:205-228 

This request goes through `openConnection`, which automatically includes the client certificate for mutual TLS authentication with the host server.

## Pairing Process for Mutual Trust

Before the client certificate can be used for authentication, a pairing process must occur. During pairing, the client sends its certificate to the server and receives the server's certificate in return. moonlight-qt:217-248 

The server certificate is then pinned and stored in the `NvComputer` object for future SSL validation. moonlight-qt:419-439 

## Certificate Validation

If there's an SSL handshake failure or certificate mismatch (error 401), Moonlight falls back to HTTP and can re-initiate pairing to obtain updated certificates. moonlight-qt:143-160 

## Notes

- The client certificate uses a common name of "NVIDIA GameStream Client" moonlight-qt:70-74 
- The certificate has a 20-year validity period moonlight-qt:51-66 
- The `/launch` endpoint uses a 120-second timeout compared to the standard 5-second timeout for other requests moonlight-qt:15-19 
- Certificate pinning prevents man-in-the-middle attacks by ensuring SSL errors are only ignored if they match the previously paired server certificate moonlight-qt:429-434
### Citations
**File:** app/backend/identitymanager.cpp (L29-110)
```cpp
void IdentityManager::createCredentials(QSettings& settings)
{
    X509* cert = X509_new();
    THROW_BAD_ALLOC_IF_NULL(cert);

    EVP_PKEY_CTX* ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_RSA, NULL);
    THROW_BAD_ALLOC_IF_NULL(ctx);

    EVP_PKEY_keygen_init(ctx);
    EVP_PKEY_CTX_set_rsa_keygen_bits(ctx, 2048);

    // pk must be initialized on input
    EVP_PKEY* pk = NULL;
    EVP_PKEY_keygen(ctx, &pk);

    EVP_PKEY_CTX_free(ctx);
    THROW_BAD_ALLOC_IF_NULL(pk);

    X509_set_version(cert, 2);
    ASN1_INTEGER_set(X509_get_serialNumber(cert), 0);
#if OPENSSL_VERSION_NUMBER < 0x10100000L
    X509_gmtime_adj(X509_get_notBefore(cert), 0);
    X509_gmtime_adj(X509_get_notAfter(cert), 60 * 60 * 24 * 365 * 20); // 20 yrs
#else
    ASN1_TIME* before = ASN1_STRING_dup(X509_get0_notBefore(cert));
    THROW_BAD_ALLOC_IF_NULL(before);
    ASN1_TIME* after = ASN1_STRING_dup(X509_get0_notAfter(cert));
    THROW_BAD_ALLOC_IF_NULL(after);

    X509_gmtime_adj(before, 0);
    X509_gmtime_adj(after, 60 * 60 * 24 * 365 * 20); // 20 yrs

    X509_set1_notBefore(cert, before);
    X509_set1_notAfter(cert, after);

    ASN1_STRING_free(before);
    ASN1_STRING_free(after);
#endif

    X509_set_pubkey(cert, pk);

    X509_NAME* name = X509_get_subject_name(cert);
    X509_NAME_add_entry_by_txt(name, "CN", MBSTRING_ASC,
                               reinterpret_cast<unsigned char *>(const_cast<char*>("NVIDIA GameStream Client")),
                               -1, -1, 0);
    X509_set_issuer_name(cert, name);

    X509_sign(cert, pk, EVP_sha256());

    BIO* biokey = BIO_new(BIO_s_mem());
    THROW_BAD_ALLOC_IF_NULL(biokey);
    PEM_write_bio_PrivateKey(biokey, pk, NULL, NULL, 0, NULL, NULL);

    BIO* biocert = BIO_new(BIO_s_mem());
    THROW_BAD_ALLOC_IF_NULL(biocert);
    PEM_write_bio_X509(biocert, cert);

    BUF_MEM* mem;
    BIO_get_mem_ptr(biokey, &mem);
    m_CachedPrivateKey = QByteArray(mem->data, (int)mem->length);

    BIO_get_mem_ptr(biocert, &mem);
    m_CachedPemCert = QByteArray(mem->data, (int)mem->length);

    X509_free(cert);
    EVP_PKEY_free(pk);
    BIO_free(biokey);
    BIO_free(biocert);

    // Check that the new keypair is valid before persisting it
    if (getSslCertificate().isNull()) {
        qFatal("Newly generated certificate is unreadable");
    }
    if (getSslKey().isNull()) {
        qFatal("Newly generated private key is unreadable");
    }

    settings.setValue(SER_CERT, m_CachedPemCert);
    settings.setValue(SER_KEY, m_CachedPrivateKey);

    qInfo() << "Wrote new identity credentials to settings";
}
```
**File:** app/backend/identitymanager.cpp (L112-139)
```cpp
IdentityManager::IdentityManager()
{
    QSettings settings;

    m_CachedPemCert = settings.value(SER_CERT).toByteArray();
    m_CachedPrivateKey = settings.value(SER_KEY).toByteArray();

    if (m_CachedPemCert.isEmpty() || m_CachedPrivateKey.isEmpty()) {
        qInfo() << "No existing credentials found";
        createCredentials(settings);
    }
    else if (getSslCertificate().isNull()) {
        qWarning() << "Certificate is unreadable";
        createCredentials(settings);
    }
    else if (getSslKey().isNull()) {
        qWarning() << "Private key is unreadable";
        createCredentials(settings);
    }

    // We should have valid credentials now. If not, we're screwed
    if (getSslCertificate().isNull()) {
        qFatal("Certificate is unreadable");
    }
    if (getSslKey().isNull()) {
        qFatal("Private key is unreadable");
    }
}
```
**File:** app/backend/identitymanager.cpp (L184-191)
```cpp
QSslConfiguration
IdentityManager::getSslConfig()
{
    QSslConfiguration sslConfig(QSslConfiguration::defaultConfiguration());
    sslConfig.setLocalCertificate(getSslCertificate());
    sslConfig.setPrivateKey(getSslKey());
    return sslConfig;
}
```
**File:** app/backend/nvhttp.cpp (L15-19)
```cpp
#define FAST_FAIL_TIMEOUT_MS 2000
#define REQUEST_TIMEOUT_MS 5000
#define LAUNCH_TIMEOUT_MS 120000
#define RESUME_TIMEOUT_MS 30000
#define QUIT_TIMEOUT_MS 30000
```
**File:** app/backend/nvhttp.cpp (L143-160)
```cpp
        catch (const GfeHttpResponseException& e)
        {
            if (e.getStatusCode() == 401)
            {
                // Certificate validation error, fallback to HTTP
                serverInfo = openConnectionToString(m_BaseUrlHttp,
                                                    "serverinfo",
                                                    nullptr,
                                                    fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                                    logLevel);
                verifyResponseStatus(serverInfo);
            }
            else
            {
                // Rethrow real errors
                throw e;
            }
        }
```
**File:** app/backend/nvhttp.cpp (L205-228)
```cpp
    QString response =
            openConnectionToString(m_BaseUrlHttps,
                                   verb,
                                   "appid="+QString::number(appId)+
                                   "&mode="+QString::number(streamConfig->width)+"x"+
                                   QString::number(streamConfig->height)+"x"+
                                   // Using an FPS value over 60 causes SOPS to default to 720p60,
                                   // so force it to 0 to ensure the correct resolution is set. We
                                   // used to use 60 here but that locked the frame rate to 60 FPS
                                   // on GFE 3.20.3. We don't need this hack for Sunshine.
                                   QString::number((streamConfig->fps > 60 && isGfe) ? 0 : streamConfig->fps)+
                                   "&additionalStates=1&sops="+QString::number(sops ? 1 : 0)+
                                   "&rikey="+QByteArray(streamConfig->remoteInputAesKey, sizeof(streamConfig->remoteInputAesKey)).toHex()+
                                   "&rikeyid="+QString::number(riKeyId)+
                                   ((streamConfig->supportedVideoFormats & VIDEO_FORMAT_MASK_10BIT) ?
                                       "&hdrMode=1&clientHdrCapVersion=0&clientHdrCapSupportedFlagsInUint32=0&clientHdrCapMetaDataId=NV_STATIC_METADATA_TYPE_1&clientHdrCapDisplayData=0x0x0x0x0x0x0x0x0x0x0" :
                                        "")+
                                   "&localAudioPlayMode="+QString::number(localAudio ? 1 : 0)+
                                   "&surroundAudioInfo="+QString::number(SURROUNDAUDIOINFO_FROM_AUDIO_CONFIGURATION(streamConfig->audioConfiguration))+
                                   "&remoteControllersBitmap="+QString::number(gamepadMask)+
                                   "&gcmap="+QString::number(gamepadMask)+
                                   "&gcpersist="+QString::number(persistGameControllersOnDisconnect ? 1 : 0)+
                                   LiGetLaunchUrlQueryParameters(),
                                   LAUNCH_TIMEOUT_MS);
```
**File:** app/backend/nvhttp.cpp (L419-439)
```cpp
void NvHTTP::handleSslErrors(QNetworkReply* reply, const QList<QSslError>& errors)
{
    bool ignoreErrors = true;

    if (m_ServerCert.isNull()) {
        // We should never make an HTTPS request without a cert
        Q_ASSERT(!m_ServerCert.isNull());
        return;
    }

    for (const QSslError& error : errors) {
        if (m_ServerCert != error.certificate()) {
            ignoreErrors = false;
            break;
        }
    }

    if (ignoreErrors) {
        reply->ignoreSslErrors(errors);
    }
}
```
**File:** app/backend/nvhttp.cpp (L486-489)
```cpp
    QNetworkRequest request(url);

    // Add our client certificate
    request.setSslConfiguration(IdentityManager::get()->getSslConfig());
```
**File:** app/backend/nvpairingmanager.cpp (L217-248)
```cpp
    QString getCert = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&phrase=getservercert&salt=" +
                                                    salt.toHex() + "&clientcert=" + IdentityManager::get()->getCertificate().toHex(),
                                                    0);
    NvHTTP::verifyResponseStatus(getCert);
    if (NvHTTP::getXmlString(getCert, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #1";
        return PairState::FAILED;
    }

    QByteArray serverCertStr = NvHTTP::getXmlStringFromHex(getCert, "plaincert");
    if (serverCertStr == nullptr)
    {
        qCritical() << "Server likely already pairing";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::ALREADY_IN_PROGRESS;
    }

    QSslCertificate unverifiedServerCert = QSslCertificate(serverCertStr);
    if (unverifiedServerCert.isNull()) {
        Q_ASSERT(!unverifiedServerCert.isNull());

        qCritical() << "Failed to parse plaincert";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    // Pin this cert for TLS until pairing is complete. If successful, we will propagate
    // the cert into the NvComputer object and persist it.
    m_Http.setServerCert(unverifiedServerCert);
```
## Q6
How to pair up computer?
### Answer
The pairing process in Moonlight uses a 5-phase handshake protocol to securely exchange certificates between the client and server. Here's how it works:

## Client Certificate Generation and Storage

The client certificate is a self-signed X.509 certificate that is generated when Moonlight first runs. It uses a 2048-bit RSA key pair with SHA-256 signature and has a 20-year validity period. moonlight-qt:29-110 

The certificate and private key are stored in QSettings and cached in memory for subsequent use. moonlight-qt:112-139 

## The 5-Phase Pairing Process

The pairing process is implemented in the `NvPairingManager::pair()` method: moonlight-qt:191-354 

### Phase 1: Certificate Exchange

The client sends its certificate to the server as a hex-encoded string in the `clientcert` parameter of an HTTP request. At the same time, it receives the server's certificate in the response: moonlight-qt:217-227 

The server returns its certificate in the `plaincert` field of the XML response: moonlight-qt:229-244 

### Phase 2-5: Challenge-Response Authentication

Once the server certificate is received, it is immediately pinned to the HTTP client for all subsequent HTTPS requests: moonlight-qt:246-248 

The remaining phases involve encrypted challenge-response exchanges and signature verification to authenticate both parties and validate the PIN.

## Certificate Pinning

The `setServerCert()` method stores the server certificate for use in HTTPS connections: moonlight-qt:43-46 

During HTTPS connections, the `handleSslErrors()` method verifies that the server certificate matches the pinned certificate, preventing man-in-the-middle attacks: moonlight-qt:419-439 

## Persisting the Server Certificate

After successful pairing, the server certificate is stored in the `NvComputer` object: moonlight-qt:113-113 

The certificate is then persisted to settings by calling `saveHost()`: moonlight-qt:599-603 

## Notes

The pairing process uses AES-128-ECB encryption for challenge exchanges, with the encryption key derived from a salted PIN hash (SHA-256 for Gen 7+ servers, SHA-1 for older versions). The client certificate is sent as plain hex-encoded PEM data in Phase 1, while the server certificate is also returned as hex-encoded PEM. This certificate exchange happens over HTTP initially, but all subsequent pairing phases use HTTPS with the newly pinned certificate to ensure secure communication.
### Citations
**File:** app/backend/identitymanager.cpp (L29-110)
```cpp
void IdentityManager::createCredentials(QSettings& settings)
{
    X509* cert = X509_new();
    THROW_BAD_ALLOC_IF_NULL(cert);

    EVP_PKEY_CTX* ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_RSA, NULL);
    THROW_BAD_ALLOC_IF_NULL(ctx);

    EVP_PKEY_keygen_init(ctx);
    EVP_PKEY_CTX_set_rsa_keygen_bits(ctx, 2048);

    // pk must be initialized on input
    EVP_PKEY* pk = NULL;
    EVP_PKEY_keygen(ctx, &pk);

    EVP_PKEY_CTX_free(ctx);
    THROW_BAD_ALLOC_IF_NULL(pk);

    X509_set_version(cert, 2);
    ASN1_INTEGER_set(X509_get_serialNumber(cert), 0);
#if OPENSSL_VERSION_NUMBER < 0x10100000L
    X509_gmtime_adj(X509_get_notBefore(cert), 0);
    X509_gmtime_adj(X509_get_notAfter(cert), 60 * 60 * 24 * 365 * 20); // 20 yrs
#else
    ASN1_TIME* before = ASN1_STRING_dup(X509_get0_notBefore(cert));
    THROW_BAD_ALLOC_IF_NULL(before);
    ASN1_TIME* after = ASN1_STRING_dup(X509_get0_notAfter(cert));
    THROW_BAD_ALLOC_IF_NULL(after);

    X509_gmtime_adj(before, 0);
    X509_gmtime_adj(after, 60 * 60 * 24 * 365 * 20); // 20 yrs

    X509_set1_notBefore(cert, before);
    X509_set1_notAfter(cert, after);

    ASN1_STRING_free(before);
    ASN1_STRING_free(after);
#endif

    X509_set_pubkey(cert, pk);

    X509_NAME* name = X509_get_subject_name(cert);
    X509_NAME_add_entry_by_txt(name, "CN", MBSTRING_ASC,
                               reinterpret_cast<unsigned char *>(const_cast<char*>("NVIDIA GameStream Client")),
                               -1, -1, 0);
    X509_set_issuer_name(cert, name);

    X509_sign(cert, pk, EVP_sha256());

    BIO* biokey = BIO_new(BIO_s_mem());
    THROW_BAD_ALLOC_IF_NULL(biokey);
    PEM_write_bio_PrivateKey(biokey, pk, NULL, NULL, 0, NULL, NULL);

    BIO* biocert = BIO_new(BIO_s_mem());
    THROW_BAD_ALLOC_IF_NULL(biocert);
    PEM_write_bio_X509(biocert, cert);

    BUF_MEM* mem;
    BIO_get_mem_ptr(biokey, &mem);
    m_CachedPrivateKey = QByteArray(mem->data, (int)mem->length);

    BIO_get_mem_ptr(biocert, &mem);
    m_CachedPemCert = QByteArray(mem->data, (int)mem->length);

    X509_free(cert);
    EVP_PKEY_free(pk);
    BIO_free(biokey);
    BIO_free(biocert);

    // Check that the new keypair is valid before persisting it
    if (getSslCertificate().isNull()) {
        qFatal("Newly generated certificate is unreadable");
    }
    if (getSslKey().isNull()) {
        qFatal("Newly generated private key is unreadable");
    }

    settings.setValue(SER_CERT, m_CachedPemCert);
    settings.setValue(SER_KEY, m_CachedPrivateKey);

    qInfo() << "Wrote new identity credentials to settings";
}
```
**File:** app/backend/identitymanager.cpp (L112-139)
```cpp
IdentityManager::IdentityManager()
{
    QSettings settings;

    m_CachedPemCert = settings.value(SER_CERT).toByteArray();
    m_CachedPrivateKey = settings.value(SER_KEY).toByteArray();

    if (m_CachedPemCert.isEmpty() || m_CachedPrivateKey.isEmpty()) {
        qInfo() << "No existing credentials found";
        createCredentials(settings);
    }
    else if (getSslCertificate().isNull()) {
        qWarning() << "Certificate is unreadable";
        createCredentials(settings);
    }
    else if (getSslKey().isNull()) {
        qWarning() << "Private key is unreadable";
        createCredentials(settings);
    }

    // We should have valid credentials now. If not, we're screwed
    if (getSslCertificate().isNull()) {
        qFatal("Certificate is unreadable");
    }
    if (getSslKey().isNull()) {
        qFatal("Private key is unreadable");
    }
}
```
**File:** app/backend/nvpairingmanager.cpp (L191-354)
```cpp
NvPairingManager::pair(QString appVersion, QString pin, QSslCertificate& serverCert)
{
    int serverMajorVersion = NvHTTP::parseQuad(appVersion).at(0);
    qInfo() << "Pairing with server generation:" << serverMajorVersion;

    QCryptographicHash::Algorithm hashAlgo;
    int hashLength;
    if (serverMajorVersion >= 7)
    {
        // Gen 7+ uses SHA-256 hashing
        hashAlgo = QCryptographicHash::Sha256;
        hashLength = 32;
    }
    else
    {
        // Prior to Gen 7 uses SHA-1 hashing
        hashAlgo = QCryptographicHash::Sha1;
        hashLength = 20;
    }

    QByteArray salt = generateRandomBytes(16);
    QByteArray saltedPin = saltPin(salt, pin);

    QByteArray aesKey = QCryptographicHash::hash(saltedPin, hashAlgo).constData();
    aesKey.truncate(16);

    QString getCert = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&phrase=getservercert&salt=" +
                                                    salt.toHex() + "&clientcert=" + IdentityManager::get()->getCertificate().toHex(),
                                                    0);
    NvHTTP::verifyResponseStatus(getCert);
    if (NvHTTP::getXmlString(getCert, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #1";
        return PairState::FAILED;
    }

    QByteArray serverCertStr = NvHTTP::getXmlStringFromHex(getCert, "plaincert");
    if (serverCertStr == nullptr)
    {
        qCritical() << "Server likely already pairing";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::ALREADY_IN_PROGRESS;
    }

    QSslCertificate unverifiedServerCert = QSslCertificate(serverCertStr);
    if (unverifiedServerCert.isNull()) {
        Q_ASSERT(!unverifiedServerCert.isNull());

        qCritical() << "Failed to parse plaincert";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    // Pin this cert for TLS until pairing is complete. If successful, we will propagate
    // the cert into the NvComputer object and persist it.
    m_Http.setServerCert(unverifiedServerCert);

    QByteArray randomChallenge = generateRandomBytes(16);
    QByteArray encryptedChallenge = encrypt(randomChallenge, aesKey);
    QString challengeXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                         "pair",
                                                         "devicename=roth&updateState=1&clientchallenge=" +
                                                         encryptedChallenge.toHex(),
                                                         REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(challengeXml);
    if (NvHTTP::getXmlString(challengeXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #2";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray challengeResponseData = decrypt(m_Http.getXmlStringFromHex(challengeXml, "challengeresponse"), aesKey);
    QByteArray clientSecretData = generateRandomBytes(16);
    QByteArray challengeResponse;
    QByteArray serverResponse(challengeResponseData.data(), hashLength);

#if (OPENSSL_VERSION_NUMBER < 0x10002000L)
    ASN1_BIT_STRING *asnSignature = m_Cert->signature;
#elif (OPENSSL_VERSION_NUMBER < 0x10100000L)
    ASN1_BIT_STRING *asnSignature;
    X509_get0_signature(&asnSignature, NULL, m_Cert);
#else
    const ASN1_BIT_STRING *asnSignature;
    X509_get0_signature(&asnSignature, NULL, m_Cert);
#endif

    challengeResponse.append(challengeResponseData.data() + hashLength, 16);
    challengeResponse.append(reinterpret_cast<char*>(asnSignature->data), asnSignature->length);
    challengeResponse.append(clientSecretData);

    QByteArray paddedHash = QCryptographicHash::hash(challengeResponse, hashAlgo);
    paddedHash.resize(32);
    QByteArray encryptedChallengeResponseHash = encrypt(paddedHash, aesKey);
    QString respXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&serverchallengeresp=" +
                                                    encryptedChallengeResponseHash.toHex(),
                                                    REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(respXml);
    if (NvHTTP::getXmlString(respXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #3";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray pairingSecret = NvHTTP::getXmlStringFromHex(respXml, "pairingsecret");
    QByteArray serverSecret = pairingSecret.left(16);
    QByteArray serverSignature = pairingSecret.mid(16);

    if (!verifySignature(serverSecret,
                         serverSignature,
                         serverCertStr))
    {
        qCritical() << "MITM detected";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray expectedResponseData;
    expectedResponseData.append(randomChallenge);
    expectedResponseData.append(getSignatureFromPemCert(serverCertStr));
    expectedResponseData.append(serverSecret);
    if (QCryptographicHash::hash(expectedResponseData, hashAlgo) != serverResponse)
    {
        qCritical() << "Incorrect PIN";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::PIN_WRONG;
    }

    QByteArray clientPairingSecret;
    clientPairingSecret.append(clientSecretData);
    clientPairingSecret.append(signMessage(clientSecretData));

    QString secretRespXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                          "pair",
                                                          "devicename=roth&updateState=1&clientpairingsecret=" +
                                                          clientPairingSecret.toHex(),
                                                          REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(secretRespXml);
    if (NvHTTP::getXmlString(secretRespXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #4";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QString pairChallengeXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttps,
                                                             "pair",
                                                             "devicename=roth&updateState=1&phrase=pairchallenge",
                                                             REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(pairChallengeXml);
    if (NvHTTP::getXmlString(pairChallengeXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #5";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    serverCert = std::move(unverifiedServerCert);
    return PairState::PAIRED;
```
**File:** app/backend/nvhttp.cpp (L43-46)
```cpp
void NvHTTP::setServerCert(QSslCertificate serverCert)
{
    m_ServerCert = serverCert;
}
```
**File:** app/backend/nvhttp.cpp (L419-439)
```cpp
void NvHTTP::handleSslErrors(QNetworkReply* reply, const QList<QSslError>& errors)
{
    bool ignoreErrors = true;

    if (m_ServerCert.isNull()) {
        // We should never make an HTTPS request without a cert
        Q_ASSERT(!m_ServerCert.isNull());
        return;
    }

    for (const QSslError& error : errors) {
        if (m_ServerCert != error.certificate()) {
            ignoreErrors = false;
            break;
        }
    }

    if (ignoreErrors) {
        reply->ignoreSslErrors(errors);
    }
}
```
**File:** app/backend/nvcomputer.h (L113-113)
```text
    QSslCertificate serverCert;
```
**File:** app/backend/computermanager.cpp (L599-603)
```cpp
           case NvPairingManager::PairState::PAIRED:
               // Persist the newly pinned server certificate for this host
               m_ComputerManager->saveHost(m_Computer);

               emit pairingCompleted(m_Computer, nullptr);
```
## Q7
When the client has launched/started the game and begun streaming before disconnecting, how does the client recover the connection?
### Answer
You're asking about how Moonlight handles connection recovery when a streaming session disconnects after it has already started.

## Answer

When a streaming session disconnects, Moonlight determines whether to call `/launch` or `/resume` based on the `currentgame` value from the host's `/serverinfo` response. moonlight-qt:1586-1586 

### Resume vs Launch Decision

In `Session::startConnectionAsync()`, the code checks if `m_Computer->currentgame` is non-zero (indicating a game is already running on the host): moonlight-qt:1556-1557 

If the game is already running, it calls `NvHTTP::startApp()` with the `"resume"` parameter instead of `"launch"`: moonlight-qt:1586-1593 

```cpp
http.startApp(m_Computer->currentgame != 0 ? "resume" : "launch",
              m_Computer->isNvidiaServerSoftware,
              m_App.id, &m_StreamConfig,
              enableGameOptimizations,
              m_Preferences->playAudioOnHost,
              m_InputHandler->getAttachedGamepadMask(),
              !m_Preferences->multiController,
              rtspSessionUrl);
```

### How Resume Works

The `/resume` endpoint tells the host to reconnect to an existing game session rather than starting a new one.<cite /> This preserves the game state and allows the client to rejoin the same streaming session.<cite />

The same connection establishment process follows after calling `/resume` - the RTSP session URL is obtained from the response and passed to `LiStartConnection()` to establish the streaming connection. moonlight-qt:1678-1680 

### State Detection

The host's state is tracked through periodic `/serverinfo` polling, which updates the `currentgame` field in the `NvComputer` object.<cite /> When the state shows `SUNSHINE_SERVER_BUSY` (as in your earlier example) with a non-zero `currentgame` value, Moonlight knows a game is already running and will use resume instead of launch.<cite />

## Notes

The resume functionality allows seamless reconnection to an existing game session without restarting the game on the host. This is particularly useful for temporary network interruptions or when the client application crashes but the host game continues running. The same certificate authentication and connection establishment process is used for both launch and resume operations.

Wiki pages you might want to explore:
- [User Interface System (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2)
- [Streaming Core (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#4)
### Citations
**File:** app/streaming/session.cpp (L1556-1557)
```cpp
    Q_ASSERT(m_Computer->currentGameId == 0 ||
             m_Computer->currentGameId == m_App.id);
```
**File:** app/streaming/session.cpp (L1586-1593)
```cpp
        http.startApp(m_Computer->currentGameId != 0 ? "resume" : "launch",
                      m_Computer->isNvidiaServerSoftware,
                      m_App.id, &m_StreamConfig,
                      enableGameOptimizations,
                      m_Preferences->playAudioOnHost,
                      m_InputHandler->getAttachedGamepadMask(),
                      !m_Preferences->multiController,
                      rtspSessionUrl);
```
**File:** app/streaming/session.cpp (L1678-1680)
```cpp
    int err = LiStartConnection(&hostInfo, &m_StreamConfig, &k_ConnCallbacks,
                                &m_VideoCallbacks, &m_AudioCallbacks,
                                NULL, 0, NULL, 0);
```
## Q8
How does the client terminate the connection?
### Answer
You're asking about how Moonlight terminates a streaming connection when the user wants to disconnect.

## Answer

Moonlight provides multiple ways to terminate a streaming connection:

### User-Initiated Disconnection

Users can disconnect from an active streaming session using keyboard shortcuts or gamepad button combinations. The UI displays a tip showing these options: **Ctrl+Alt+Shift+Q** for keyboard or **Start+Select+L1+R1** for gamepad. moonlight-qt:167-168 

### Connection Termination Flow

When a connection terminates, the `Session::clConnectionTerminated()` callback is invoked with an error code. moonlight-qt:98-155  This callback:

1. **Performs port testing** to diagnose connectivity issues if the termination was unexpected moonlight-qt:100-101 

2. **Determines if termination was graceful** - If the error code is `ML_ERROR_GRACEFUL_TERMINATION`, no error dialog is shown moonlight-qt:105-106 

3. **Displays error messages** for unexpected terminations (network issues, video encoding errors, etc.) moonlight-qt:108-144 

4. **Pushes a quit event** to the SDL event loop to exit the streaming session moonlight-qt:150-154 

### UI Cleanup After Termination

After the session ends, the `StreamSegue::sessionFinished()` method handles cleanup: moonlight-qt:73-108 

1. **Re-enables gamepad navigation** for the UI moonlight-qt:79-80 

2. **Pops the stream view** from the navigation stack to return to the previous screen moonlight-qt:93-94 

3. **Shows the main window** again moonlight-qt:96-97 

4. **Displays any error dialogs** if the termination was unexpected moonlight-qt:103-106 

The session object is then garbage collected to free resources. moonlight-qt:110-116 

### Quitting Running Apps

Moonlight can also terminate a running game on the host without streaming it. The `ComputerManager::quitRunningApp()` method creates a `PendingQuitTask` that sends a quit request to the host server. moonlight-qt:675-682  This is used when users want to stop a game remotely without connecting to it.

## Notes

The termination process distinguishes between graceful disconnections (user-initiated) and unexpected terminations (network errors, encoding failures). For unexpected terminations, Moonlight performs network diagnostics and displays helpful error messages to guide troubleshooting. The same cleanup process applies whether the user disconnects manually or the connection fails unexpectedly.

Wiki pages you might want to explore:
- [User Interface System (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2)
- [PC Discovery View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.1)
### Citations
**File:** app/gui/StreamSegue.qml (L73-108)
```text
    function sessionFinished(portTestResult)
    {
        if (portTestResult !== 0 && portTestResult !== -1 && streamSegueErrorDialog.text) {
            streamSegueErrorDialog.text += "\n\n" + qsTr("This PC's Internet connection is blocking Moonlight. Streaming over the Internet may not work while connected to this network.")
        }

        // Re-enable GUI gamepad usage now
        SdlGamepadKeyNavigation.enable()

        if (quitAfter) {
            if (streamSegueErrorDialog.text) {
                // Quit when the error dialog is acknowledged
                streamSegueErrorDialog.quitAfter = quitAfter
                streamSegueErrorDialog.open()
            }
            else {
                // Quit immediately
                Qt.quit()
            }
        } else {
            // Exit this view
            stackView.pop()

            // Show the Qt window again after streaming
            window.visible = true

            // Display any launch errors. We do this after
            // the Qt UI is visible again to prevent losing
            // focus on the dialog which would impact gamepad
            // users.
            if (streamSegueErrorDialog.text) {
                streamSegueErrorDialog.quitAfter = quitAfter
                streamSegueErrorDialog.open()
            }
        }
    }
```
**File:** app/gui/StreamSegue.qml (L110-116)
```text
    function sessionReadyForDeletion()
    {
        // Garbage collect the Session object since it's pretty heavyweight
        // and keeps other libraries (like SDL_TTF) around until it is deleted.
        session = null
        gc()
    }
```
**File:** app/gui/StreamSegue.qml (L167-168)
```text
            hintText.text = qsTr("Tip:") + " " + qsTr("Press %1 to disconnect your session").arg(SdlGamepadKeyNavigation.getConnectedGamepads() > 0 ?
                                                  qsTr("Start+Select+L1+R1") : qsTr("Ctrl+Alt+Shift+Q"))
```
**File:** app/streaming/session.cpp (L98-155)
```cpp
void Session::clConnectionTerminated(int errorCode)
{
    unsigned int portFlags = LiGetPortFlagsFromTerminationErrorCode(errorCode);
    s_ActiveSession->m_PortTestResults = LiTestClientConnectivity(CONN_TEST_SERVER, 443, portFlags);

    // Display the termination dialog if this was not intended
    switch (errorCode) {
    case ML_ERROR_GRACEFUL_TERMINATION:
        break;

    case ML_ERROR_NO_VIDEO_TRAFFIC:
        s_ActiveSession->m_UnexpectedTermination = true;

        char ports[128];
        SDL_assert(portFlags != 0);
        LiStringifyPortFlags(portFlags, ", ", ports, sizeof(ports));
        emit s_ActiveSession->displayLaunchError(tr("No video received from host.") + "\n\n"+
                                                 tr("Check your firewall and port forwarding rules for port(s): %1").arg(ports));
        break;

    case ML_ERROR_NO_VIDEO_FRAME:
        s_ActiveSession->m_UnexpectedTermination = true;
        emit s_ActiveSession->displayLaunchError(tr("Your network connection isn't performing well. Reduce your video bitrate setting or try a faster connection."));
        break;

    case ML_ERROR_PROTECTED_CONTENT:
    case ML_ERROR_UNEXPECTED_EARLY_TERMINATION:
        s_ActiveSession->m_UnexpectedTermination = true;
        emit s_ActiveSession->displayLaunchError(tr("Something went wrong on your host PC when starting the stream.") + "\n\n" +
                                                 tr("Make sure you don't have any DRM-protected content open on your host PC. You can also try restarting your host PC."));
        break;

    case ML_ERROR_FRAME_CONVERSION:
        s_ActiveSession->m_UnexpectedTermination = true;
        emit s_ActiveSession->displayLaunchError(tr("The host PC reported a fatal video encoding error.") + "\n\n" +
                                                 tr("Try disabling HDR mode, changing the streaming resolution, or changing your host PC's display resolution."));
        break;

    default:
        s_ActiveSession->m_UnexpectedTermination = true;

        // We'll assume large errors are hex values
        bool hexError = qAbs(errorCode) > 1000;
        emit s_ActiveSession->displayLaunchError(tr("Connection terminated") + "\n\n" +
                                                 tr("Error code: %1").arg(errorCode, hexError ? 8 : 0, hexError ? 16 : 10, QChar('0')));
        break;
    }

    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION,
                 "Connection terminated: %d",
                 errorCode);

    // Push a quit event to the main loop
    SDL_Event event;
    event.type = SDL_QUIT;
    event.quit.timestamp = SDL_GetTicks();
    SDL_PushEvent(&event);
}
```
**File:** app/backend/computermanager.cpp (L675-682)
```cpp
void ComputerManager::quitRunningApp(NvComputer* computer)
{
    QWriteLocker lock(&computer->lock);
    computer->pendingQuit = true;

    PendingQuitTask* quit = new PendingQuitTask(this, computer);
    QThreadPool::globalInstance()->start(quit);
}
```
## Q9
Please list all the APIs used for the client and server interaction, including their purposes and required parameters, and list the APIs needed for the entire process from adding a computer to selecting one in the app list and starting a connection to ending the connection.
### Answer
Based on my analysis of the Moonlight codebase, here are all the client-server interaction APIs used throughout the entire process:

## 1. **Adding a Computer**

### Server Discovery - `serverinfo` API
**Purpose**: Discover and retrieve information about the host PC, including pairing status, current game, server version, and HTTPS port. moonlight-qt:124-187 

**Required Parameters**:
- `uniqueid`: Common UID for Moonlight clients (fixed: "0123456789ABCDEF")
- `uuid`: Random UUID for the request

**Protocol**: HTTP initially (before pairing), then HTTPS (after pairing)

### Pairing - 5-Phase Cryptographic Handshake

**Purpose**: Establish trust between client and host PC through certificate exchange and PIN verification. moonlight-qt:191-355 

**Phase 1 - Get Server Certificate**:
- Endpoint: `pair`
- Parameters:
  - `devicename=roth`
  - `updateState=1`
  - `phrase=getservercert`
  - `salt`: 16-byte random salt (hex)
  - `clientcert`: Client certificate (hex)

**Phase 2 - Client Challenge**:
- Endpoint: `pair`
- Parameters:
  - `devicename=roth`
  - `updateState=1`
  - `clientchallenge`: Encrypted 16-byte challenge (hex)

**Phase 3 - Server Challenge Response**:
- Endpoint: `pair`
- Parameters:
  - `devicename=roth`
  - `updateState=1`
  - `serverchallengeresp`: Encrypted challenge response hash (hex)

**Phase 4 - Client Pairing Secret**:
- Endpoint: `pair`
- Parameters:
  - `devicename=roth`
  - `updateState=1`
  - `clientpairingsecret`: Client secret + signature (hex)

**Phase 5 - Final Challenge (HTTPS)**:
- Endpoint: `pair`
- Parameters:
  - `devicename=roth`
  - `updateState=1`
  - `phrase=pairchallenge`

**Protocol**: HTTP for phases 1-4, HTTPS for phase 5

## 2. **Selecting an App**

### App List - `applist` API
**Purpose**: Retrieve the list of available applications on the host PC. moonlight-qt:288-328 

**Required Parameters**:
- `uniqueid`: "0123456789ABCDEF"
- `uuid`: Random UUID

**Protocol**: HTTPS (requires prior pairing)

**Response**: XML with app information including:
- `AppTitle`: Application name
- `ID`: Application ID
- `IsHdrSupported`: HDR capability
- `IsAppCollectorGame`: Whether it's an App Collector game

### Box Art - `getBoxArt` API
**Purpose**: Download application cover art/thumbnails. moonlight-qt:178-179 moonlight-qt:107-129 

**Required Parameters**:
- `appId`: Application ID

**Protocol**: HTTPS
**Response**: Image data (various formats, cached as PNG locally)

## 3. **Starting a Streaming Connection**

### Launch/Resume - `launch` or `resume` API
**Purpose**: Start a new streaming session or resume an existing one. moonlight-qt:190-236 moonlight-qt:1582-1600 

**Endpoint**: `launch` (new session) or `resume` (existing session)

**Required Parameters**:
- `uniqueid`: "0123456789ABCDEF"
- `uuid`: Random UUID
- `appid`: Application ID to launch
- `mode`: Resolution and FPS (format: `{width}x{height}x{fps}`)
- `additionalStates=1`: Enable additional states
- `sops`: Stream optimization settings (0 or 1)
- `rikey`: Remote input AES key (hex)
- `rikeyid`: Remote input key ID
- `hdrMode`: HDR mode flag (included if HDR supported)
- `clientHdrCapVersion`, `clientHdrCapSupportedFlagsInUint32`, `clientHdrCapMetaDataId`, `clientHdrCapDisplayData`: HDR capability parameters (if HDR mode)
- `localAudioPlayMode`: Play audio on host (0 or 1)
- `surroundAudioInfo`: Surround audio configuration
- `remoteControllersBitmap`: Gamepad mask
- `gcmap`: Gamepad controller map
- `gcpersist`: Persist game controllers on disconnect (0 or 1)
- Additional parameters from `LiGetLaunchUrlQueryParameters()`

**Protocol**: HTTPS

**Response**: XML containing `sessionUrl0` (RTSP session URL)

**Decision Logic**: The verb is determined based on whether a game is currently running: moonlight-qt:1586-1593 

## 4. **Ending a Streaming Connection**

### Quit App - `cancel` API
**Purpose**: Terminate the currently running application on the host PC. moonlight-qt:238-259 

**Required Parameters**:
- `uniqueid`: "0123456789ABCDEF"
- `uuid`: Random UUID

**Protocol**: HTTPS

**Timeout**: 30 seconds

**Note**: The quit operation is optional based on user preferences: moonlight-qt:1554-1558 

## Additional APIs

### Wake-on-LAN
**Purpose**: Wake up a sleeping/powered-off host PC. moonlight-qt:1-50 

**Protocol**: UDP magic packets sent to multiple addresses and ports (9, 47009, and dynamic ports 47998-48010)

### Unpair - `unpair` API
**Purpose**: Remove pairing relationship (used during pairing failures). moonlight-qt:232-234 

**Required Parameters**: Standard uniqueid and uuid

**Protocol**: HTTP

## Notes

- All HTTP/HTTPS requests use a common `uniqueid` of "0123456789ABCDEF" to allow Moonlight clients to manage each other's sessions
- Each request includes a random `uuid` parameter generated via `QUuid::createUuid()`
- Certificate pinning is implemented for HTTPS connections to prevent MITM attacks
- Timeouts vary by operation: 2s (fast-fail), 5s (normal), 30s (resume/quit), 120s (launch)
- The base URL format is `http(s)://{host}:{port}/{command}?{parameters}`
### Citations
**File:** app/backend/nvhttp.cpp (L124-187)
```cpp
NvHTTP::getServerInfo(NvLogLevel logLevel, bool fastFail)
{
    QString serverInfo;

    // Check if we have a pinned cert and HTTPS port for this host yet
    if (!m_ServerCert.isNull() && httpsPort() != 0)
    {
        try
        {
            // Always try HTTPS first, since it properly reports
            // pairing status (and a few other attributes).
            serverInfo = openConnectionToString(m_BaseUrlHttps,
                                                "serverinfo",
                                                nullptr,
                                                fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                                logLevel);
            // Throws if the request failed
            verifyResponseStatus(serverInfo);
        }
        catch (const GfeHttpResponseException& e)
        {
            if (e.getStatusCode() == 401)
            {
                // Certificate validation error, fallback to HTTP
                serverInfo = openConnectionToString(m_BaseUrlHttp,
                                                    "serverinfo",
                                                    nullptr,
                                                    fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                                    logLevel);
                verifyResponseStatus(serverInfo);
            }
            else
            {
                // Rethrow real errors
                throw e;
            }
        }
    }
    else
    {
        // Only use HTTP prior to pairing or fetching HTTPS port
        serverInfo = openConnectionToString(m_BaseUrlHttp,
                                            "serverinfo",
                                            nullptr,
                                            fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                            logLevel);
        verifyResponseStatus(serverInfo);

        // Populate the HTTPS port
        uint16_t httpsPort = getXmlString(serverInfo, "HttpsPort").toUShort();
        if (httpsPort == 0) {
            httpsPort = DEFAULT_HTTPS_PORT;
        }
        setHttpsPort(httpsPort);

        // If we just needed to determine the HTTPS port, we'll try again over
        // HTTPS now that we have the port number
        if (!m_ServerCert.isNull()) {
            return getServerInfo(logLevel, fastFail);
        }
    }

    return serverInfo;
}
```
**File:** app/backend/nvhttp.cpp (L190-236)
```cpp
NvHTTP::startApp(QString verb,
                 bool isGfe,
                 int appId,
                 PSTREAM_CONFIGURATION streamConfig,
                 bool sops,
                 bool localAudio,
                 int gamepadMask,
                 bool persistGameControllersOnDisconnect,
                 QString& rtspSessionUrl)
{
    int riKeyId;

    memcpy(&riKeyId, streamConfig->remoteInputAesIv, sizeof(riKeyId));
    riKeyId = qFromBigEndian(riKeyId);

    QString response =
            openConnectionToString(m_BaseUrlHttps,
                                   verb,
                                   "appid="+QString::number(appId)+
                                   "&mode="+QString::number(streamConfig->width)+"x"+
                                   QString::number(streamConfig->height)+"x"+
                                   // Using an FPS value over 60 causes SOPS to default to 720p60,
                                   // so force it to 0 to ensure the correct resolution is set. We
                                   // used to use 60 here but that locked the frame rate to 60 FPS
                                   // on GFE 3.20.3. We don't need this hack for Sunshine.
                                   QString::number((streamConfig->fps > 60 && isGfe) ? 0 : streamConfig->fps)+
                                   "&additionalStates=1&sops="+QString::number(sops ? 1 : 0)+
                                   "&rikey="+QByteArray(streamConfig->remoteInputAesKey, sizeof(streamConfig->remoteInputAesKey)).toHex()+
                                   "&rikeyid="+QString::number(riKeyId)+
                                   ((streamConfig->supportedVideoFormats & VIDEO_FORMAT_MASK_10BIT) ?
                                       "&hdrMode=1&clientHdrCapVersion=0&clientHdrCapSupportedFlagsInUint32=0&clientHdrCapMetaDataId=NV_STATIC_METADATA_TYPE_1&clientHdrCapDisplayData=0x0x0x0x0x0x0x0x0x0x0" :
                                        "")+
                                   "&localAudioPlayMode="+QString::number(localAudio ? 1 : 0)+
                                   "&surroundAudioInfo="+QString::number(SURROUNDAUDIOINFO_FROM_AUDIO_CONFIGURATION(streamConfig->audioConfiguration))+
                                   "&remoteControllersBitmap="+QString::number(gamepadMask)+
                                   "&gcmap="+QString::number(gamepadMask)+
                                   "&gcpersist="+QString::number(persistGameControllersOnDisconnect ? 1 : 0)+
                                   LiGetLaunchUrlQueryParameters(),
                                   LAUNCH_TIMEOUT_MS);

    qInfo() << "Launch response:" << response;

    // Throws if the request failed
    verifyResponseStatus(response);

    rtspSessionUrl = getXmlString(response, "sessionUrl0");
}
```
**File:** app/backend/nvhttp.cpp (L238-259)
```cpp
void
NvHTTP::quitApp()
{
    QString response =
            openConnectionToString(m_BaseUrlHttps,
                                   "cancel",
                                   nullptr,
                                   QUIT_TIMEOUT_MS);

    qInfo() << "Quit response:" << response;

    // Throws if the request failed
    verifyResponseStatus(response);

    // Newer GFE versions will just return success even if quitting fails
    // if we're not the original requester.
    if (getCurrentGame(getServerInfo(NvHTTP::NVLL_ERROR)) != 0) {
        // Generate a synthetic GfeResponseException letting the caller know
        // that they can't kill someone else's stream.
        throw GfeHttpResponseException(599, "");
    }
}
```
**File:** app/backend/nvhttp.cpp (L288-328)
```cpp
QVector<NvApp>
NvHTTP::getAppList()
{
    QString appxml = openConnectionToString(m_BaseUrlHttps,
                                            "applist",
                                            nullptr,
                                            REQUEST_TIMEOUT_MS,
                                            NvLogLevel::NVLL_ERROR);
    verifyResponseStatus(appxml);

    QXmlStreamReader xmlReader(appxml);
    QVector<NvApp> apps;
    while (!xmlReader.atEnd()) {
        while (xmlReader.readNextStartElement()) {
            auto name = xmlReader.name();
            if (name == QString("App")) {
                // We must have a valid app before advancing to the next one
                if (!apps.isEmpty() && !apps.last().isInitialized()) {
                    qWarning() << "Invalid applist XML";
                    Q_ASSERT(false);
                    return QVector<NvApp>();
                }
                apps.append(NvApp());
            }
            else if (name == QString("AppTitle")) {
                apps.last().name = xmlReader.readElementText();
            }
            else if (name == QString("ID")) {
                apps.last().id = xmlReader.readElementText().toInt();
            }
            else if (name == QString("IsHdrSupported")) {
                apps.last().hdrSupported = xmlReader.readElementText() == "1";
            }
            else if (name == QString("IsAppCollectorGame")) {
                apps.last().isAppCollectorGame = xmlReader.readElementText() == "1";
            }
        }
    }

    return apps;
}
```
**File:** app/backend/nvpairingmanager.cpp (L191-355)
```cpp
NvPairingManager::pair(QString appVersion, QString pin, QSslCertificate& serverCert)
{
    int serverMajorVersion = NvHTTP::parseQuad(appVersion).at(0);
    qInfo() << "Pairing with server generation:" << serverMajorVersion;

    QCryptographicHash::Algorithm hashAlgo;
    int hashLength;
    if (serverMajorVersion >= 7)
    {
        // Gen 7+ uses SHA-256 hashing
        hashAlgo = QCryptographicHash::Sha256;
        hashLength = 32;
    }
    else
    {
        // Prior to Gen 7 uses SHA-1 hashing
        hashAlgo = QCryptographicHash::Sha1;
        hashLength = 20;
    }

    QByteArray salt = generateRandomBytes(16);
    QByteArray saltedPin = saltPin(salt, pin);

    QByteArray aesKey = QCryptographicHash::hash(saltedPin, hashAlgo).constData();
    aesKey.truncate(16);

    QString getCert = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&phrase=getservercert&salt=" +
                                                    salt.toHex() + "&clientcert=" + IdentityManager::get()->getCertificate().toHex(),
                                                    0);
    NvHTTP::verifyResponseStatus(getCert);
    if (NvHTTP::getXmlString(getCert, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #1";
        return PairState::FAILED;
    }

    QByteArray serverCertStr = NvHTTP::getXmlStringFromHex(getCert, "plaincert");
    if (serverCertStr == nullptr)
    {
        qCritical() << "Server likely already pairing";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::ALREADY_IN_PROGRESS;
    }

    QSslCertificate unverifiedServerCert = QSslCertificate(serverCertStr);
    if (unverifiedServerCert.isNull()) {
        Q_ASSERT(!unverifiedServerCert.isNull());

        qCritical() << "Failed to parse plaincert";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    // Pin this cert for TLS until pairing is complete. If successful, we will propagate
    // the cert into the NvComputer object and persist it.
    m_Http.setServerCert(unverifiedServerCert);

    QByteArray randomChallenge = generateRandomBytes(16);
    QByteArray encryptedChallenge = encrypt(randomChallenge, aesKey);
    QString challengeXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                         "pair",
                                                         "devicename=roth&updateState=1&clientchallenge=" +
                                                         encryptedChallenge.toHex(),
                                                         REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(challengeXml);
    if (NvHTTP::getXmlString(challengeXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #2";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray challengeResponseData = decrypt(m_Http.getXmlStringFromHex(challengeXml, "challengeresponse"), aesKey);
    QByteArray clientSecretData = generateRandomBytes(16);
    QByteArray challengeResponse;
    QByteArray serverResponse(challengeResponseData.data(), hashLength);

#if (OPENSSL_VERSION_NUMBER < 0x10002000L)
    ASN1_BIT_STRING *asnSignature = m_Cert->signature;
#elif (OPENSSL_VERSION_NUMBER < 0x10100000L)
    ASN1_BIT_STRING *asnSignature;
    X509_get0_signature(&asnSignature, NULL, m_Cert);
#else
    const ASN1_BIT_STRING *asnSignature;
    X509_get0_signature(&asnSignature, NULL, m_Cert);
#endif

    challengeResponse.append(challengeResponseData.data() + hashLength, 16);
    challengeResponse.append(reinterpret_cast<char*>(asnSignature->data), asnSignature->length);
    challengeResponse.append(clientSecretData);

    QByteArray paddedHash = QCryptographicHash::hash(challengeResponse, hashAlgo);
    paddedHash.resize(32);
    QByteArray encryptedChallengeResponseHash = encrypt(paddedHash, aesKey);
    QString respXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&serverchallengeresp=" +
                                                    encryptedChallengeResponseHash.toHex(),
                                                    REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(respXml);
    if (NvHTTP::getXmlString(respXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #3";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray pairingSecret = NvHTTP::getXmlStringFromHex(respXml, "pairingsecret");
    QByteArray serverSecret = pairingSecret.left(16);
    QByteArray serverSignature = pairingSecret.mid(16);

    if (!verifySignature(serverSecret,
                         serverSignature,
                         serverCertStr))
    {
        qCritical() << "MITM detected";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray expectedResponseData;
    expectedResponseData.append(randomChallenge);
    expectedResponseData.append(getSignatureFromPemCert(serverCertStr));
    expectedResponseData.append(serverSecret);
    if (QCryptographicHash::hash(expectedResponseData, hashAlgo) != serverResponse)
    {
        qCritical() << "Incorrect PIN";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::PIN_WRONG;
    }

    QByteArray clientPairingSecret;
    clientPairingSecret.append(clientSecretData);
    clientPairingSecret.append(signMessage(clientSecretData));

    QString secretRespXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                          "pair",
                                                          "devicename=roth&updateState=1&clientpairingsecret=" +
                                                          clientPairingSecret.toHex(),
                                                          REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(secretRespXml);
    if (NvHTTP::getXmlString(secretRespXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #4";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QString pairChallengeXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttps,
                                                             "pair",
                                                             "devicename=roth&updateState=1&phrase=pairchallenge",
                                                             REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(pairChallengeXml);
    if (NvHTTP::getXmlString(pairChallengeXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #5";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    serverCert = std::move(unverifiedServerCert);
    return PairState::PAIRED;
}
```
**File:** app/backend/nvhttp.h (L178-179)
```text
    QImage
    getBoxArt(int appId);
```
**File:** app/backend/boxartmanager.cpp (L107-129)
```cpp
QUrl BoxArtManager::loadBoxArtFromNetwork(NvComputer* computer, int appId)
{
    NvHTTP http(computer);

    QString cachePath = getFilePathForBoxArt(computer, appId);
    QImage image;
    try {
        image = http.getBoxArt(appId);
    } catch (...) {}

    // Cache the box art on disk if it loaded
    if (!image.isNull()) {
        if (image.save(cachePath)) {
            return QUrl::fromLocalFile(cachePath);
        }
        else {
            // A failed save() may leave a zero byte file. Make sure that's removed.
            QFile(cachePath).remove();
        }
    }

    return QUrl();
}
```
**File:** app/streaming/session.cpp (L1554-1558)
```cpp
    // The UI should have ensured the old game was already quit
    // if we decide to stream a different game.
    Q_ASSERT(m_Computer->currentGameId == 0 ||
             m_Computer->currentGameId == m_App.id);

```
**File:** app/streaming/session.cpp (L1582-1600)
```cpp
    QString rtspSessionUrl;

    try {
        NvHTTP http(m_Computer);
        http.startApp(m_Computer->currentGameId != 0 ? "resume" : "launch",
                      m_Computer->isNvidiaServerSoftware,
                      m_App.id, &m_StreamConfig,
                      enableGameOptimizations,
                      m_Preferences->playAudioOnHost,
                      m_InputHandler->getAttachedGamepadMask(),
                      !m_Preferences->multiController,
                      rtspSessionUrl);
    } catch (const GfeHttpResponseException& e) {
        emit displayLaunchError(tr("Host returned error: %1").arg(e.toQString()));
        return false;
    } catch (const QtNetworkReplyException& e) {
        emit displayLaunchError(e.toQString());
        return false;
    }
```
**File:** app/backend/nvcomputer.cpp (L1-50)
```cpp
#include "nvcomputer.h"
#include "nvapp.h"
#include "settings/compatfetcher.h"

#include <QUdpSocket>
#include <QHostInfo>
#include <QNetworkInterface>
#include <QNetworkProxy>

#define SER_NAME "hostname"
#define SER_UUID "uuid"
#define SER_MAC "mac"
#define SER_LOCALADDR "localaddress"
#define SER_LOCALPORT "localport"
#define SER_REMOTEADDR "remoteaddress"
#define SER_REMOTEPORT "remoteport"
#define SER_MANUALADDR "manualaddress"
#define SER_MANUALPORT "manualport"
#define SER_IPV6ADDR "ipv6address"
#define SER_IPV6PORT "ipv6port"
#define SER_APPLIST "apps"
#define SER_SRVCERT "srvcert"
#define SER_CUSTOMNAME "customname"
#define SER_NVIDIASOFTWARE "nvidiasw"

NvComputer::NvComputer(QSettings& settings)
{
    this->name = settings.value(SER_NAME).toString();
    this->uuid = settings.value(SER_UUID).toString();
    this->hasCustomName = settings.value(SER_CUSTOMNAME).toBool();
    this->macAddress = settings.value(SER_MAC).toByteArray();
    this->localAddress = NvAddress(settings.value(SER_LOCALADDR).toString(),
                                   settings.value(SER_LOCALPORT, QVariant(DEFAULT_HTTP_PORT)).toUInt());
    this->remoteAddress = NvAddress(settings.value(SER_REMOTEADDR).toString(),
                                    settings.value(SER_REMOTEPORT, QVariant(DEFAULT_HTTP_PORT)).toUInt());
    this->ipv6Address = NvAddress(settings.value(SER_IPV6ADDR).toString(),
                                  settings.value(SER_IPV6PORT, QVariant(DEFAULT_HTTP_PORT)).toUInt());
    this->manualAddress = NvAddress(settings.value(SER_MANUALADDR).toString(),
                                    settings.value(SER_MANUALPORT, QVariant(DEFAULT_HTTP_PORT)).toUInt());
    this->serverCert = QSslCertificate(settings.value(SER_SRVCERT).toByteArray());
    this->isNvidiaServerSoftware = settings.value(SER_NVIDIASOFTWARE).toBool();

    int appCount = settings.beginReadArray(SER_APPLIST);
    this->appList.reserve(appCount);
    for (int i = 0; i < appCount; i++) {
        settings.setArrayIndex(i);

        NvApp app(settings);
        this->appList.append(app);
    }
```
## Q10
The server completes the pairing by inputting the PIN code displayed by the client. How does the client wait for the server's response to complete the pairing during the time the PIN code is generated and the user inputs the PIN on the server side?
### Answer
You're asking about how the Moonlight client waits for the server to complete pairing after displaying the PIN code to the user.

## Answer

The client doesn't actively poll or wait for the server's response during pairing. Instead, the pairing process is **synchronous and blocking** - the client sends requests sequentially through all 5 phases and waits for each response before proceeding to the next phase.

### Pairing Execution Flow

When the user clicks on an unpaired PC, the client generates a PIN and displays it in a dialog: moonlight-qt:239-246 

The pairing task runs in a background thread via `PendingPairingTask`: moonlight-qt:564-582 

### The Blocking Nature of Pairing

Inside `NvPairingManager::pair()`, each phase makes an HTTP/HTTPS request and **blocks waiting for the response** before proceeding: moonlight-qt:217-227 

The server validates the PIN during Phase 3 (server challenge response). If the user hasn't entered the PIN yet on the server side, the server simply doesn't respond or returns an error, causing the pairing to fail: moonlight-qt:287-298 

### PIN Validation

The PIN validation happens when the client sends the encrypted challenge response hash in Phase 3. The server decrypts this using the PIN-derived key and verifies it matches the expected value: moonlight-qt:313-322 

If the PIN is incorrect (user entered wrong PIN on server), the server returns a response that causes the client to detect `PIN_WRONG` state: moonlight-qt:585-586 

### UI Feedback

While pairing is in progress, the dialog remains open showing the PIN: moonlight-qt:302-310 

When pairing completes (successfully or with error), the `pairingCompleted` signal is emitted, which closes the dialog: moonlight-qt:47-58 

## Notes

The pairing process uses HTTP request timeouts (defined as `REQUEST_TIMEOUT_MS`) to prevent indefinite waiting. If the user takes too long to enter the PIN on the server, the HTTP request will timeout and pairing will fail. The client doesn't implement any retry logic or polling mechanism - it's a single synchronous attempt that either succeeds or fails based on the server's responses to the 5-phase handshake.

Wiki pages you might want to explore:
- [User Interface System (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2)
- [PC Discovery View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.1)
### Citations
**File:** app/gui/PcView.qml (L47-58)
```text
    function pairingComplete(error)
    {
        // Close the PIN dialog
        pairDialog.close()

        // Display a failed dialog if we got an error
        if (error !== undefined) {
            errorDialog.text = error
            errorDialog.helpText = ""
            errorDialog.open()
        }
    }
```
**File:** app/gui/PcView.qml (L239-246)
```text
                    var pin = computerModel.generatePinString()

                    // Kick off pairing in the background
                    computerModel.pairComputer(index, pin)

                    // Display the pairing dialog
                    pairDialog.pin = pin
                    pairDialog.open()
```
**File:** app/gui/PcView.qml (L302-310)
```text
        // don't allow edits to the rest of the window while open
        property string pin : "0000"
        text:qsTr("Please enter %1 on your host PC. This dialog will close when pairing is completed.").arg(pin)+"\n\n"+
             qsTr("If your host PC is running Sunshine, navigate to the Sunshine web UI to enter the PIN.")
        standardButtons: Dialog.Cancel
        onRejected: {
            // FIXME: We should interrupt pairing here
        }
    }
```
**File:** app/backend/computermanager.cpp (L564-582)
```cpp
    PendingPairingTask(ComputerManager* computerManager, NvComputer* computer, QString pin)
        : m_ComputerManager(computerManager),
          m_Computer(computer),
          m_Pin(pin)
    {
        connect(this, &PendingPairingTask::pairingCompleted,
                computerManager, &ComputerManager::pairingCompleted);
    }

signals:
    void pairingCompleted(NvComputer* computer, QString error);

private:
    void run()
    {
        NvPairingManager pairingManager(m_Computer);

        try {
           NvPairingManager::PairState result = pairingManager.pair(m_Computer->appVersion, m_Pin, m_Computer->serverCert);
```
**File:** app/backend/computermanager.cpp (L585-586)
```cpp
           case NvPairingManager::PairState::PIN_WRONG:
               emit pairingCompleted(m_Computer, tr("The PIN from the PC didn't match. Please try again."));
```
**File:** app/backend/nvpairingmanager.cpp (L217-227)
```cpp
    QString getCert = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&phrase=getservercert&salt=" +
                                                    salt.toHex() + "&clientcert=" + IdentityManager::get()->getCertificate().toHex(),
                                                    0);
    NvHTTP::verifyResponseStatus(getCert);
    if (NvHTTP::getXmlString(getCert, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #1";
        return PairState::FAILED;
    }
```
**File:** app/backend/nvpairingmanager.cpp (L287-298)
```cpp
    QString respXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&serverchallengeresp=" +
                                                    encryptedChallengeResponseHash.toHex(),
                                                    REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(respXml);
    if (NvHTTP::getXmlString(respXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #3";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }
```
**File:** app/backend/nvpairingmanager.cpp (L313-322)
```cpp
    QByteArray expectedResponseData;
    expectedResponseData.append(randomChallenge);
    expectedResponseData.append(getSignatureFromPemCert(serverCertStr));
    expectedResponseData.append(serverSecret);
    if (QCryptographicHash::hash(expectedResponseData, hashAlgo) != serverResponse)
    {
        qCritical() << "Incorrect PIN";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::PIN_WRONG;
    }
```
# DeepWiki Q&A with Code Context for Repository: moonlight-stream/moonlight-qt
## Q1
how to get /launch and /serverinfo info from server?
### Answer
Based on the code context, you're asking about how Moonlight retrieves `/launch` and `/serverinfo` information from the host server.

## Answer

Moonlight uses the `NvHTTP` class to communicate with the host server and retrieve information through HTTP/HTTPS endpoints. moonlight-qt:124-187 

### Getting `/serverinfo`

The `NvHTTP::getServerInfo()` method fetches server information: moonlight-qt:124-140 

The method first attempts to use HTTPS if a pinned certificate is available, then falls back to HTTP if needed. moonlight-qt:143-160  If no certificate exists yet, it uses HTTP initially to fetch the HTTPS port, then retries over HTTPS. moonlight-qt:162-183 

This is called during PC discovery when adding a new host: moonlight-qt:809-818 

The response is then used to create or update an `NvComputer` object: moonlight-qt:820-821 

### Getting `/launch` info

The `/launch` endpoint is called via `NvHTTP::startApp()` when starting a streaming session: moonlight-qt:1585-1593 

This happens in `Session::startConnectionAsync()` after the user selects an app to stream. moonlight-qt:1548-1600  The method passes streaming configuration parameters and receives back an RTSP session URL that's used to establish the actual streaming connection. moonlight-qt:1582-1593 

## Notes

The `NvHTTP` class handles all HTTP/HTTPS communication with the host server, including certificate pinning for security. The `/serverinfo` endpoint is polled regularly to monitor PC status, while `/launch` (or `/resume`) is only called when initiating a streaming session. Both endpoints use the base URL constructed from the host's address and appropriate port (HTTP 47989 or HTTPS 47984 by default).

Wiki pages you might want to explore:
- [User Interface System (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2)
- [PC Discovery View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.1)
### Citations
**File:** app/backend/nvhttp.cpp (L124-187)
```cpp
NvHTTP::getServerInfo(NvLogLevel logLevel, bool fastFail)
{
    QString serverInfo;

    // Check if we have a pinned cert and HTTPS port for this host yet
    if (!m_ServerCert.isNull() && httpsPort() != 0)
    {
        try
        {
            // Always try HTTPS first, since it properly reports
            // pairing status (and a few other attributes).
            serverInfo = openConnectionToString(m_BaseUrlHttps,
                                                "serverinfo",
                                                nullptr,
                                                fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                                logLevel);
            // Throws if the request failed
            verifyResponseStatus(serverInfo);
        }
        catch (const GfeHttpResponseException& e)
        {
            if (e.getStatusCode() == 401)
            {
                // Certificate validation error, fallback to HTTP
                serverInfo = openConnectionToString(m_BaseUrlHttp,
                                                    "serverinfo",
                                                    nullptr,
                                                    fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                                    logLevel);
                verifyResponseStatus(serverInfo);
            }
            else
            {
                // Rethrow real errors
                throw e;
            }
        }
    }
    else
    {
        // Only use HTTP prior to pairing or fetching HTTPS port
        serverInfo = openConnectionToString(m_BaseUrlHttp,
                                            "serverinfo",
                                            nullptr,
                                            fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                            logLevel);
        verifyResponseStatus(serverInfo);

        // Populate the HTTPS port
        uint16_t httpsPort = getXmlString(serverInfo, "HttpsPort").toUShort();
        if (httpsPort == 0) {
            httpsPort = DEFAULT_HTTPS_PORT;
        }
        setHttpsPort(httpsPort);

        // If we just needed to determine the HTTPS port, we'll try again over
        // HTTPS now that we have the port number
        if (!m_ServerCert.isNull()) {
            return getServerInfo(logLevel, fastFail);
        }
    }

    return serverInfo;
}
```
**File:** app/backend/computermanager.cpp (L809-818)
```cpp
        // Perform initial serverinfo fetch over HTTP since we don't know which cert to use
        QString serverInfo = fetchServerInfo(http);
        if (serverInfo.isEmpty() && !m_MdnsIpv6Address.isNull()) {
            // Retry using the global IPv6 address if the IPv4 or link-local IPv6 address fails
            http.setAddress(m_MdnsIpv6Address);
            serverInfo = fetchServerInfo(http);
        }
        if (serverInfo.isEmpty()) {
            return;
        }
```
**File:** app/backend/computermanager.cpp (L820-821)
```cpp
        // Create initial newComputer using HTTP serverinfo with no pinned cert
        NvComputer* newComputer = new NvComputer(http, serverInfo);
```
**File:** app/streaming/session.cpp (L1548-1600)
```cpp
bool Session::startConnectionAsync()
{
    // Wait 1.5 seconds before connecting to let the user
    // have time to read any messages present on the segue
    SDL_Delay(1500);

    // The UI should have ensured the old game was already quit
    // if we decide to stream a different game.
    Q_ASSERT(m_Computer->currentGameId == 0 ||
             m_Computer->currentGameId == m_App.id);

    bool enableGameOptimizations;
    if (m_Computer->isNvidiaServerSoftware) {
        // GFE will set all settings to 720p60 if it doesn't recognize
        // the chosen resolution. Avoid that by disabling SOPS when it
        // is not streaming a supported resolution.
        enableGameOptimizations = false;
        for (const NvDisplayMode &mode : m_Computer->displayModes) {
            if (mode.width == m_StreamConfig.width &&
                    mode.height == m_StreamConfig.height) {
                SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION,
                            "Found host supported resolution: %dx%d",
                            mode.width, mode.height);
                enableGameOptimizations = m_Preferences->gameOptimizations;
                break;
            }
        }
    }
    else {
        // Always send SOPS to Sunshine because we may repurpose the
        // option to control whether the display mode is adjusted
        enableGameOptimizations = m_Preferences->gameOptimizations;
    }

    QString rtspSessionUrl;

    try {
        NvHTTP http(m_Computer);
        http.startApp(m_Computer->currentGameId != 0 ? "resume" : "launch",
                      m_Computer->isNvidiaServerSoftware,
                      m_App.id, &m_StreamConfig,
                      enableGameOptimizations,
                      m_Preferences->playAudioOnHost,
                      m_InputHandler->getAttachedGamepadMask(),
                      !m_Preferences->multiController,
                      rtspSessionUrl);
    } catch (const GfeHttpResponseException& e) {
        emit displayLaunchError(tr("Host returned error: %1").arg(e.toQString()));
        return false;
    } catch (const QtNetworkReplyException& e) {
        emit displayLaunchError(e.toQString());
        return false;
    }
```
## Q2
How to parse the information returned by the above 2 interfaces and provide it to the function for establishing a streaming connection?
### Answer
You're asking about how Moonlight parses the responses from `/serverinfo` and `/launch` endpoints and uses that information to establish a streaming connection.

## Answer

### Parsing `/serverinfo` Response

The `/serverinfo` response is parsed to create/update an `NvComputer` object that stores host capabilities. moonlight-qt:754-782  The `NvHTTP::getServerInfo()` method returns an XML string that gets parsed to extract server properties like:<cite />

- Server codec mode support (`serverCodecModeSupport`)
- GFE version (`gfeVersion`)
- App version (`appVersion`)
- Display modes
- Current game ID

These properties are stored in the `NvComputer` object and later used during session validation and configuration.<cite />

### Parsing `/launch` Response and Establishing Connection

When starting a stream, `NvHTTP::startApp()` is called with the `STREAM_CONFIGURATION` structure containing all streaming parameters (resolution, FPS, bitrate, codec preferences, etc.). moonlight-qt:189-236  The method constructs a URL with query parameters including:<cite />

- Resolution and FPS (`mode` parameter)
- HDR settings
- Audio configuration
- Gamepad mask
- Remote input encryption keys

The response is parsed to extract the `rtspSessionUrl` using `getXmlString(response, "sessionUrl0")`. moonlight-qt:235-235 

### Providing Information to Connection Function

After receiving the `/launch` response, the parsed information is used to populate a `SERVER_INFORMATION` structure: moonlight-qt:1602-1624 

```cpp
SERVER_INFORMATION hostInfo;
hostInfo.address = hostnameStr.data();
hostInfo.serverInfoAppVersion = siAppVersion.data();
hostInfo.serverCodecModeSupport = m_Computer->serverCodecModeSupport;
hostInfo.serverInfoGfeVersion = siGfeVersion.data();
hostInfo.rtspSessionUrl = rtspSessionUrlStr.data();
```

This structure, along with the `STREAM_CONFIGURATION` and callback structures, is passed to `LiStartConnection()` to establish the actual streaming connection: moonlight-qt:1678-1685 

The `LiStartConnection()` function (from the moonlight-common-c library) uses:
- The RTSP session URL from `/launch` response to establish the RTSP control channel
- Server codec support from `/serverinfo` to negotiate video formats
- Stream configuration to set up video/audio decoders

### Validation Before Connection

Before calling `LiStartConnection()`, the session validates that the host supports the requested features by checking `m_Computer->serverCodecModeSupport` against the requested video formats. moonlight-qt:1117-1152  For example, it verifies YUV 4:4:4 support and adjusts the supported video formats list accordingly.<cite />

## Notes

The parsing happens in two stages: first during PC discovery (parsing `/serverinfo` into `NvComputer` properties), then during session start (parsing `/launch` response for RTSP URL). The `NvComputer` object acts as a bridge, storing server capabilities that are later referenced when configuring the `SERVER_INFORMATION` structure for `LiStartConnection()`. The actual XML parsing is handled by helper functions like `getXmlString()` in the `NvHTTP` class.

Wiki pages you might want to explore:
- [Settings View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.2)
- [Input Handling (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#4.7)
### Citations
**File:** app/backend/computermanager.cpp (L754-782)
```cpp
    QString fetchServerInfo(NvHTTP& http)
    {
        QString serverInfo;

        // Do nothing if we're quitting
        if (m_AboutToQuit) {
            return QString();
        }

        try {
            // There's a race condition between GameStream servers reporting presence over
            // mDNS and the HTTPS server being ready to respond to our queries. To work
            // around this issue, we will issue the request again after a few seconds if
            // we see a ServiceUnavailableError error.
            try {
                serverInfo = http.getServerInfo(NvHTTP::NVLL_VERBOSE);
            } catch (const QtNetworkReplyException& e) {
                if (e.getError() == QNetworkReply::ServiceUnavailableError) {
                    qWarning() << "Retrying request in 5 seconds after ServiceUnavailableError";
                    QThread::sleep(5);
                    serverInfo = http.getServerInfo(NvHTTP::NVLL_VERBOSE);
                    qInfo() << "Retry successful";
                }
                else {
                    // Rethrow other errors
                    throw e;
                }
            }
            return serverInfo;
```
**File:** app/backend/nvhttp.cpp (L189-236)
```cpp
void
NvHTTP::startApp(QString verb,
                 bool isGfe,
                 int appId,
                 PSTREAM_CONFIGURATION streamConfig,
                 bool sops,
                 bool localAudio,
                 int gamepadMask,
                 bool persistGameControllersOnDisconnect,
                 QString& rtspSessionUrl)
{
    int riKeyId;

    memcpy(&riKeyId, streamConfig->remoteInputAesIv, sizeof(riKeyId));
    riKeyId = qFromBigEndian(riKeyId);

    QString response =
            openConnectionToString(m_BaseUrlHttps,
                                   verb,
                                   "appid="+QString::number(appId)+
                                   "&mode="+QString::number(streamConfig->width)+"x"+
                                   QString::number(streamConfig->height)+"x"+
                                   // Using an FPS value over 60 causes SOPS to default to 720p60,
                                   // so force it to 0 to ensure the correct resolution is set. We
                                   // used to use 60 here but that locked the frame rate to 60 FPS
                                   // on GFE 3.20.3. We don't need this hack for Sunshine.
                                   QString::number((streamConfig->fps > 60 && isGfe) ? 0 : streamConfig->fps)+
                                   "&additionalStates=1&sops="+QString::number(sops ? 1 : 0)+
                                   "&rikey="+QByteArray(streamConfig->remoteInputAesKey, sizeof(streamConfig->remoteInputAesKey)).toHex()+
                                   "&rikeyid="+QString::number(riKeyId)+
                                   ((streamConfig->supportedVideoFormats & VIDEO_FORMAT_MASK_10BIT) ?
                                       "&hdrMode=1&clientHdrCapVersion=0&clientHdrCapSupportedFlagsInUint32=0&clientHdrCapMetaDataId=NV_STATIC_METADATA_TYPE_1&clientHdrCapDisplayData=0x0x0x0x0x0x0x0x0x0x0" :
                                        "")+
                                   "&localAudioPlayMode="+QString::number(localAudio ? 1 : 0)+
                                   "&surroundAudioInfo="+QString::number(SURROUNDAUDIOINFO_FROM_AUDIO_CONFIGURATION(streamConfig->audioConfiguration))+
                                   "&remoteControllersBitmap="+QString::number(gamepadMask)+
                                   "&gcmap="+QString::number(gamepadMask)+
                                   "&gcpersist="+QString::number(persistGameControllersOnDisconnect ? 1 : 0)+
                                   LiGetLaunchUrlQueryParameters(),
                                   LAUNCH_TIMEOUT_MS);

    qInfo() << "Launch response:" << response;

    // Throws if the request failed
    verifyResponseStatus(response);

    rtspSessionUrl = getXmlString(response, "sessionUrl0");
}
```
**File:** app/streaming/session.cpp (L1117-1152)
```cpp
    if (m_Preferences->enableYUV444) {
        if (!(m_Computer->serverCodecModeSupport & SCM_MASK_YUV444)) {
            emitLaunchWarning(tr("Your host PC doesn't support YUV 4:4:4 streaming."));
            m_SupportedVideoFormats.removeByMask(VIDEO_FORMAT_MASK_YUV444);
        }
        else {
            m_SupportedVideoFormats.removeByMask(~m_SupportedVideoFormats.maskByServerCodecModes(m_Computer->serverCodecModeSupport));

            if (!m_SupportedVideoFormats.isEmpty() &&
                !(m_SupportedVideoFormats.front() & VIDEO_FORMAT_MASK_YUV444)) {
                emitLaunchWarning(tr("Your host PC doesn't support YUV 4:4:4 streaming for selected video codec."));
            }
            else if (m_Preferences->videoDecoderSelection != StreamingPreferences::VDS_FORCE_SOFTWARE) {
                while (!m_SupportedVideoFormats.isEmpty() &&
                       (m_SupportedVideoFormats.front() & VIDEO_FORMAT_MASK_YUV444) &&
                       getDecoderAvailability(testWindow,
                                              m_Preferences->videoDecoderSelection,
                                              m_SupportedVideoFormats.front(),
                                              m_StreamConfig.width,
                                              m_StreamConfig.height,
                                              m_StreamConfig.fps) != DecoderAvailability::Hardware) {
                    if (m_Preferences->videoDecoderSelection == StreamingPreferences::VDS_FORCE_HARDWARE) {
                        m_SupportedVideoFormats.removeFirst();
                    }
                    else {
                        emitLaunchWarning(tr("Using software decoding due to your selection to force YUV 4:4:4 without GPU support. This may cause poor streaming performance."));
                        break;
                    }
                }
                if (!m_SupportedVideoFormats.isEmpty() &&
                    !(m_SupportedVideoFormats.front() & VIDEO_FORMAT_MASK_YUV444)) {
                    emitLaunchWarning(tr("This PC's GPU doesn't support YUV 4:4:4 decoding for selected video codec."));
                }
            }
        }
    }
```
**File:** app/streaming/session.cpp (L1602-1624)
```cpp
    QByteArray hostnameStr = m_Computer->activeAddress.address().toLatin1();
    QByteArray siAppVersion = m_Computer->appVersion.toLatin1();

    SERVER_INFORMATION hostInfo;
    hostInfo.address = hostnameStr.data();
    hostInfo.serverInfoAppVersion = siAppVersion.data();
    hostInfo.serverCodecModeSupport = m_Computer->serverCodecModeSupport;

    // Older GFE versions didn't have this field
    QByteArray siGfeVersion;
    if (!m_Computer->gfeVersion.isEmpty()) {
        siGfeVersion = m_Computer->gfeVersion.toLatin1();
    }
    if (!siGfeVersion.isEmpty()) {
        hostInfo.serverInfoGfeVersion = siGfeVersion.data();
    }

    // Older GFE and Sunshine versions didn't have this field
    QByteArray rtspSessionUrlStr;
    if (!rtspSessionUrl.isEmpty()) {
        rtspSessionUrlStr = rtspSessionUrl.toLatin1();
        hostInfo.rtspSessionUrl = rtspSessionUrlStr.data();
    }
```
**File:** app/streaming/session.cpp (L1678-1685)
```cpp
    int err = LiStartConnection(&hostInfo, &m_StreamConfig, &k_ConnCallbacks,
                                &m_VideoCallbacks, &m_AudioCallbacks,
                                NULL, 0, NULL, 0);
    if (err != 0) {
        // We already displayed an error dialog in the stage failure
        // listener.
        return false;
    }
```
## Q3
how to get "Remote input encryption keys"
### Answer
You're asking about how Moonlight generates the "Remote input encryption keys" that are sent to the host server during the `/launch` request.

## Answer

The remote input encryption keys (`rikey` and `rikeyid`) are randomly generated AES encryption keys used to secure input data sent from the client to the host during streaming. moonlight-qt:692-696 

### Key Generation

During session initialization in `Session::initialize()`, Moonlight generates these keys using OpenSSL's cryptographically secure random number generator:

```cpp
RAND_bytes(reinterpret_cast<unsigned char*>(m_StreamConfig.remoteInputAesKey),
           sizeof(m_StreamConfig.remoteInputAesKey));

// Only the first 4 bytes are populated in the RI key IV
RAND_bytes(reinterpret_cast<unsigned char*>(m_StreamConfig.remoteInputAesIv), 4);
``` moonlight-qt:692-696 

The `remoteInputAesKey` is a full AES key (16 bytes), while `remoteInputAesIv` only uses the first 4 bytes as an initialization vector. moonlight-qt:692-696 

### Sending Keys to Host

These generated keys are then sent to the host server when calling the `/launch` endpoint in `NvHTTP::startApp()`. moonlight-qt:200-218  The method:

1. Extracts the key ID from the IV by reading the first 4 bytes as a big-endian integer moonlight-qt:200-203 
2. Converts the AES key to hexadecimal format using `QByteArray(...).toHex()` moonlight-qt:217-217 
3. Includes both values as query parameters: `rikey=<hex_key>&rikeyid=<key_id>` moonlight-qt:217-218 

### Security Considerations

For security, these keys are automatically redacted from log files to prevent exposure. moonlight-qt:108-110  The logging system uses regex patterns to strip `rikey` and `rikeyid` values before writing to logs. moonlight-qt:88-88 

## Notes

The remote input encryption is part of Moonlight's security features to protect input data (keyboard, mouse, gamepad) transmitted during streaming. The keys are generated fresh for each streaming session and are stored in the `STREAM_CONFIGURATION` structure (`m_StreamConfig`) which is later passed to `LiStartConnection()` to establish the connection. moonlight-qt:1584-1593 

Wiki pages you might want to explore:
- [PC Discovery View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.1)
### Citations
**File:** app/streaming/session.cpp (L692-696)
```cpp
    RAND_bytes(reinterpret_cast<unsigned char*>(m_StreamConfig.remoteInputAesKey),
               sizeof(m_StreamConfig.remoteInputAesKey));

    // Only the first 4 bytes are populated in the RI key IV
    RAND_bytes(reinterpret_cast<unsigned char*>(m_StreamConfig.remoteInputAesIv), 4);
```
**File:** app/streaming/session.cpp (L1584-1593)
```cpp
    try {
        NvHTTP http(m_Computer);
        http.startApp(m_Computer->currentGameId != 0 ? "resume" : "launch",
                      m_Computer->isNvidiaServerSoftware,
                      m_App.id, &m_StreamConfig,
                      enableGameOptimizations,
                      m_Preferences->playAudioOnHost,
                      m_InputHandler->getAttachedGamepadMask(),
                      !m_Preferences->multiController,
                      rtspSessionUrl);
```
**File:** app/backend/nvhttp.cpp (L200-218)
```cpp
    int riKeyId;

    memcpy(&riKeyId, streamConfig->remoteInputAesIv, sizeof(riKeyId));
    riKeyId = qFromBigEndian(riKeyId);

    QString response =
            openConnectionToString(m_BaseUrlHttps,
                                   verb,
                                   "appid="+QString::number(appId)+
                                   "&mode="+QString::number(streamConfig->width)+"x"+
                                   QString::number(streamConfig->height)+"x"+
                                   // Using an FPS value over 60 causes SOPS to default to 720p60,
                                   // so force it to 0 to ensure the correct resolution is set. We
                                   // used to use 60 here but that locked the frame rate to 60 FPS
                                   // on GFE 3.20.3. We don't need this hack for Sunshine.
                                   QString::number((streamConfig->fps > 60 && isGfe) ? 0 : streamConfig->fps)+
                                   "&additionalStates=1&sops="+QString::number(sops ? 1 : 0)+
                                   "&rikey="+QByteArray(streamConfig->remoteInputAesKey, sizeof(streamConfig->remoteInputAesKey)).toHex()+
                                   "&rikeyid="+QString::number(riKeyId)+
```
**File:** app/main.cpp (L108-110)
```cpp
    // Strip session encryption keys and IVs from the logs
    message.replace(k_RikeyRegex, "&rikey=REDACTED");
    message.replace(k_RikeyIdRegex, "&rikeyid=REDACTED");
```
**File:** app/deploy/linux/com.moonlight_stream.Moonlight.appdata.xml (L88-88)
```text
					<li>Per-session keys (rikey and rikeyid values) are now automatically stripped from logs</li>
```
## Q4
<?xml version="1.0" encoding="utf-8"?>
<root status_code="200">
  <hostname>Html5syt</hostname>
  <appversion>7.1.431.-1</appversion>
<GfeVersion>3.23.0.74</GfeVersion>
  <uniqueid>F98186B1-DE02-2328-279E-0A461FBCEC47</uniqueid>
  <HttpsPort>47984</HttpsPort>
  <ExternalPort>47989</ExternalPort>
<MaxLumaPixelsHEVC>1869449984</MaxLumaPixelsHEVC>
  <mac>00:00:00:00:00:00</mac>
  <LocalIP>127.0.0.1</LocalIP>
  <ServerCodecModeSupport>257</ServerCodecModeSupport>
<PairStatus>0</PairStatus>
  <currentgame>1191261554</currentgame>
  <state>SUNSHINE_SERVER_BUSY</state>
</root>
This is a response from a serverinfo, please tell me which parameters are used to establish the connection in it?
### Answer
You're asking which parameters from the `/serverinfo` XML response are used when establishing a streaming connection in Moonlight.

## Answer

From the `/serverinfo` response you provided, the following parameters are used to establish the streaming connection:

### Parameters Used in Connection Establishment

**`ServerCodecModeSupport` (value: 257)** - This is stored in the `NvComputer` object and later passed to `LiStartConnection()` via the `SERVER_INFORMATION` structure. moonlight-qt:1608-1608  It indicates which video codecs and formats the host supports, and is used to negotiate the video format during connection setup. moonlight-qt:1608-1608 

**`appversion` (value: 7.1.431.-1)** - This is stored as `m_Computer->appVersion` and passed to `LiStartConnection()` as `hostInfo.serverInfoAppVersion`. moonlight-qt:1603-1607  The connection library uses this to determine host capabilities and compatibility. moonlight-qt:1603-1607 

**`GfeVersion` (value: 3.23.0.74)** - This is stored as `m_Computer->gfeVersion` and passed to `LiStartConnection()` as `hostInfo.serverInfoGfeVersion`. moonlight-qt:1611-1617  It's used to determine if the host is running GFE or Sunshine and adjust behavior accordingly. moonlight-qt:1560-1580 

**`LocalIP` (value: 127.0.0.1)** - The host's address is used to construct the base URLs for HTTP/HTTPS communication and is passed to `LiStartConnection()` as `hostInfo.address`. moonlight-qt:1602-1606 

**`HttpsPort` (value: 47984)** - Used to construct the HTTPS base URL for secure communication with the host, including the `/launch` endpoint call. moonlight-qt:173-177 

### Parameters NOT Directly Used in Connection

The following parameters are informational but not directly passed to the connection function:

- `hostname`, `uniqueid`, `ExternalPort`, `MaxLumaPixelsHEVC`, `mac` - These are stored in the `NvComputer` object for display and management purposes but aren't passed to `LiStartConnection()`.<cite />
- `PairStatus` - Used to determine if pairing is needed before streaming, but not used during connection establishment.<cite />
- `currentgame` and `state` - Used to determine if the host is already streaming, which affects whether to call `/launch` or `/resume`. moonlight-qt:1586-1586 

## Notes

The `state` value "SUNSHINE_SERVER_BUSY" indicates the host is currently streaming (as confirmed by the non-zero `currentgame` value). moonlight-qt:112-116  In this case, Moonlight would call `/resume` instead of `/launch` if you're trying to connect to the same game. moonlight-qt:1586-1586  The `ServerCodecModeSupport` value of 257 indicates support for H.264 (bit 0) and H.265/HEVC (bit 8).<cite />

Wiki pages you might want to explore:
- [PC Discovery View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.1)
### Citations
**File:** app/streaming/session.cpp (L1560-1580)
```cpp
    if (m_Computer->isNvidiaServerSoftware) {
        // GFE will set all settings to 720p60 if it doesn't recognize
        // the chosen resolution. Avoid that by disabling SOPS when it
        // is not streaming a supported resolution.
        enableGameOptimizations = false;
        for (const NvDisplayMode &mode : m_Computer->displayModes) {
            if (mode.width == m_StreamConfig.width &&
                    mode.height == m_StreamConfig.height) {
                SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION,
                            "Found host supported resolution: %dx%d",
                            mode.width, mode.height);
                enableGameOptimizations = m_Preferences->gameOptimizations;
                break;
            }
        }
    }
    else {
        // Always send SOPS to Sunshine because we may repurpose the
        // option to control whether the display mode is adjusted
        enableGameOptimizations = m_Preferences->gameOptimizations;
    }
```
**File:** app/streaming/session.cpp (L1586-1586)
```cpp
        http.startApp(m_Computer->currentGameId != 0 ? "resume" : "launch",
```
**File:** app/streaming/session.cpp (L1602-1607)
```cpp
    QByteArray hostnameStr = m_Computer->activeAddress.address().toLatin1();
    QByteArray siAppVersion = m_Computer->appVersion.toLatin1();

    SERVER_INFORMATION hostInfo;
    hostInfo.address = hostnameStr.data();
    hostInfo.serverInfoAppVersion = siAppVersion.data();
```
**File:** app/streaming/session.cpp (L1608-1608)
```cpp
    hostInfo.serverCodecModeSupport = m_Computer->serverCodecModeSupport;
```
**File:** app/streaming/session.cpp (L1611-1617)
```cpp
    QByteArray siGfeVersion;
    if (!m_Computer->gfeVersion.isEmpty()) {
        siGfeVersion = m_Computer->gfeVersion.toLatin1();
    }
    if (!siGfeVersion.isEmpty()) {
        hostInfo.serverInfoGfeVersion = siGfeVersion.data();
    }
```
**File:** app/backend/nvhttp.cpp (L112-116)
```cpp
    QString serverState = getXmlString(serverInfo, "state");
    if (serverState != nullptr && serverState.endsWith("_SERVER_BUSY"))
    {
        return getXmlString(serverInfo, "currentgame").toInt();
    }
```
**File:** app/backend/nvhttp.cpp (L173-177)
```cpp
        uint16_t httpsPort = getXmlString(serverInfo, "HttpsPort").toUShort();
        if (httpsPort == 0) {
            httpsPort = DEFAULT_HTTPS_PORT;
        }
        setHttpsPort(httpsPort);
```
## Q5
When I call the /launch interface, the server requires me to provide a client certificate. How can I obtain this certificate?
### Answer
Moonlight obtains and provides client certificates through a multi-step process involving certificate generation, pairing, and SSL configuration:

## Client Certificate Generation

When Moonlight first launches, the `IdentityManager` class automatically generates a self-signed 2048-bit RSA certificate and private key pair if none exist. moonlight-qt:29-110 

These credentials are stored persistently in QSettings and cached in memory for reuse. moonlight-qt:112-139 

## Attaching Certificates to Requests

For every HTTPS request (including `/launch`), Moonlight attaches the client certificate through the `IdentityManager::getSslConfig()` method, which returns a `QSslConfiguration` containing both the client certificate and private key. moonlight-qt:184-191 

This SSL configuration is applied to all network requests in the `openConnection` method via `request.setSslConfiguration()`. moonlight-qt:486-489 

## The `/launch` Interface Specifically

When the `startApp` method is called to launch a game, it makes an HTTPS request to the `/launch` endpoint using the base HTTPS URL. moonlight-qt:205-228 

This request goes through `openConnection`, which automatically includes the client certificate for mutual TLS authentication with the host server.

## Pairing Process for Mutual Trust

Before the client certificate can be used for authentication, a pairing process must occur. During pairing, the client sends its certificate to the server and receives the server's certificate in return. moonlight-qt:217-248 

The server certificate is then pinned and stored in the `NvComputer` object for future SSL validation. moonlight-qt:419-439 

## Certificate Validation

If there's an SSL handshake failure or certificate mismatch (error 401), Moonlight falls back to HTTP and can re-initiate pairing to obtain updated certificates. moonlight-qt:143-160 

## Notes

- The client certificate uses a common name of "NVIDIA GameStream Client" moonlight-qt:70-74 
- The certificate has a 20-year validity period moonlight-qt:51-66 
- The `/launch` endpoint uses a 120-second timeout compared to the standard 5-second timeout for other requests moonlight-qt:15-19 
- Certificate pinning prevents man-in-the-middle attacks by ensuring SSL errors are only ignored if they match the previously paired server certificate moonlight-qt:429-434
### Citations
**File:** app/backend/identitymanager.cpp (L29-110)
```cpp
void IdentityManager::createCredentials(QSettings& settings)
{
    X509* cert = X509_new();
    THROW_BAD_ALLOC_IF_NULL(cert);

    EVP_PKEY_CTX* ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_RSA, NULL);
    THROW_BAD_ALLOC_IF_NULL(ctx);

    EVP_PKEY_keygen_init(ctx);
    EVP_PKEY_CTX_set_rsa_keygen_bits(ctx, 2048);

    // pk must be initialized on input
    EVP_PKEY* pk = NULL;
    EVP_PKEY_keygen(ctx, &pk);

    EVP_PKEY_CTX_free(ctx);
    THROW_BAD_ALLOC_IF_NULL(pk);

    X509_set_version(cert, 2);
    ASN1_INTEGER_set(X509_get_serialNumber(cert), 0);
#if OPENSSL_VERSION_NUMBER < 0x10100000L
    X509_gmtime_adj(X509_get_notBefore(cert), 0);
    X509_gmtime_adj(X509_get_notAfter(cert), 60 * 60 * 24 * 365 * 20); // 20 yrs
#else
    ASN1_TIME* before = ASN1_STRING_dup(X509_get0_notBefore(cert));
    THROW_BAD_ALLOC_IF_NULL(before);
    ASN1_TIME* after = ASN1_STRING_dup(X509_get0_notAfter(cert));
    THROW_BAD_ALLOC_IF_NULL(after);

    X509_gmtime_adj(before, 0);
    X509_gmtime_adj(after, 60 * 60 * 24 * 365 * 20); // 20 yrs

    X509_set1_notBefore(cert, before);
    X509_set1_notAfter(cert, after);

    ASN1_STRING_free(before);
    ASN1_STRING_free(after);
#endif

    X509_set_pubkey(cert, pk);

    X509_NAME* name = X509_get_subject_name(cert);
    X509_NAME_add_entry_by_txt(name, "CN", MBSTRING_ASC,
                               reinterpret_cast<unsigned char *>(const_cast<char*>("NVIDIA GameStream Client")),
                               -1, -1, 0);
    X509_set_issuer_name(cert, name);

    X509_sign(cert, pk, EVP_sha256());

    BIO* biokey = BIO_new(BIO_s_mem());
    THROW_BAD_ALLOC_IF_NULL(biokey);
    PEM_write_bio_PrivateKey(biokey, pk, NULL, NULL, 0, NULL, NULL);

    BIO* biocert = BIO_new(BIO_s_mem());
    THROW_BAD_ALLOC_IF_NULL(biocert);
    PEM_write_bio_X509(biocert, cert);

    BUF_MEM* mem;
    BIO_get_mem_ptr(biokey, &mem);
    m_CachedPrivateKey = QByteArray(mem->data, (int)mem->length);

    BIO_get_mem_ptr(biocert, &mem);
    m_CachedPemCert = QByteArray(mem->data, (int)mem->length);

    X509_free(cert);
    EVP_PKEY_free(pk);
    BIO_free(biokey);
    BIO_free(biocert);

    // Check that the new keypair is valid before persisting it
    if (getSslCertificate().isNull()) {
        qFatal("Newly generated certificate is unreadable");
    }
    if (getSslKey().isNull()) {
        qFatal("Newly generated private key is unreadable");
    }

    settings.setValue(SER_CERT, m_CachedPemCert);
    settings.setValue(SER_KEY, m_CachedPrivateKey);

    qInfo() << "Wrote new identity credentials to settings";
}
```
**File:** app/backend/identitymanager.cpp (L112-139)
```cpp
IdentityManager::IdentityManager()
{
    QSettings settings;

    m_CachedPemCert = settings.value(SER_CERT).toByteArray();
    m_CachedPrivateKey = settings.value(SER_KEY).toByteArray();

    if (m_CachedPemCert.isEmpty() || m_CachedPrivateKey.isEmpty()) {
        qInfo() << "No existing credentials found";
        createCredentials(settings);
    }
    else if (getSslCertificate().isNull()) {
        qWarning() << "Certificate is unreadable";
        createCredentials(settings);
    }
    else if (getSslKey().isNull()) {
        qWarning() << "Private key is unreadable";
        createCredentials(settings);
    }

    // We should have valid credentials now. If not, we're screwed
    if (getSslCertificate().isNull()) {
        qFatal("Certificate is unreadable");
    }
    if (getSslKey().isNull()) {
        qFatal("Private key is unreadable");
    }
}
```
**File:** app/backend/identitymanager.cpp (L184-191)
```cpp
QSslConfiguration
IdentityManager::getSslConfig()
{
    QSslConfiguration sslConfig(QSslConfiguration::defaultConfiguration());
    sslConfig.setLocalCertificate(getSslCertificate());
    sslConfig.setPrivateKey(getSslKey());
    return sslConfig;
}
```
**File:** app/backend/nvhttp.cpp (L15-19)
```cpp
#define FAST_FAIL_TIMEOUT_MS 2000
#define REQUEST_TIMEOUT_MS 5000
#define LAUNCH_TIMEOUT_MS 120000
#define RESUME_TIMEOUT_MS 30000
#define QUIT_TIMEOUT_MS 30000
```
**File:** app/backend/nvhttp.cpp (L143-160)
```cpp
        catch (const GfeHttpResponseException& e)
        {
            if (e.getStatusCode() == 401)
            {
                // Certificate validation error, fallback to HTTP
                serverInfo = openConnectionToString(m_BaseUrlHttp,
                                                    "serverinfo",
                                                    nullptr,
                                                    fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                                    logLevel);
                verifyResponseStatus(serverInfo);
            }
            else
            {
                // Rethrow real errors
                throw e;
            }
        }
```
**File:** app/backend/nvhttp.cpp (L205-228)
```cpp
    QString response =
            openConnectionToString(m_BaseUrlHttps,
                                   verb,
                                   "appid="+QString::number(appId)+
                                   "&mode="+QString::number(streamConfig->width)+"x"+
                                   QString::number(streamConfig->height)+"x"+
                                   // Using an FPS value over 60 causes SOPS to default to 720p60,
                                   // so force it to 0 to ensure the correct resolution is set. We
                                   // used to use 60 here but that locked the frame rate to 60 FPS
                                   // on GFE 3.20.3. We don't need this hack for Sunshine.
                                   QString::number((streamConfig->fps > 60 && isGfe) ? 0 : streamConfig->fps)+
                                   "&additionalStates=1&sops="+QString::number(sops ? 1 : 0)+
                                   "&rikey="+QByteArray(streamConfig->remoteInputAesKey, sizeof(streamConfig->remoteInputAesKey)).toHex()+
                                   "&rikeyid="+QString::number(riKeyId)+
                                   ((streamConfig->supportedVideoFormats & VIDEO_FORMAT_MASK_10BIT) ?
                                       "&hdrMode=1&clientHdrCapVersion=0&clientHdrCapSupportedFlagsInUint32=0&clientHdrCapMetaDataId=NV_STATIC_METADATA_TYPE_1&clientHdrCapDisplayData=0x0x0x0x0x0x0x0x0x0x0" :
                                        "")+
                                   "&localAudioPlayMode="+QString::number(localAudio ? 1 : 0)+
                                   "&surroundAudioInfo="+QString::number(SURROUNDAUDIOINFO_FROM_AUDIO_CONFIGURATION(streamConfig->audioConfiguration))+
                                   "&remoteControllersBitmap="+QString::number(gamepadMask)+
                                   "&gcmap="+QString::number(gamepadMask)+
                                   "&gcpersist="+QString::number(persistGameControllersOnDisconnect ? 1 : 0)+
                                   LiGetLaunchUrlQueryParameters(),
                                   LAUNCH_TIMEOUT_MS);
```
**File:** app/backend/nvhttp.cpp (L419-439)
```cpp
void NvHTTP::handleSslErrors(QNetworkReply* reply, const QList<QSslError>& errors)
{
    bool ignoreErrors = true;

    if (m_ServerCert.isNull()) {
        // We should never make an HTTPS request without a cert
        Q_ASSERT(!m_ServerCert.isNull());
        return;
    }

    for (const QSslError& error : errors) {
        if (m_ServerCert != error.certificate()) {
            ignoreErrors = false;
            break;
        }
    }

    if (ignoreErrors) {
        reply->ignoreSslErrors(errors);
    }
}
```
**File:** app/backend/nvhttp.cpp (L486-489)
```cpp
    QNetworkRequest request(url);

    // Add our client certificate
    request.setSslConfiguration(IdentityManager::get()->getSslConfig());
```
**File:** app/backend/nvpairingmanager.cpp (L217-248)
```cpp
    QString getCert = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&phrase=getservercert&salt=" +
                                                    salt.toHex() + "&clientcert=" + IdentityManager::get()->getCertificate().toHex(),
                                                    0);
    NvHTTP::verifyResponseStatus(getCert);
    if (NvHTTP::getXmlString(getCert, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #1";
        return PairState::FAILED;
    }

    QByteArray serverCertStr = NvHTTP::getXmlStringFromHex(getCert, "plaincert");
    if (serverCertStr == nullptr)
    {
        qCritical() << "Server likely already pairing";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::ALREADY_IN_PROGRESS;
    }

    QSslCertificate unverifiedServerCert = QSslCertificate(serverCertStr);
    if (unverifiedServerCert.isNull()) {
        Q_ASSERT(!unverifiedServerCert.isNull());

        qCritical() << "Failed to parse plaincert";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    // Pin this cert for TLS until pairing is complete. If successful, we will propagate
    // the cert into the NvComputer object and persist it.
    m_Http.setServerCert(unverifiedServerCert);
```
## Q6
How to pair up computer?
### Answer
The pairing process in Moonlight uses a 5-phase handshake protocol to securely exchange certificates between the client and server. Here's how it works:

## Client Certificate Generation and Storage

The client certificate is a self-signed X.509 certificate that is generated when Moonlight first runs. It uses a 2048-bit RSA key pair with SHA-256 signature and has a 20-year validity period. moonlight-qt:29-110 

The certificate and private key are stored in QSettings and cached in memory for subsequent use. moonlight-qt:112-139 

## The 5-Phase Pairing Process

The pairing process is implemented in the `NvPairingManager::pair()` method: moonlight-qt:191-354 

### Phase 1: Certificate Exchange

The client sends its certificate to the server as a hex-encoded string in the `clientcert` parameter of an HTTP request. At the same time, it receives the server's certificate in the response: moonlight-qt:217-227 

The server returns its certificate in the `plaincert` field of the XML response: moonlight-qt:229-244 

### Phase 2-5: Challenge-Response Authentication

Once the server certificate is received, it is immediately pinned to the HTTP client for all subsequent HTTPS requests: moonlight-qt:246-248 

The remaining phases involve encrypted challenge-response exchanges and signature verification to authenticate both parties and validate the PIN.

## Certificate Pinning

The `setServerCert()` method stores the server certificate for use in HTTPS connections: moonlight-qt:43-46 

During HTTPS connections, the `handleSslErrors()` method verifies that the server certificate matches the pinned certificate, preventing man-in-the-middle attacks: moonlight-qt:419-439 

## Persisting the Server Certificate

After successful pairing, the server certificate is stored in the `NvComputer` object: moonlight-qt:113-113 

The certificate is then persisted to settings by calling `saveHost()`: moonlight-qt:599-603 

## Notes

The pairing process uses AES-128-ECB encryption for challenge exchanges, with the encryption key derived from a salted PIN hash (SHA-256 for Gen 7+ servers, SHA-1 for older versions). The client certificate is sent as plain hex-encoded PEM data in Phase 1, while the server certificate is also returned as hex-encoded PEM. This certificate exchange happens over HTTP initially, but all subsequent pairing phases use HTTPS with the newly pinned certificate to ensure secure communication.
### Citations
**File:** app/backend/identitymanager.cpp (L29-110)
```cpp
void IdentityManager::createCredentials(QSettings& settings)
{
    X509* cert = X509_new();
    THROW_BAD_ALLOC_IF_NULL(cert);

    EVP_PKEY_CTX* ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_RSA, NULL);
    THROW_BAD_ALLOC_IF_NULL(ctx);

    EVP_PKEY_keygen_init(ctx);
    EVP_PKEY_CTX_set_rsa_keygen_bits(ctx, 2048);

    // pk must be initialized on input
    EVP_PKEY* pk = NULL;
    EVP_PKEY_keygen(ctx, &pk);

    EVP_PKEY_CTX_free(ctx);
    THROW_BAD_ALLOC_IF_NULL(pk);

    X509_set_version(cert, 2);
    ASN1_INTEGER_set(X509_get_serialNumber(cert), 0);
#if OPENSSL_VERSION_NUMBER < 0x10100000L
    X509_gmtime_adj(X509_get_notBefore(cert), 0);
    X509_gmtime_adj(X509_get_notAfter(cert), 60 * 60 * 24 * 365 * 20); // 20 yrs
#else
    ASN1_TIME* before = ASN1_STRING_dup(X509_get0_notBefore(cert));
    THROW_BAD_ALLOC_IF_NULL(before);
    ASN1_TIME* after = ASN1_STRING_dup(X509_get0_notAfter(cert));
    THROW_BAD_ALLOC_IF_NULL(after);

    X509_gmtime_adj(before, 0);
    X509_gmtime_adj(after, 60 * 60 * 24 * 365 * 20); // 20 yrs

    X509_set1_notBefore(cert, before);
    X509_set1_notAfter(cert, after);

    ASN1_STRING_free(before);
    ASN1_STRING_free(after);
#endif

    X509_set_pubkey(cert, pk);

    X509_NAME* name = X509_get_subject_name(cert);
    X509_NAME_add_entry_by_txt(name, "CN", MBSTRING_ASC,
                               reinterpret_cast<unsigned char *>(const_cast<char*>("NVIDIA GameStream Client")),
                               -1, -1, 0);
    X509_set_issuer_name(cert, name);

    X509_sign(cert, pk, EVP_sha256());

    BIO* biokey = BIO_new(BIO_s_mem());
    THROW_BAD_ALLOC_IF_NULL(biokey);
    PEM_write_bio_PrivateKey(biokey, pk, NULL, NULL, 0, NULL, NULL);

    BIO* biocert = BIO_new(BIO_s_mem());
    THROW_BAD_ALLOC_IF_NULL(biocert);
    PEM_write_bio_X509(biocert, cert);

    BUF_MEM* mem;
    BIO_get_mem_ptr(biokey, &mem);
    m_CachedPrivateKey = QByteArray(mem->data, (int)mem->length);

    BIO_get_mem_ptr(biocert, &mem);
    m_CachedPemCert = QByteArray(mem->data, (int)mem->length);

    X509_free(cert);
    EVP_PKEY_free(pk);
    BIO_free(biokey);
    BIO_free(biocert);

    // Check that the new keypair is valid before persisting it
    if (getSslCertificate().isNull()) {
        qFatal("Newly generated certificate is unreadable");
    }
    if (getSslKey().isNull()) {
        qFatal("Newly generated private key is unreadable");
    }

    settings.setValue(SER_CERT, m_CachedPemCert);
    settings.setValue(SER_KEY, m_CachedPrivateKey);

    qInfo() << "Wrote new identity credentials to settings";
}
```
**File:** app/backend/identitymanager.cpp (L112-139)
```cpp
IdentityManager::IdentityManager()
{
    QSettings settings;

    m_CachedPemCert = settings.value(SER_CERT).toByteArray();
    m_CachedPrivateKey = settings.value(SER_KEY).toByteArray();

    if (m_CachedPemCert.isEmpty() || m_CachedPrivateKey.isEmpty()) {
        qInfo() << "No existing credentials found";
        createCredentials(settings);
    }
    else if (getSslCertificate().isNull()) {
        qWarning() << "Certificate is unreadable";
        createCredentials(settings);
    }
    else if (getSslKey().isNull()) {
        qWarning() << "Private key is unreadable";
        createCredentials(settings);
    }

    // We should have valid credentials now. If not, we're screwed
    if (getSslCertificate().isNull()) {
        qFatal("Certificate is unreadable");
    }
    if (getSslKey().isNull()) {
        qFatal("Private key is unreadable");
    }
}
```
**File:** app/backend/nvpairingmanager.cpp (L191-354)
```cpp
NvPairingManager::pair(QString appVersion, QString pin, QSslCertificate& serverCert)
{
    int serverMajorVersion = NvHTTP::parseQuad(appVersion).at(0);
    qInfo() << "Pairing with server generation:" << serverMajorVersion;

    QCryptographicHash::Algorithm hashAlgo;
    int hashLength;
    if (serverMajorVersion >= 7)
    {
        // Gen 7+ uses SHA-256 hashing
        hashAlgo = QCryptographicHash::Sha256;
        hashLength = 32;
    }
    else
    {
        // Prior to Gen 7 uses SHA-1 hashing
        hashAlgo = QCryptographicHash::Sha1;
        hashLength = 20;
    }

    QByteArray salt = generateRandomBytes(16);
    QByteArray saltedPin = saltPin(salt, pin);

    QByteArray aesKey = QCryptographicHash::hash(saltedPin, hashAlgo).constData();
    aesKey.truncate(16);

    QString getCert = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&phrase=getservercert&salt=" +
                                                    salt.toHex() + "&clientcert=" + IdentityManager::get()->getCertificate().toHex(),
                                                    0);
    NvHTTP::verifyResponseStatus(getCert);
    if (NvHTTP::getXmlString(getCert, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #1";
        return PairState::FAILED;
    }

    QByteArray serverCertStr = NvHTTP::getXmlStringFromHex(getCert, "plaincert");
    if (serverCertStr == nullptr)
    {
        qCritical() << "Server likely already pairing";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::ALREADY_IN_PROGRESS;
    }

    QSslCertificate unverifiedServerCert = QSslCertificate(serverCertStr);
    if (unverifiedServerCert.isNull()) {
        Q_ASSERT(!unverifiedServerCert.isNull());

        qCritical() << "Failed to parse plaincert";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    // Pin this cert for TLS until pairing is complete. If successful, we will propagate
    // the cert into the NvComputer object and persist it.
    m_Http.setServerCert(unverifiedServerCert);

    QByteArray randomChallenge = generateRandomBytes(16);
    QByteArray encryptedChallenge = encrypt(randomChallenge, aesKey);
    QString challengeXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                         "pair",
                                                         "devicename=roth&updateState=1&clientchallenge=" +
                                                         encryptedChallenge.toHex(),
                                                         REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(challengeXml);
    if (NvHTTP::getXmlString(challengeXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #2";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray challengeResponseData = decrypt(m_Http.getXmlStringFromHex(challengeXml, "challengeresponse"), aesKey);
    QByteArray clientSecretData = generateRandomBytes(16);
    QByteArray challengeResponse;
    QByteArray serverResponse(challengeResponseData.data(), hashLength);

#if (OPENSSL_VERSION_NUMBER < 0x10002000L)
    ASN1_BIT_STRING *asnSignature = m_Cert->signature;
#elif (OPENSSL_VERSION_NUMBER < 0x10100000L)
    ASN1_BIT_STRING *asnSignature;
    X509_get0_signature(&asnSignature, NULL, m_Cert);
#else
    const ASN1_BIT_STRING *asnSignature;
    X509_get0_signature(&asnSignature, NULL, m_Cert);
#endif

    challengeResponse.append(challengeResponseData.data() + hashLength, 16);
    challengeResponse.append(reinterpret_cast<char*>(asnSignature->data), asnSignature->length);
    challengeResponse.append(clientSecretData);

    QByteArray paddedHash = QCryptographicHash::hash(challengeResponse, hashAlgo);
    paddedHash.resize(32);
    QByteArray encryptedChallengeResponseHash = encrypt(paddedHash, aesKey);
    QString respXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&serverchallengeresp=" +
                                                    encryptedChallengeResponseHash.toHex(),
                                                    REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(respXml);
    if (NvHTTP::getXmlString(respXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #3";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray pairingSecret = NvHTTP::getXmlStringFromHex(respXml, "pairingsecret");
    QByteArray serverSecret = pairingSecret.left(16);
    QByteArray serverSignature = pairingSecret.mid(16);

    if (!verifySignature(serverSecret,
                         serverSignature,
                         serverCertStr))
    {
        qCritical() << "MITM detected";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray expectedResponseData;
    expectedResponseData.append(randomChallenge);
    expectedResponseData.append(getSignatureFromPemCert(serverCertStr));
    expectedResponseData.append(serverSecret);
    if (QCryptographicHash::hash(expectedResponseData, hashAlgo) != serverResponse)
    {
        qCritical() << "Incorrect PIN";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::PIN_WRONG;
    }

    QByteArray clientPairingSecret;
    clientPairingSecret.append(clientSecretData);
    clientPairingSecret.append(signMessage(clientSecretData));

    QString secretRespXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                          "pair",
                                                          "devicename=roth&updateState=1&clientpairingsecret=" +
                                                          clientPairingSecret.toHex(),
                                                          REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(secretRespXml);
    if (NvHTTP::getXmlString(secretRespXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #4";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QString pairChallengeXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttps,
                                                             "pair",
                                                             "devicename=roth&updateState=1&phrase=pairchallenge",
                                                             REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(pairChallengeXml);
    if (NvHTTP::getXmlString(pairChallengeXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #5";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    serverCert = std::move(unverifiedServerCert);
    return PairState::PAIRED;
```
**File:** app/backend/nvhttp.cpp (L43-46)
```cpp
void NvHTTP::setServerCert(QSslCertificate serverCert)
{
    m_ServerCert = serverCert;
}
```
**File:** app/backend/nvhttp.cpp (L419-439)
```cpp
void NvHTTP::handleSslErrors(QNetworkReply* reply, const QList<QSslError>& errors)
{
    bool ignoreErrors = true;

    if (m_ServerCert.isNull()) {
        // We should never make an HTTPS request without a cert
        Q_ASSERT(!m_ServerCert.isNull());
        return;
    }

    for (const QSslError& error : errors) {
        if (m_ServerCert != error.certificate()) {
            ignoreErrors = false;
            break;
        }
    }

    if (ignoreErrors) {
        reply->ignoreSslErrors(errors);
    }
}
```
**File:** app/backend/nvcomputer.h (L113-113)
```text
    QSslCertificate serverCert;
```
**File:** app/backend/computermanager.cpp (L599-603)
```cpp
           case NvPairingManager::PairState::PAIRED:
               // Persist the newly pinned server certificate for this host
               m_ComputerManager->saveHost(m_Computer);

               emit pairingCompleted(m_Computer, nullptr);
```
## Q7
When the client has launched/started the game and begun streaming before disconnecting, how does the client recover the connection?
### Answer
You're asking about how Moonlight handles connection recovery when a streaming session disconnects after it has already started.

## Answer

When a streaming session disconnects, Moonlight determines whether to call `/launch` or `/resume` based on the `currentgame` value from the host's `/serverinfo` response. moonlight-qt:1586-1586 

### Resume vs Launch Decision

In `Session::startConnectionAsync()`, the code checks if `m_Computer->currentgame` is non-zero (indicating a game is already running on the host): moonlight-qt:1556-1557 

If the game is already running, it calls `NvHTTP::startApp()` with the `"resume"` parameter instead of `"launch"`: moonlight-qt:1586-1593 

```cpp
http.startApp(m_Computer->currentgame != 0 ? "resume" : "launch",
              m_Computer->isNvidiaServerSoftware,
              m_App.id, &m_StreamConfig,
              enableGameOptimizations,
              m_Preferences->playAudioOnHost,
              m_InputHandler->getAttachedGamepadMask(),
              !m_Preferences->multiController,
              rtspSessionUrl);
```

### How Resume Works

The `/resume` endpoint tells the host to reconnect to an existing game session rather than starting a new one.<cite /> This preserves the game state and allows the client to rejoin the same streaming session.<cite />

The same connection establishment process follows after calling `/resume` - the RTSP session URL is obtained from the response and passed to `LiStartConnection()` to establish the streaming connection. moonlight-qt:1678-1680 

### State Detection

The host's state is tracked through periodic `/serverinfo` polling, which updates the `currentgame` field in the `NvComputer` object.<cite /> When the state shows `SUNSHINE_SERVER_BUSY` (as in your earlier example) with a non-zero `currentgame` value, Moonlight knows a game is already running and will use resume instead of launch.<cite />

## Notes

The resume functionality allows seamless reconnection to an existing game session without restarting the game on the host. This is particularly useful for temporary network interruptions or when the client application crashes but the host game continues running. The same certificate authentication and connection establishment process is used for both launch and resume operations.

Wiki pages you might want to explore:
- [User Interface System (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2)
- [Streaming Core (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#4)
### Citations
**File:** app/streaming/session.cpp (L1556-1557)
```cpp
    Q_ASSERT(m_Computer->currentGameId == 0 ||
             m_Computer->currentGameId == m_App.id);
```
**File:** app/streaming/session.cpp (L1586-1593)
```cpp
        http.startApp(m_Computer->currentGameId != 0 ? "resume" : "launch",
                      m_Computer->isNvidiaServerSoftware,
                      m_App.id, &m_StreamConfig,
                      enableGameOptimizations,
                      m_Preferences->playAudioOnHost,
                      m_InputHandler->getAttachedGamepadMask(),
                      !m_Preferences->multiController,
                      rtspSessionUrl);
```
**File:** app/streaming/session.cpp (L1678-1680)
```cpp
    int err = LiStartConnection(&hostInfo, &m_StreamConfig, &k_ConnCallbacks,
                                &m_VideoCallbacks, &m_AudioCallbacks,
                                NULL, 0, NULL, 0);
```
## Q8
How does the client terminate the connection?
### Answer
You're asking about how Moonlight terminates a streaming connection when the user wants to disconnect.

## Answer

Moonlight provides multiple ways to terminate a streaming connection:

### User-Initiated Disconnection

Users can disconnect from an active streaming session using keyboard shortcuts or gamepad button combinations. The UI displays a tip showing these options: **Ctrl+Alt+Shift+Q** for keyboard or **Start+Select+L1+R1** for gamepad. moonlight-qt:167-168 

### Connection Termination Flow

When a connection terminates, the `Session::clConnectionTerminated()` callback is invoked with an error code. moonlight-qt:98-155  This callback:

1. **Performs port testing** to diagnose connectivity issues if the termination was unexpected moonlight-qt:100-101 

2. **Determines if termination was graceful** - If the error code is `ML_ERROR_GRACEFUL_TERMINATION`, no error dialog is shown moonlight-qt:105-106 

3. **Displays error messages** for unexpected terminations (network issues, video encoding errors, etc.) moonlight-qt:108-144 

4. **Pushes a quit event** to the SDL event loop to exit the streaming session moonlight-qt:150-154 

### UI Cleanup After Termination

After the session ends, the `StreamSegue::sessionFinished()` method handles cleanup: moonlight-qt:73-108 

1. **Re-enables gamepad navigation** for the UI moonlight-qt:79-80 

2. **Pops the stream view** from the navigation stack to return to the previous screen moonlight-qt:93-94 

3. **Shows the main window** again moonlight-qt:96-97 

4. **Displays any error dialogs** if the termination was unexpected moonlight-qt:103-106 

The session object is then garbage collected to free resources. moonlight-qt:110-116 

### Quitting Running Apps

Moonlight can also terminate a running game on the host without streaming it. The `ComputerManager::quitRunningApp()` method creates a `PendingQuitTask` that sends a quit request to the host server. moonlight-qt:675-682  This is used when users want to stop a game remotely without connecting to it.

## Notes

The termination process distinguishes between graceful disconnections (user-initiated) and unexpected terminations (network errors, encoding failures). For unexpected terminations, Moonlight performs network diagnostics and displays helpful error messages to guide troubleshooting. The same cleanup process applies whether the user disconnects manually or the connection fails unexpectedly.

Wiki pages you might want to explore:
- [User Interface System (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2)
- [PC Discovery View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.1)
### Citations
**File:** app/gui/StreamSegue.qml (L73-108)
```text
    function sessionFinished(portTestResult)
    {
        if (portTestResult !== 0 && portTestResult !== -1 && streamSegueErrorDialog.text) {
            streamSegueErrorDialog.text += "\n\n" + qsTr("This PC's Internet connection is blocking Moonlight. Streaming over the Internet may not work while connected to this network.")
        }

        // Re-enable GUI gamepad usage now
        SdlGamepadKeyNavigation.enable()

        if (quitAfter) {
            if (streamSegueErrorDialog.text) {
                // Quit when the error dialog is acknowledged
                streamSegueErrorDialog.quitAfter = quitAfter
                streamSegueErrorDialog.open()
            }
            else {
                // Quit immediately
                Qt.quit()
            }
        } else {
            // Exit this view
            stackView.pop()

            // Show the Qt window again after streaming
            window.visible = true

            // Display any launch errors. We do this after
            // the Qt UI is visible again to prevent losing
            // focus on the dialog which would impact gamepad
            // users.
            if (streamSegueErrorDialog.text) {
                streamSegueErrorDialog.quitAfter = quitAfter
                streamSegueErrorDialog.open()
            }
        }
    }
```
**File:** app/gui/StreamSegue.qml (L110-116)
```text
    function sessionReadyForDeletion()
    {
        // Garbage collect the Session object since it's pretty heavyweight
        // and keeps other libraries (like SDL_TTF) around until it is deleted.
        session = null
        gc()
    }
```
**File:** app/gui/StreamSegue.qml (L167-168)
```text
            hintText.text = qsTr("Tip:") + " " + qsTr("Press %1 to disconnect your session").arg(SdlGamepadKeyNavigation.getConnectedGamepads() > 0 ?
                                                  qsTr("Start+Select+L1+R1") : qsTr("Ctrl+Alt+Shift+Q"))
```
**File:** app/streaming/session.cpp (L98-155)
```cpp
void Session::clConnectionTerminated(int errorCode)
{
    unsigned int portFlags = LiGetPortFlagsFromTerminationErrorCode(errorCode);
    s_ActiveSession->m_PortTestResults = LiTestClientConnectivity(CONN_TEST_SERVER, 443, portFlags);

    // Display the termination dialog if this was not intended
    switch (errorCode) {
    case ML_ERROR_GRACEFUL_TERMINATION:
        break;

    case ML_ERROR_NO_VIDEO_TRAFFIC:
        s_ActiveSession->m_UnexpectedTermination = true;

        char ports[128];
        SDL_assert(portFlags != 0);
        LiStringifyPortFlags(portFlags, ", ", ports, sizeof(ports));
        emit s_ActiveSession->displayLaunchError(tr("No video received from host.") + "\n\n"+
                                                 tr("Check your firewall and port forwarding rules for port(s): %1").arg(ports));
        break;

    case ML_ERROR_NO_VIDEO_FRAME:
        s_ActiveSession->m_UnexpectedTermination = true;
        emit s_ActiveSession->displayLaunchError(tr("Your network connection isn't performing well. Reduce your video bitrate setting or try a faster connection."));
        break;

    case ML_ERROR_PROTECTED_CONTENT:
    case ML_ERROR_UNEXPECTED_EARLY_TERMINATION:
        s_ActiveSession->m_UnexpectedTermination = true;
        emit s_ActiveSession->displayLaunchError(tr("Something went wrong on your host PC when starting the stream.") + "\n\n" +
                                                 tr("Make sure you don't have any DRM-protected content open on your host PC. You can also try restarting your host PC."));
        break;

    case ML_ERROR_FRAME_CONVERSION:
        s_ActiveSession->m_UnexpectedTermination = true;
        emit s_ActiveSession->displayLaunchError(tr("The host PC reported a fatal video encoding error.") + "\n\n" +
                                                 tr("Try disabling HDR mode, changing the streaming resolution, or changing your host PC's display resolution."));
        break;

    default:
        s_ActiveSession->m_UnexpectedTermination = true;

        // We'll assume large errors are hex values
        bool hexError = qAbs(errorCode) > 1000;
        emit s_ActiveSession->displayLaunchError(tr("Connection terminated") + "\n\n" +
                                                 tr("Error code: %1").arg(errorCode, hexError ? 8 : 0, hexError ? 16 : 10, QChar('0')));
        break;
    }

    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION,
                 "Connection terminated: %d",
                 errorCode);

    // Push a quit event to the main loop
    SDL_Event event;
    event.type = SDL_QUIT;
    event.quit.timestamp = SDL_GetTicks();
    SDL_PushEvent(&event);
}
```
**File:** app/backend/computermanager.cpp (L675-682)
```cpp
void ComputerManager::quitRunningApp(NvComputer* computer)
{
    QWriteLocker lock(&computer->lock);
    computer->pendingQuit = true;

    PendingQuitTask* quit = new PendingQuitTask(this, computer);
    QThreadPool::globalInstance()->start(quit);
}
```
## Q9
Please list all the APIs used for the client and server interaction, including their purposes and required parameters, and list the APIs needed for the entire process from adding a computer to selecting one in the app list and starting a connection to ending the connection.
### Answer
Based on my analysis of the Moonlight codebase, here are all the client-server interaction APIs used throughout the entire process:

## 1. **Adding a Computer**

### Server Discovery - `serverinfo` API
**Purpose**: Discover and retrieve information about the host PC, including pairing status, current game, server version, and HTTPS port. moonlight-qt:124-187 

**Required Parameters**:
- `uniqueid`: Common UID for Moonlight clients (fixed: "0123456789ABCDEF")
- `uuid`: Random UUID for the request

**Protocol**: HTTP initially (before pairing), then HTTPS (after pairing)

### Pairing - 5-Phase Cryptographic Handshake

**Purpose**: Establish trust between client and host PC through certificate exchange and PIN verification. moonlight-qt:191-355 

**Phase 1 - Get Server Certificate**:
- Endpoint: `pair`
- Parameters:
  - `devicename=roth`
  - `updateState=1`
  - `phrase=getservercert`
  - `salt`: 16-byte random salt (hex)
  - `clientcert`: Client certificate (hex)

**Phase 2 - Client Challenge**:
- Endpoint: `pair`
- Parameters:
  - `devicename=roth`
  - `updateState=1`
  - `clientchallenge`: Encrypted 16-byte challenge (hex)

**Phase 3 - Server Challenge Response**:
- Endpoint: `pair`
- Parameters:
  - `devicename=roth`
  - `updateState=1`
  - `serverchallengeresp`: Encrypted challenge response hash (hex)

**Phase 4 - Client Pairing Secret**:
- Endpoint: `pair`
- Parameters:
  - `devicename=roth`
  - `updateState=1`
  - `clientpairingsecret`: Client secret + signature (hex)

**Phase 5 - Final Challenge (HTTPS)**:
- Endpoint: `pair`
- Parameters:
  - `devicename=roth`
  - `updateState=1`
  - `phrase=pairchallenge`

**Protocol**: HTTP for phases 1-4, HTTPS for phase 5

## 2. **Selecting an App**

### App List - `applist` API
**Purpose**: Retrieve the list of available applications on the host PC. moonlight-qt:288-328 

**Required Parameters**:
- `uniqueid`: "0123456789ABCDEF"
- `uuid`: Random UUID

**Protocol**: HTTPS (requires prior pairing)

**Response**: XML with app information including:
- `AppTitle`: Application name
- `ID`: Application ID
- `IsHdrSupported`: HDR capability
- `IsAppCollectorGame`: Whether it's an App Collector game

### Box Art - `getBoxArt` API
**Purpose**: Download application cover art/thumbnails. moonlight-qt:178-179 moonlight-qt:107-129 

**Required Parameters**:
- `appId`: Application ID

**Protocol**: HTTPS
**Response**: Image data (various formats, cached as PNG locally)

## 3. **Starting a Streaming Connection**

### Launch/Resume - `launch` or `resume` API
**Purpose**: Start a new streaming session or resume an existing one. moonlight-qt:190-236 moonlight-qt:1582-1600 

**Endpoint**: `launch` (new session) or `resume` (existing session)

**Required Parameters**:
- `uniqueid`: "0123456789ABCDEF"
- `uuid`: Random UUID
- `appid`: Application ID to launch
- `mode`: Resolution and FPS (format: `{width}x{height}x{fps}`)
- `additionalStates=1`: Enable additional states
- `sops`: Stream optimization settings (0 or 1)
- `rikey`: Remote input AES key (hex)
- `rikeyid`: Remote input key ID
- `hdrMode`: HDR mode flag (included if HDR supported)
- `clientHdrCapVersion`, `clientHdrCapSupportedFlagsInUint32`, `clientHdrCapMetaDataId`, `clientHdrCapDisplayData`: HDR capability parameters (if HDR mode)
- `localAudioPlayMode`: Play audio on host (0 or 1)
- `surroundAudioInfo`: Surround audio configuration
- `remoteControllersBitmap`: Gamepad mask
- `gcmap`: Gamepad controller map
- `gcpersist`: Persist game controllers on disconnect (0 or 1)
- Additional parameters from `LiGetLaunchUrlQueryParameters()`

**Protocol**: HTTPS

**Response**: XML containing `sessionUrl0` (RTSP session URL)

**Decision Logic**: The verb is determined based on whether a game is currently running: moonlight-qt:1586-1593 

## 4. **Ending a Streaming Connection**

### Quit App - `cancel` API
**Purpose**: Terminate the currently running application on the host PC. moonlight-qt:238-259 

**Required Parameters**:
- `uniqueid`: "0123456789ABCDEF"
- `uuid`: Random UUID

**Protocol**: HTTPS

**Timeout**: 30 seconds

**Note**: The quit operation is optional based on user preferences: moonlight-qt:1554-1558 

## Additional APIs

### Wake-on-LAN
**Purpose**: Wake up a sleeping/powered-off host PC. moonlight-qt:1-50 

**Protocol**: UDP magic packets sent to multiple addresses and ports (9, 47009, and dynamic ports 47998-48010)

### Unpair - `unpair` API
**Purpose**: Remove pairing relationship (used during pairing failures). moonlight-qt:232-234 

**Required Parameters**: Standard uniqueid and uuid

**Protocol**: HTTP

## Notes

- All HTTP/HTTPS requests use a common `uniqueid` of "0123456789ABCDEF" to allow Moonlight clients to manage each other's sessions
- Each request includes a random `uuid` parameter generated via `QUuid::createUuid()`
- Certificate pinning is implemented for HTTPS connections to prevent MITM attacks
- Timeouts vary by operation: 2s (fast-fail), 5s (normal), 30s (resume/quit), 120s (launch)
- The base URL format is `http(s)://{host}:{port}/{command}?{parameters}`
### Citations
**File:** app/backend/nvhttp.cpp (L124-187)
```cpp
NvHTTP::getServerInfo(NvLogLevel logLevel, bool fastFail)
{
    QString serverInfo;

    // Check if we have a pinned cert and HTTPS port for this host yet
    if (!m_ServerCert.isNull() && httpsPort() != 0)
    {
        try
        {
            // Always try HTTPS first, since it properly reports
            // pairing status (and a few other attributes).
            serverInfo = openConnectionToString(m_BaseUrlHttps,
                                                "serverinfo",
                                                nullptr,
                                                fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                                logLevel);
            // Throws if the request failed
            verifyResponseStatus(serverInfo);
        }
        catch (const GfeHttpResponseException& e)
        {
            if (e.getStatusCode() == 401)
            {
                // Certificate validation error, fallback to HTTP
                serverInfo = openConnectionToString(m_BaseUrlHttp,
                                                    "serverinfo",
                                                    nullptr,
                                                    fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                                    logLevel);
                verifyResponseStatus(serverInfo);
            }
            else
            {
                // Rethrow real errors
                throw e;
            }
        }
    }
    else
    {
        // Only use HTTP prior to pairing or fetching HTTPS port
        serverInfo = openConnectionToString(m_BaseUrlHttp,
                                            "serverinfo",
                                            nullptr,
                                            fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                            logLevel);
        verifyResponseStatus(serverInfo);

        // Populate the HTTPS port
        uint16_t httpsPort = getXmlString(serverInfo, "HttpsPort").toUShort();
        if (httpsPort == 0) {
            httpsPort = DEFAULT_HTTPS_PORT;
        }
        setHttpsPort(httpsPort);

        // If we just needed to determine the HTTPS port, we'll try again over
        // HTTPS now that we have the port number
        if (!m_ServerCert.isNull()) {
            return getServerInfo(logLevel, fastFail);
        }
    }

    return serverInfo;
}
```
**File:** app/backend/nvhttp.cpp (L190-236)
```cpp
NvHTTP::startApp(QString verb,
                 bool isGfe,
                 int appId,
                 PSTREAM_CONFIGURATION streamConfig,
                 bool sops,
                 bool localAudio,
                 int gamepadMask,
                 bool persistGameControllersOnDisconnect,
                 QString& rtspSessionUrl)
{
    int riKeyId;

    memcpy(&riKeyId, streamConfig->remoteInputAesIv, sizeof(riKeyId));
    riKeyId = qFromBigEndian(riKeyId);

    QString response =
            openConnectionToString(m_BaseUrlHttps,
                                   verb,
                                   "appid="+QString::number(appId)+
                                   "&mode="+QString::number(streamConfig->width)+"x"+
                                   QString::number(streamConfig->height)+"x"+
                                   // Using an FPS value over 60 causes SOPS to default to 720p60,
                                   // so force it to 0 to ensure the correct resolution is set. We
                                   // used to use 60 here but that locked the frame rate to 60 FPS
                                   // on GFE 3.20.3. We don't need this hack for Sunshine.
                                   QString::number((streamConfig->fps > 60 && isGfe) ? 0 : streamConfig->fps)+
                                   "&additionalStates=1&sops="+QString::number(sops ? 1 : 0)+
                                   "&rikey="+QByteArray(streamConfig->remoteInputAesKey, sizeof(streamConfig->remoteInputAesKey)).toHex()+
                                   "&rikeyid="+QString::number(riKeyId)+
                                   ((streamConfig->supportedVideoFormats & VIDEO_FORMAT_MASK_10BIT) ?
                                       "&hdrMode=1&clientHdrCapVersion=0&clientHdrCapSupportedFlagsInUint32=0&clientHdrCapMetaDataId=NV_STATIC_METADATA_TYPE_1&clientHdrCapDisplayData=0x0x0x0x0x0x0x0x0x0x0" :
                                        "")+
                                   "&localAudioPlayMode="+QString::number(localAudio ? 1 : 0)+
                                   "&surroundAudioInfo="+QString::number(SURROUNDAUDIOINFO_FROM_AUDIO_CONFIGURATION(streamConfig->audioConfiguration))+
                                   "&remoteControllersBitmap="+QString::number(gamepadMask)+
                                   "&gcmap="+QString::number(gamepadMask)+
                                   "&gcpersist="+QString::number(persistGameControllersOnDisconnect ? 1 : 0)+
                                   LiGetLaunchUrlQueryParameters(),
                                   LAUNCH_TIMEOUT_MS);

    qInfo() << "Launch response:" << response;

    // Throws if the request failed
    verifyResponseStatus(response);

    rtspSessionUrl = getXmlString(response, "sessionUrl0");
}
```
**File:** app/backend/nvhttp.cpp (L238-259)
```cpp
void
NvHTTP::quitApp()
{
    QString response =
            openConnectionToString(m_BaseUrlHttps,
                                   "cancel",
                                   nullptr,
                                   QUIT_TIMEOUT_MS);

    qInfo() << "Quit response:" << response;

    // Throws if the request failed
    verifyResponseStatus(response);

    // Newer GFE versions will just return success even if quitting fails
    // if we're not the original requester.
    if (getCurrentGame(getServerInfo(NvHTTP::NVLL_ERROR)) != 0) {
        // Generate a synthetic GfeResponseException letting the caller know
        // that they can't kill someone else's stream.
        throw GfeHttpResponseException(599, "");
    }
}
```
**File:** app/backend/nvhttp.cpp (L288-328)
```cpp
QVector<NvApp>
NvHTTP::getAppList()
{
    QString appxml = openConnectionToString(m_BaseUrlHttps,
                                            "applist",
                                            nullptr,
                                            REQUEST_TIMEOUT_MS,
                                            NvLogLevel::NVLL_ERROR);
    verifyResponseStatus(appxml);

    QXmlStreamReader xmlReader(appxml);
    QVector<NvApp> apps;
    while (!xmlReader.atEnd()) {
        while (xmlReader.readNextStartElement()) {
            auto name = xmlReader.name();
            if (name == QString("App")) {
                // We must have a valid app before advancing to the next one
                if (!apps.isEmpty() && !apps.last().isInitialized()) {
                    qWarning() << "Invalid applist XML";
                    Q_ASSERT(false);
                    return QVector<NvApp>();
                }
                apps.append(NvApp());
            }
            else if (name == QString("AppTitle")) {
                apps.last().name = xmlReader.readElementText();
            }
            else if (name == QString("ID")) {
                apps.last().id = xmlReader.readElementText().toInt();
            }
            else if (name == QString("IsHdrSupported")) {
                apps.last().hdrSupported = xmlReader.readElementText() == "1";
            }
            else if (name == QString("IsAppCollectorGame")) {
                apps.last().isAppCollectorGame = xmlReader.readElementText() == "1";
            }
        }
    }

    return apps;
}
```
**File:** app/backend/nvpairingmanager.cpp (L191-355)
```cpp
NvPairingManager::pair(QString appVersion, QString pin, QSslCertificate& serverCert)
{
    int serverMajorVersion = NvHTTP::parseQuad(appVersion).at(0);
    qInfo() << "Pairing with server generation:" << serverMajorVersion;

    QCryptographicHash::Algorithm hashAlgo;
    int hashLength;
    if (serverMajorVersion >= 7)
    {
        // Gen 7+ uses SHA-256 hashing
        hashAlgo = QCryptographicHash::Sha256;
        hashLength = 32;
    }
    else
    {
        // Prior to Gen 7 uses SHA-1 hashing
        hashAlgo = QCryptographicHash::Sha1;
        hashLength = 20;
    }

    QByteArray salt = generateRandomBytes(16);
    QByteArray saltedPin = saltPin(salt, pin);

    QByteArray aesKey = QCryptographicHash::hash(saltedPin, hashAlgo).constData();
    aesKey.truncate(16);

    QString getCert = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&phrase=getservercert&salt=" +
                                                    salt.toHex() + "&clientcert=" + IdentityManager::get()->getCertificate().toHex(),
                                                    0);
    NvHTTP::verifyResponseStatus(getCert);
    if (NvHTTP::getXmlString(getCert, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #1";
        return PairState::FAILED;
    }

    QByteArray serverCertStr = NvHTTP::getXmlStringFromHex(getCert, "plaincert");
    if (serverCertStr == nullptr)
    {
        qCritical() << "Server likely already pairing";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::ALREADY_IN_PROGRESS;
    }

    QSslCertificate unverifiedServerCert = QSslCertificate(serverCertStr);
    if (unverifiedServerCert.isNull()) {
        Q_ASSERT(!unverifiedServerCert.isNull());

        qCritical() << "Failed to parse plaincert";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    // Pin this cert for TLS until pairing is complete. If successful, we will propagate
    // the cert into the NvComputer object and persist it.
    m_Http.setServerCert(unverifiedServerCert);

    QByteArray randomChallenge = generateRandomBytes(16);
    QByteArray encryptedChallenge = encrypt(randomChallenge, aesKey);
    QString challengeXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                         "pair",
                                                         "devicename=roth&updateState=1&clientchallenge=" +
                                                         encryptedChallenge.toHex(),
                                                         REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(challengeXml);
    if (NvHTTP::getXmlString(challengeXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #2";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray challengeResponseData = decrypt(m_Http.getXmlStringFromHex(challengeXml, "challengeresponse"), aesKey);
    QByteArray clientSecretData = generateRandomBytes(16);
    QByteArray challengeResponse;
    QByteArray serverResponse(challengeResponseData.data(), hashLength);

#if (OPENSSL_VERSION_NUMBER < 0x10002000L)
    ASN1_BIT_STRING *asnSignature = m_Cert->signature;
#elif (OPENSSL_VERSION_NUMBER < 0x10100000L)
    ASN1_BIT_STRING *asnSignature;
    X509_get0_signature(&asnSignature, NULL, m_Cert);
#else
    const ASN1_BIT_STRING *asnSignature;
    X509_get0_signature(&asnSignature, NULL, m_Cert);
#endif

    challengeResponse.append(challengeResponseData.data() + hashLength, 16);
    challengeResponse.append(reinterpret_cast<char*>(asnSignature->data), asnSignature->length);
    challengeResponse.append(clientSecretData);

    QByteArray paddedHash = QCryptographicHash::hash(challengeResponse, hashAlgo);
    paddedHash.resize(32);
    QByteArray encryptedChallengeResponseHash = encrypt(paddedHash, aesKey);
    QString respXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&serverchallengeresp=" +
                                                    encryptedChallengeResponseHash.toHex(),
                                                    REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(respXml);
    if (NvHTTP::getXmlString(respXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #3";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray pairingSecret = NvHTTP::getXmlStringFromHex(respXml, "pairingsecret");
    QByteArray serverSecret = pairingSecret.left(16);
    QByteArray serverSignature = pairingSecret.mid(16);

    if (!verifySignature(serverSecret,
                         serverSignature,
                         serverCertStr))
    {
        qCritical() << "MITM detected";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray expectedResponseData;
    expectedResponseData.append(randomChallenge);
    expectedResponseData.append(getSignatureFromPemCert(serverCertStr));
    expectedResponseData.append(serverSecret);
    if (QCryptographicHash::hash(expectedResponseData, hashAlgo) != serverResponse)
    {
        qCritical() << "Incorrect PIN";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::PIN_WRONG;
    }

    QByteArray clientPairingSecret;
    clientPairingSecret.append(clientSecretData);
    clientPairingSecret.append(signMessage(clientSecretData));

    QString secretRespXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                          "pair",
                                                          "devicename=roth&updateState=1&clientpairingsecret=" +
                                                          clientPairingSecret.toHex(),
                                                          REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(secretRespXml);
    if (NvHTTP::getXmlString(secretRespXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #4";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QString pairChallengeXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttps,
                                                             "pair",
                                                             "devicename=roth&updateState=1&phrase=pairchallenge",
                                                             REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(pairChallengeXml);
    if (NvHTTP::getXmlString(pairChallengeXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #5";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    serverCert = std::move(unverifiedServerCert);
    return PairState::PAIRED;
}
```
**File:** app/backend/nvhttp.h (L178-179)
```text
    QImage
    getBoxArt(int appId);
```
**File:** app/backend/boxartmanager.cpp (L107-129)
```cpp
QUrl BoxArtManager::loadBoxArtFromNetwork(NvComputer* computer, int appId)
{
    NvHTTP http(computer);

    QString cachePath = getFilePathForBoxArt(computer, appId);
    QImage image;
    try {
        image = http.getBoxArt(appId);
    } catch (...) {}

    // Cache the box art on disk if it loaded
    if (!image.isNull()) {
        if (image.save(cachePath)) {
            return QUrl::fromLocalFile(cachePath);
        }
        else {
            // A failed save() may leave a zero byte file. Make sure that's removed.
            QFile(cachePath).remove();
        }
    }

    return QUrl();
}
```
**File:** app/streaming/session.cpp (L1554-1558)
```cpp
    // The UI should have ensured the old game was already quit
    // if we decide to stream a different game.
    Q_ASSERT(m_Computer->currentGameId == 0 ||
             m_Computer->currentGameId == m_App.id);

```
**File:** app/streaming/session.cpp (L1582-1600)
```cpp
    QString rtspSessionUrl;

    try {
        NvHTTP http(m_Computer);
        http.startApp(m_Computer->currentGameId != 0 ? "resume" : "launch",
                      m_Computer->isNvidiaServerSoftware,
                      m_App.id, &m_StreamConfig,
                      enableGameOptimizations,
                      m_Preferences->playAudioOnHost,
                      m_InputHandler->getAttachedGamepadMask(),
                      !m_Preferences->multiController,
                      rtspSessionUrl);
    } catch (const GfeHttpResponseException& e) {
        emit displayLaunchError(tr("Host returned error: %1").arg(e.toQString()));
        return false;
    } catch (const QtNetworkReplyException& e) {
        emit displayLaunchError(e.toQString());
        return false;
    }
```
**File:** app/backend/nvcomputer.cpp (L1-50)
```cpp
#include "nvcomputer.h"
#include "nvapp.h"
#include "settings/compatfetcher.h"

#include <QUdpSocket>
#include <QHostInfo>
#include <QNetworkInterface>
#include <QNetworkProxy>

#define SER_NAME "hostname"
#define SER_UUID "uuid"
#define SER_MAC "mac"
#define SER_LOCALADDR "localaddress"
#define SER_LOCALPORT "localport"
#define SER_REMOTEADDR "remoteaddress"
#define SER_REMOTEPORT "remoteport"
#define SER_MANUALADDR "manualaddress"
#define SER_MANUALPORT "manualport"
#define SER_IPV6ADDR "ipv6address"
#define SER_IPV6PORT "ipv6port"
#define SER_APPLIST "apps"
#define SER_SRVCERT "srvcert"
#define SER_CUSTOMNAME "customname"
#define SER_NVIDIASOFTWARE "nvidiasw"

NvComputer::NvComputer(QSettings& settings)
{
    this->name = settings.value(SER_NAME).toString();
    this->uuid = settings.value(SER_UUID).toString();
    this->hasCustomName = settings.value(SER_CUSTOMNAME).toBool();
    this->macAddress = settings.value(SER_MAC).toByteArray();
    this->localAddress = NvAddress(settings.value(SER_LOCALADDR).toString(),
                                   settings.value(SER_LOCALPORT, QVariant(DEFAULT_HTTP_PORT)).toUInt());
    this->remoteAddress = NvAddress(settings.value(SER_REMOTEADDR).toString(),
                                    settings.value(SER_REMOTEPORT, QVariant(DEFAULT_HTTP_PORT)).toUInt());
    this->ipv6Address = NvAddress(settings.value(SER_IPV6ADDR).toString(),
                                  settings.value(SER_IPV6PORT, QVariant(DEFAULT_HTTP_PORT)).toUInt());
    this->manualAddress = NvAddress(settings.value(SER_MANUALADDR).toString(),
                                    settings.value(SER_MANUALPORT, QVariant(DEFAULT_HTTP_PORT)).toUInt());
    this->serverCert = QSslCertificate(settings.value(SER_SRVCERT).toByteArray());
    this->isNvidiaServerSoftware = settings.value(SER_NVIDIASOFTWARE).toBool();

    int appCount = settings.beginReadArray(SER_APPLIST);
    this->appList.reserve(appCount);
    for (int i = 0; i < appCount; i++) {
        settings.setArrayIndex(i);

        NvApp app(settings);
        this->appList.append(app);
    }
```
## Q10
The server completes the pairing by inputting the PIN code displayed by the client. How does the client wait for the server's response to complete the pairing during the time the PIN code is generated and the user inputs the PIN on the server side?
### Answer
You're asking about how the Moonlight client waits for the server to complete pairing after displaying the PIN code to the user.

## Answer

The client doesn't actively poll or wait for the server's response during pairing. Instead, the pairing process is **synchronous and blocking** - the client sends requests sequentially through all 5 phases and waits for each response before proceeding to the next phase.

### Pairing Execution Flow

When the user clicks on an unpaired PC, the client generates a PIN and displays it in a dialog: moonlight-qt:239-246 

The pairing task runs in a background thread via `PendingPairingTask`: moonlight-qt:564-582 

### The Blocking Nature of Pairing

Inside `NvPairingManager::pair()`, each phase makes an HTTP/HTTPS request and **blocks waiting for the response** before proceeding: moonlight-qt:217-227 

The server validates the PIN during Phase 3 (server challenge response). If the user hasn't entered the PIN yet on the server side, the server simply doesn't respond or returns an error, causing the pairing to fail: moonlight-qt:287-298 

### PIN Validation

The PIN validation happens when the client sends the encrypted challenge response hash in Phase 3. The server decrypts this using the PIN-derived key and verifies it matches the expected value: moonlight-qt:313-322 

If the PIN is incorrect (user entered wrong PIN on server), the server returns a response that causes the client to detect `PIN_WRONG` state: moonlight-qt:585-586 

### UI Feedback

While pairing is in progress, the dialog remains open showing the PIN: moonlight-qt:302-310 

When pairing completes (successfully or with error), the `pairingCompleted` signal is emitted, which closes the dialog: moonlight-qt:47-58 

## Notes

The pairing process uses HTTP request timeouts (defined as `REQUEST_TIMEOUT_MS`) to prevent indefinite waiting. If the user takes too long to enter the PIN on the server, the HTTP request will timeout and pairing will fail. The client doesn't implement any retry logic or polling mechanism - it's a single synchronous attempt that either succeeds or fails based on the server's responses to the 5-phase handshake.

Wiki pages you might want to explore:
- [User Interface System (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2)
- [PC Discovery View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.1)
### Citations
**File:** app/gui/PcView.qml (L47-58)
```text
    function pairingComplete(error)
    {
        // Close the PIN dialog
        pairDialog.close()

        // Display a failed dialog if we got an error
        if (error !== undefined) {
            errorDialog.text = error
            errorDialog.helpText = ""
            errorDialog.open()
        }
    }
```
**File:** app/gui/PcView.qml (L239-246)
```text
                    var pin = computerModel.generatePinString()

                    // Kick off pairing in the background
                    computerModel.pairComputer(index, pin)

                    // Display the pairing dialog
                    pairDialog.pin = pin
                    pairDialog.open()
```
**File:** app/gui/PcView.qml (L302-310)
```text
        // don't allow edits to the rest of the window while open
        property string pin : "0000"
        text:qsTr("Please enter %1 on your host PC. This dialog will close when pairing is completed.").arg(pin)+"\n\n"+
             qsTr("If your host PC is running Sunshine, navigate to the Sunshine web UI to enter the PIN.")
        standardButtons: Dialog.Cancel
        onRejected: {
            // FIXME: We should interrupt pairing here
        }
    }
```
**File:** app/backend/computermanager.cpp (L564-582)
```cpp
    PendingPairingTask(ComputerManager* computerManager, NvComputer* computer, QString pin)
        : m_ComputerManager(computerManager),
          m_Computer(computer),
          m_Pin(pin)
    {
        connect(this, &PendingPairingTask::pairingCompleted,
                computerManager, &ComputerManager::pairingCompleted);
    }

signals:
    void pairingCompleted(NvComputer* computer, QString error);

private:
    void run()
    {
        NvPairingManager pairingManager(m_Computer);

        try {
           NvPairingManager::PairState result = pairingManager.pair(m_Computer->appVersion, m_Pin, m_Computer->serverCert);
```
**File:** app/backend/computermanager.cpp (L585-586)
```cpp
           case NvPairingManager::PairState::PIN_WRONG:
               emit pairingCompleted(m_Computer, tr("The PIN from the PC didn't match. Please try again."));
```
**File:** app/backend/nvpairingmanager.cpp (L217-227)
```cpp
    QString getCert = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&phrase=getservercert&salt=" +
                                                    salt.toHex() + "&clientcert=" + IdentityManager::get()->getCertificate().toHex(),
                                                    0);
    NvHTTP::verifyResponseStatus(getCert);
    if (NvHTTP::getXmlString(getCert, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #1";
        return PairState::FAILED;
    }
```
**File:** app/backend/nvpairingmanager.cpp (L287-298)
```cpp
    QString respXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&serverchallengeresp=" +
                                                    encryptedChallengeResponseHash.toHex(),
                                                    REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(respXml);
    if (NvHTTP::getXmlString(respXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #3";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }
```
**File:** app/backend/nvpairingmanager.cpp (L313-322)
```cpp
    QByteArray expectedResponseData;
    expectedResponseData.append(randomChallenge);
    expectedResponseData.append(getSignatureFromPemCert(serverCertStr));
    expectedResponseData.append(serverSecret);
    if (QCryptographicHash::hash(expectedResponseData, hashAlgo) != serverResponse)
    {
        qCritical() << "Incorrect PIN";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::PIN_WRONG;
    }
```
# DeepWiki Q&A with Code Context for Repository: moonlight-stream/moonlight-qt
## Q1
how to get /launch and /serverinfo info from server?
### Answer
Based on the code context, you're asking about how Moonlight retrieves `/launch` and `/serverinfo` information from the host server.

## Answer

Moonlight uses the `NvHTTP` class to communicate with the host server and retrieve information through HTTP/HTTPS endpoints. moonlight-qt:124-187 

### Getting `/serverinfo`

The `NvHTTP::getServerInfo()` method fetches server information: moonlight-qt:124-140 

The method first attempts to use HTTPS if a pinned certificate is available, then falls back to HTTP if needed. moonlight-qt:143-160  If no certificate exists yet, it uses HTTP initially to fetch the HTTPS port, then retries over HTTPS. moonlight-qt:162-183 

This is called during PC discovery when adding a new host: moonlight-qt:809-818 

The response is then used to create or update an `NvComputer` object: moonlight-qt:820-821 

### Getting `/launch` info

The `/launch` endpoint is called via `NvHTTP::startApp()` when starting a streaming session: moonlight-qt:1585-1593 

This happens in `Session::startConnectionAsync()` after the user selects an app to stream. moonlight-qt:1548-1600  The method passes streaming configuration parameters and receives back an RTSP session URL that's used to establish the actual streaming connection. moonlight-qt:1582-1593 

## Notes

The `NvHTTP` class handles all HTTP/HTTPS communication with the host server, including certificate pinning for security. The `/serverinfo` endpoint is polled regularly to monitor PC status, while `/launch` (or `/resume`) is only called when initiating a streaming session. Both endpoints use the base URL constructed from the host's address and appropriate port (HTTP 47989 or HTTPS 47984 by default).

Wiki pages you might want to explore:
- [User Interface System (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2)
- [PC Discovery View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.1)
### Citations
**File:** app/backend/nvhttp.cpp (L124-187)
```cpp
NvHTTP::getServerInfo(NvLogLevel logLevel, bool fastFail)
{
    QString serverInfo;

    // Check if we have a pinned cert and HTTPS port for this host yet
    if (!m_ServerCert.isNull() && httpsPort() != 0)
    {
        try
        {
            // Always try HTTPS first, since it properly reports
            // pairing status (and a few other attributes).
            serverInfo = openConnectionToString(m_BaseUrlHttps,
                                                "serverinfo",
                                                nullptr,
                                                fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                                logLevel);
            // Throws if the request failed
            verifyResponseStatus(serverInfo);
        }
        catch (const GfeHttpResponseException& e)
        {
            if (e.getStatusCode() == 401)
            {
                // Certificate validation error, fallback to HTTP
                serverInfo = openConnectionToString(m_BaseUrlHttp,
                                                    "serverinfo",
                                                    nullptr,
                                                    fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                                    logLevel);
                verifyResponseStatus(serverInfo);
            }
            else
            {
                // Rethrow real errors
                throw e;
            }
        }
    }
    else
    {
        // Only use HTTP prior to pairing or fetching HTTPS port
        serverInfo = openConnectionToString(m_BaseUrlHttp,
                                            "serverinfo",
                                            nullptr,
                                            fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                            logLevel);
        verifyResponseStatus(serverInfo);

        // Populate the HTTPS port
        uint16_t httpsPort = getXmlString(serverInfo, "HttpsPort").toUShort();
        if (httpsPort == 0) {
            httpsPort = DEFAULT_HTTPS_PORT;
        }
        setHttpsPort(httpsPort);

        // If we just needed to determine the HTTPS port, we'll try again over
        // HTTPS now that we have the port number
        if (!m_ServerCert.isNull()) {
            return getServerInfo(logLevel, fastFail);
        }
    }

    return serverInfo;
}
```
**File:** app/backend/computermanager.cpp (L809-818)
```cpp
        // Perform initial serverinfo fetch over HTTP since we don't know which cert to use
        QString serverInfo = fetchServerInfo(http);
        if (serverInfo.isEmpty() && !m_MdnsIpv6Address.isNull()) {
            // Retry using the global IPv6 address if the IPv4 or link-local IPv6 address fails
            http.setAddress(m_MdnsIpv6Address);
            serverInfo = fetchServerInfo(http);
        }
        if (serverInfo.isEmpty()) {
            return;
        }
```
**File:** app/backend/computermanager.cpp (L820-821)
```cpp
        // Create initial newComputer using HTTP serverinfo with no pinned cert
        NvComputer* newComputer = new NvComputer(http, serverInfo);
```
**File:** app/streaming/session.cpp (L1548-1600)
```cpp
bool Session::startConnectionAsync()
{
    // Wait 1.5 seconds before connecting to let the user
    // have time to read any messages present on the segue
    SDL_Delay(1500);

    // The UI should have ensured the old game was already quit
    // if we decide to stream a different game.
    Q_ASSERT(m_Computer->currentGameId == 0 ||
             m_Computer->currentGameId == m_App.id);

    bool enableGameOptimizations;
    if (m_Computer->isNvidiaServerSoftware) {
        // GFE will set all settings to 720p60 if it doesn't recognize
        // the chosen resolution. Avoid that by disabling SOPS when it
        // is not streaming a supported resolution.
        enableGameOptimizations = false;
        for (const NvDisplayMode &mode : m_Computer->displayModes) {
            if (mode.width == m_StreamConfig.width &&
                    mode.height == m_StreamConfig.height) {
                SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION,
                            "Found host supported resolution: %dx%d",
                            mode.width, mode.height);
                enableGameOptimizations = m_Preferences->gameOptimizations;
                break;
            }
        }
    }
    else {
        // Always send SOPS to Sunshine because we may repurpose the
        // option to control whether the display mode is adjusted
        enableGameOptimizations = m_Preferences->gameOptimizations;
    }

    QString rtspSessionUrl;

    try {
        NvHTTP http(m_Computer);
        http.startApp(m_Computer->currentGameId != 0 ? "resume" : "launch",
                      m_Computer->isNvidiaServerSoftware,
                      m_App.id, &m_StreamConfig,
                      enableGameOptimizations,
                      m_Preferences->playAudioOnHost,
                      m_InputHandler->getAttachedGamepadMask(),
                      !m_Preferences->multiController,
                      rtspSessionUrl);
    } catch (const GfeHttpResponseException& e) {
        emit displayLaunchError(tr("Host returned error: %1").arg(e.toQString()));
        return false;
    } catch (const QtNetworkReplyException& e) {
        emit displayLaunchError(e.toQString());
        return false;
    }
```
## Q2
How to parse the information returned by the above 2 interfaces and provide it to the function for establishing a streaming connection?
### Answer
You're asking about how Moonlight parses the responses from `/serverinfo` and `/launch` endpoints and uses that information to establish a streaming connection.

## Answer

### Parsing `/serverinfo` Response

The `/serverinfo` response is parsed to create/update an `NvComputer` object that stores host capabilities. moonlight-qt:754-782  The `NvHTTP::getServerInfo()` method returns an XML string that gets parsed to extract server properties like:<cite />

- Server codec mode support (`serverCodecModeSupport`)
- GFE version (`gfeVersion`)
- App version (`appVersion`)
- Display modes
- Current game ID

These properties are stored in the `NvComputer` object and later used during session validation and configuration.<cite />

### Parsing `/launch` Response and Establishing Connection

When starting a stream, `NvHTTP::startApp()` is called with the `STREAM_CONFIGURATION` structure containing all streaming parameters (resolution, FPS, bitrate, codec preferences, etc.). moonlight-qt:189-236  The method constructs a URL with query parameters including:<cite />

- Resolution and FPS (`mode` parameter)
- HDR settings
- Audio configuration
- Gamepad mask
- Remote input encryption keys

The response is parsed to extract the `rtspSessionUrl` using `getXmlString(response, "sessionUrl0")`. moonlight-qt:235-235 

### Providing Information to Connection Function

After receiving the `/launch` response, the parsed information is used to populate a `SERVER_INFORMATION` structure: moonlight-qt:1602-1624 

```cpp
SERVER_INFORMATION hostInfo;
hostInfo.address = hostnameStr.data();
hostInfo.serverInfoAppVersion = siAppVersion.data();
hostInfo.serverCodecModeSupport = m_Computer->serverCodecModeSupport;
hostInfo.serverInfoGfeVersion = siGfeVersion.data();
hostInfo.rtspSessionUrl = rtspSessionUrlStr.data();
```

This structure, along with the `STREAM_CONFIGURATION` and callback structures, is passed to `LiStartConnection()` to establish the actual streaming connection: moonlight-qt:1678-1685 

The `LiStartConnection()` function (from the moonlight-common-c library) uses:
- The RTSP session URL from `/launch` response to establish the RTSP control channel
- Server codec support from `/serverinfo` to negotiate video formats
- Stream configuration to set up video/audio decoders

### Validation Before Connection

Before calling `LiStartConnection()`, the session validates that the host supports the requested features by checking `m_Computer->serverCodecModeSupport` against the requested video formats. moonlight-qt:1117-1152  For example, it verifies YUV 4:4:4 support and adjusts the supported video formats list accordingly.<cite />

## Notes

The parsing happens in two stages: first during PC discovery (parsing `/serverinfo` into `NvComputer` properties), then during session start (parsing `/launch` response for RTSP URL). The `NvComputer` object acts as a bridge, storing server capabilities that are later referenced when configuring the `SERVER_INFORMATION` structure for `LiStartConnection()`. The actual XML parsing is handled by helper functions like `getXmlString()` in the `NvHTTP` class.

Wiki pages you might want to explore:
- [Settings View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.2)
- [Input Handling (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#4.7)
### Citations
**File:** app/backend/computermanager.cpp (L754-782)
```cpp
    QString fetchServerInfo(NvHTTP& http)
    {
        QString serverInfo;

        // Do nothing if we're quitting
        if (m_AboutToQuit) {
            return QString();
        }

        try {
            // There's a race condition between GameStream servers reporting presence over
            // mDNS and the HTTPS server being ready to respond to our queries. To work
            // around this issue, we will issue the request again after a few seconds if
            // we see a ServiceUnavailableError error.
            try {
                serverInfo = http.getServerInfo(NvHTTP::NVLL_VERBOSE);
            } catch (const QtNetworkReplyException& e) {
                if (e.getError() == QNetworkReply::ServiceUnavailableError) {
                    qWarning() << "Retrying request in 5 seconds after ServiceUnavailableError";
                    QThread::sleep(5);
                    serverInfo = http.getServerInfo(NvHTTP::NVLL_VERBOSE);
                    qInfo() << "Retry successful";
                }
                else {
                    // Rethrow other errors
                    throw e;
                }
            }
            return serverInfo;
```
**File:** app/backend/nvhttp.cpp (L189-236)
```cpp
void
NvHTTP::startApp(QString verb,
                 bool isGfe,
                 int appId,
                 PSTREAM_CONFIGURATION streamConfig,
                 bool sops,
                 bool localAudio,
                 int gamepadMask,
                 bool persistGameControllersOnDisconnect,
                 QString& rtspSessionUrl)
{
    int riKeyId;

    memcpy(&riKeyId, streamConfig->remoteInputAesIv, sizeof(riKeyId));
    riKeyId = qFromBigEndian(riKeyId);

    QString response =
            openConnectionToString(m_BaseUrlHttps,
                                   verb,
                                   "appid="+QString::number(appId)+
                                   "&mode="+QString::number(streamConfig->width)+"x"+
                                   QString::number(streamConfig->height)+"x"+
                                   // Using an FPS value over 60 causes SOPS to default to 720p60,
                                   // so force it to 0 to ensure the correct resolution is set. We
                                   // used to use 60 here but that locked the frame rate to 60 FPS
                                   // on GFE 3.20.3. We don't need this hack for Sunshine.
                                   QString::number((streamConfig->fps > 60 && isGfe) ? 0 : streamConfig->fps)+
                                   "&additionalStates=1&sops="+QString::number(sops ? 1 : 0)+
                                   "&rikey="+QByteArray(streamConfig->remoteInputAesKey, sizeof(streamConfig->remoteInputAesKey)).toHex()+
                                   "&rikeyid="+QString::number(riKeyId)+
                                   ((streamConfig->supportedVideoFormats & VIDEO_FORMAT_MASK_10BIT) ?
                                       "&hdrMode=1&clientHdrCapVersion=0&clientHdrCapSupportedFlagsInUint32=0&clientHdrCapMetaDataId=NV_STATIC_METADATA_TYPE_1&clientHdrCapDisplayData=0x0x0x0x0x0x0x0x0x0x0" :
                                        "")+
                                   "&localAudioPlayMode="+QString::number(localAudio ? 1 : 0)+
                                   "&surroundAudioInfo="+QString::number(SURROUNDAUDIOINFO_FROM_AUDIO_CONFIGURATION(streamConfig->audioConfiguration))+
                                   "&remoteControllersBitmap="+QString::number(gamepadMask)+
                                   "&gcmap="+QString::number(gamepadMask)+
                                   "&gcpersist="+QString::number(persistGameControllersOnDisconnect ? 1 : 0)+
                                   LiGetLaunchUrlQueryParameters(),
                                   LAUNCH_TIMEOUT_MS);

    qInfo() << "Launch response:" << response;

    // Throws if the request failed
    verifyResponseStatus(response);

    rtspSessionUrl = getXmlString(response, "sessionUrl0");
}
```
**File:** app/streaming/session.cpp (L1117-1152)
```cpp
    if (m_Preferences->enableYUV444) {
        if (!(m_Computer->serverCodecModeSupport & SCM_MASK_YUV444)) {
            emitLaunchWarning(tr("Your host PC doesn't support YUV 4:4:4 streaming."));
            m_SupportedVideoFormats.removeByMask(VIDEO_FORMAT_MASK_YUV444);
        }
        else {
            m_SupportedVideoFormats.removeByMask(~m_SupportedVideoFormats.maskByServerCodecModes(m_Computer->serverCodecModeSupport));

            if (!m_SupportedVideoFormats.isEmpty() &&
                !(m_SupportedVideoFormats.front() & VIDEO_FORMAT_MASK_YUV444)) {
                emitLaunchWarning(tr("Your host PC doesn't support YUV 4:4:4 streaming for selected video codec."));
            }
            else if (m_Preferences->videoDecoderSelection != StreamingPreferences::VDS_FORCE_SOFTWARE) {
                while (!m_SupportedVideoFormats.isEmpty() &&
                       (m_SupportedVideoFormats.front() & VIDEO_FORMAT_MASK_YUV444) &&
                       getDecoderAvailability(testWindow,
                                              m_Preferences->videoDecoderSelection,
                                              m_SupportedVideoFormats.front(),
                                              m_StreamConfig.width,
                                              m_StreamConfig.height,
                                              m_StreamConfig.fps) != DecoderAvailability::Hardware) {
                    if (m_Preferences->videoDecoderSelection == StreamingPreferences::VDS_FORCE_HARDWARE) {
                        m_SupportedVideoFormats.removeFirst();
                    }
                    else {
                        emitLaunchWarning(tr("Using software decoding due to your selection to force YUV 4:4:4 without GPU support. This may cause poor streaming performance."));
                        break;
                    }
                }
                if (!m_SupportedVideoFormats.isEmpty() &&
                    !(m_SupportedVideoFormats.front() & VIDEO_FORMAT_MASK_YUV444)) {
                    emitLaunchWarning(tr("This PC's GPU doesn't support YUV 4:4:4 decoding for selected video codec."));
                }
            }
        }
    }
```
**File:** app/streaming/session.cpp (L1602-1624)
```cpp
    QByteArray hostnameStr = m_Computer->activeAddress.address().toLatin1();
    QByteArray siAppVersion = m_Computer->appVersion.toLatin1();

    SERVER_INFORMATION hostInfo;
    hostInfo.address = hostnameStr.data();
    hostInfo.serverInfoAppVersion = siAppVersion.data();
    hostInfo.serverCodecModeSupport = m_Computer->serverCodecModeSupport;

    // Older GFE versions didn't have this field
    QByteArray siGfeVersion;
    if (!m_Computer->gfeVersion.isEmpty()) {
        siGfeVersion = m_Computer->gfeVersion.toLatin1();
    }
    if (!siGfeVersion.isEmpty()) {
        hostInfo.serverInfoGfeVersion = siGfeVersion.data();
    }

    // Older GFE and Sunshine versions didn't have this field
    QByteArray rtspSessionUrlStr;
    if (!rtspSessionUrl.isEmpty()) {
        rtspSessionUrlStr = rtspSessionUrl.toLatin1();
        hostInfo.rtspSessionUrl = rtspSessionUrlStr.data();
    }
```
**File:** app/streaming/session.cpp (L1678-1685)
```cpp
    int err = LiStartConnection(&hostInfo, &m_StreamConfig, &k_ConnCallbacks,
                                &m_VideoCallbacks, &m_AudioCallbacks,
                                NULL, 0, NULL, 0);
    if (err != 0) {
        // We already displayed an error dialog in the stage failure
        // listener.
        return false;
    }
```
## Q3
how to get "Remote input encryption keys"
### Answer
You're asking about how Moonlight generates the "Remote input encryption keys" that are sent to the host server during the `/launch` request.

## Answer

The remote input encryption keys (`rikey` and `rikeyid`) are randomly generated AES encryption keys used to secure input data sent from the client to the host during streaming. moonlight-qt:692-696 

### Key Generation

During session initialization in `Session::initialize()`, Moonlight generates these keys using OpenSSL's cryptographically secure random number generator:

```cpp
RAND_bytes(reinterpret_cast<unsigned char*>(m_StreamConfig.remoteInputAesKey),
           sizeof(m_StreamConfig.remoteInputAesKey));

// Only the first 4 bytes are populated in the RI key IV
RAND_bytes(reinterpret_cast<unsigned char*>(m_StreamConfig.remoteInputAesIv), 4);
``` moonlight-qt:692-696 

The `remoteInputAesKey` is a full AES key (16 bytes), while `remoteInputAesIv` only uses the first 4 bytes as an initialization vector. moonlight-qt:692-696 

### Sending Keys to Host

These generated keys are then sent to the host server when calling the `/launch` endpoint in `NvHTTP::startApp()`. moonlight-qt:200-218  The method:

1. Extracts the key ID from the IV by reading the first 4 bytes as a big-endian integer moonlight-qt:200-203 
2. Converts the AES key to hexadecimal format using `QByteArray(...).toHex()` moonlight-qt:217-217 
3. Includes both values as query parameters: `rikey=<hex_key>&rikeyid=<key_id>` moonlight-qt:217-218 

### Security Considerations

For security, these keys are automatically redacted from log files to prevent exposure. moonlight-qt:108-110  The logging system uses regex patterns to strip `rikey` and `rikeyid` values before writing to logs. moonlight-qt:88-88 

## Notes

The remote input encryption is part of Moonlight's security features to protect input data (keyboard, mouse, gamepad) transmitted during streaming. The keys are generated fresh for each streaming session and are stored in the `STREAM_CONFIGURATION` structure (`m_StreamConfig`) which is later passed to `LiStartConnection()` to establish the connection. moonlight-qt:1584-1593 

Wiki pages you might want to explore:
- [PC Discovery View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.1)
### Citations
**File:** app/streaming/session.cpp (L692-696)
```cpp
    RAND_bytes(reinterpret_cast<unsigned char*>(m_StreamConfig.remoteInputAesKey),
               sizeof(m_StreamConfig.remoteInputAesKey));

    // Only the first 4 bytes are populated in the RI key IV
    RAND_bytes(reinterpret_cast<unsigned char*>(m_StreamConfig.remoteInputAesIv), 4);
```
**File:** app/streaming/session.cpp (L1584-1593)
```cpp
    try {
        NvHTTP http(m_Computer);
        http.startApp(m_Computer->currentGameId != 0 ? "resume" : "launch",
                      m_Computer->isNvidiaServerSoftware,
                      m_App.id, &m_StreamConfig,
                      enableGameOptimizations,
                      m_Preferences->playAudioOnHost,
                      m_InputHandler->getAttachedGamepadMask(),
                      !m_Preferences->multiController,
                      rtspSessionUrl);
```
**File:** app/backend/nvhttp.cpp (L200-218)
```cpp
    int riKeyId;

    memcpy(&riKeyId, streamConfig->remoteInputAesIv, sizeof(riKeyId));
    riKeyId = qFromBigEndian(riKeyId);

    QString response =
            openConnectionToString(m_BaseUrlHttps,
                                   verb,
                                   "appid="+QString::number(appId)+
                                   "&mode="+QString::number(streamConfig->width)+"x"+
                                   QString::number(streamConfig->height)+"x"+
                                   // Using an FPS value over 60 causes SOPS to default to 720p60,
                                   // so force it to 0 to ensure the correct resolution is set. We
                                   // used to use 60 here but that locked the frame rate to 60 FPS
                                   // on GFE 3.20.3. We don't need this hack for Sunshine.
                                   QString::number((streamConfig->fps > 60 && isGfe) ? 0 : streamConfig->fps)+
                                   "&additionalStates=1&sops="+QString::number(sops ? 1 : 0)+
                                   "&rikey="+QByteArray(streamConfig->remoteInputAesKey, sizeof(streamConfig->remoteInputAesKey)).toHex()+
                                   "&rikeyid="+QString::number(riKeyId)+
```
**File:** app/main.cpp (L108-110)
```cpp
    // Strip session encryption keys and IVs from the logs
    message.replace(k_RikeyRegex, "&rikey=REDACTED");
    message.replace(k_RikeyIdRegex, "&rikeyid=REDACTED");
```
**File:** app/deploy/linux/com.moonlight_stream.Moonlight.appdata.xml (L88-88)
```text
					<li>Per-session keys (rikey and rikeyid values) are now automatically stripped from logs</li>
```
## Q4
<?xml version="1.0" encoding="utf-8"?>
<root status_code="200">
  <hostname>Html5syt</hostname>
  <appversion>7.1.431.-1</appversion>
<GfeVersion>3.23.0.74</GfeVersion>
  <uniqueid>F98186B1-DE02-2328-279E-0A461FBCEC47</uniqueid>
  <HttpsPort>47984</HttpsPort>
  <ExternalPort>47989</ExternalPort>
<MaxLumaPixelsHEVC>1869449984</MaxLumaPixelsHEVC>
  <mac>00:00:00:00:00:00</mac>
  <LocalIP>127.0.0.1</LocalIP>
  <ServerCodecModeSupport>257</ServerCodecModeSupport>
<PairStatus>0</PairStatus>
  <currentgame>1191261554</currentgame>
  <state>SUNSHINE_SERVER_BUSY</state>
</root>
This is a response from a serverinfo, please tell me which parameters are used to establish the connection in it?
### Answer
You're asking which parameters from the `/serverinfo` XML response are used when establishing a streaming connection in Moonlight.

## Answer

From the `/serverinfo` response you provided, the following parameters are used to establish the streaming connection:

### Parameters Used in Connection Establishment

**`ServerCodecModeSupport` (value: 257)** - This is stored in the `NvComputer` object and later passed to `LiStartConnection()` via the `SERVER_INFORMATION` structure. moonlight-qt:1608-1608  It indicates which video codecs and formats the host supports, and is used to negotiate the video format during connection setup. moonlight-qt:1608-1608 

**`appversion` (value: 7.1.431.-1)** - This is stored as `m_Computer->appVersion` and passed to `LiStartConnection()` as `hostInfo.serverInfoAppVersion`. moonlight-qt:1603-1607  The connection library uses this to determine host capabilities and compatibility. moonlight-qt:1603-1607 

**`GfeVersion` (value: 3.23.0.74)** - This is stored as `m_Computer->gfeVersion` and passed to `LiStartConnection()` as `hostInfo.serverInfoGfeVersion`. moonlight-qt:1611-1617  It's used to determine if the host is running GFE or Sunshine and adjust behavior accordingly. moonlight-qt:1560-1580 

**`LocalIP` (value: 127.0.0.1)** - The host's address is used to construct the base URLs for HTTP/HTTPS communication and is passed to `LiStartConnection()` as `hostInfo.address`. moonlight-qt:1602-1606 

**`HttpsPort` (value: 47984)** - Used to construct the HTTPS base URL for secure communication with the host, including the `/launch` endpoint call. moonlight-qt:173-177 

### Parameters NOT Directly Used in Connection

The following parameters are informational but not directly passed to the connection function:

- `hostname`, `uniqueid`, `ExternalPort`, `MaxLumaPixelsHEVC`, `mac` - These are stored in the `NvComputer` object for display and management purposes but aren't passed to `LiStartConnection()`.<cite />
- `PairStatus` - Used to determine if pairing is needed before streaming, but not used during connection establishment.<cite />
- `currentgame` and `state` - Used to determine if the host is already streaming, which affects whether to call `/launch` or `/resume`. moonlight-qt:1586-1586 

## Notes

The `state` value "SUNSHINE_SERVER_BUSY" indicates the host is currently streaming (as confirmed by the non-zero `currentgame` value). moonlight-qt:112-116  In this case, Moonlight would call `/resume` instead of `/launch` if you're trying to connect to the same game. moonlight-qt:1586-1586  The `ServerCodecModeSupport` value of 257 indicates support for H.264 (bit 0) and H.265/HEVC (bit 8).<cite />

Wiki pages you might want to explore:
- [PC Discovery View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.1)
### Citations
**File:** app/streaming/session.cpp (L1560-1580)
```cpp
    if (m_Computer->isNvidiaServerSoftware) {
        // GFE will set all settings to 720p60 if it doesn't recognize
        // the chosen resolution. Avoid that by disabling SOPS when it
        // is not streaming a supported resolution.
        enableGameOptimizations = false;
        for (const NvDisplayMode &mode : m_Computer->displayModes) {
            if (mode.width == m_StreamConfig.width &&
                    mode.height == m_StreamConfig.height) {
                SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION,
                            "Found host supported resolution: %dx%d",
                            mode.width, mode.height);
                enableGameOptimizations = m_Preferences->gameOptimizations;
                break;
            }
        }
    }
    else {
        // Always send SOPS to Sunshine because we may repurpose the
        // option to control whether the display mode is adjusted
        enableGameOptimizations = m_Preferences->gameOptimizations;
    }
```
**File:** app/streaming/session.cpp (L1586-1586)
```cpp
        http.startApp(m_Computer->currentGameId != 0 ? "resume" : "launch",
```
**File:** app/streaming/session.cpp (L1602-1607)
```cpp
    QByteArray hostnameStr = m_Computer->activeAddress.address().toLatin1();
    QByteArray siAppVersion = m_Computer->appVersion.toLatin1();

    SERVER_INFORMATION hostInfo;
    hostInfo.address = hostnameStr.data();
    hostInfo.serverInfoAppVersion = siAppVersion.data();
```
**File:** app/streaming/session.cpp (L1608-1608)
```cpp
    hostInfo.serverCodecModeSupport = m_Computer->serverCodecModeSupport;
```
**File:** app/streaming/session.cpp (L1611-1617)
```cpp
    QByteArray siGfeVersion;
    if (!m_Computer->gfeVersion.isEmpty()) {
        siGfeVersion = m_Computer->gfeVersion.toLatin1();
    }
    if (!siGfeVersion.isEmpty()) {
        hostInfo.serverInfoGfeVersion = siGfeVersion.data();
    }
```
**File:** app/backend/nvhttp.cpp (L112-116)
```cpp
    QString serverState = getXmlString(serverInfo, "state");
    if (serverState != nullptr && serverState.endsWith("_SERVER_BUSY"))
    {
        return getXmlString(serverInfo, "currentgame").toInt();
    }
```
**File:** app/backend/nvhttp.cpp (L173-177)
```cpp
        uint16_t httpsPort = getXmlString(serverInfo, "HttpsPort").toUShort();
        if (httpsPort == 0) {
            httpsPort = DEFAULT_HTTPS_PORT;
        }
        setHttpsPort(httpsPort);
```
## Q5
When I call the /launch interface, the server requires me to provide a client certificate. How can I obtain this certificate?
### Answer
Moonlight obtains and provides client certificates through a multi-step process involving certificate generation, pairing, and SSL configuration:

## Client Certificate Generation

When Moonlight first launches, the `IdentityManager` class automatically generates a self-signed 2048-bit RSA certificate and private key pair if none exist. moonlight-qt:29-110 

These credentials are stored persistently in QSettings and cached in memory for reuse. moonlight-qt:112-139 

## Attaching Certificates to Requests

For every HTTPS request (including `/launch`), Moonlight attaches the client certificate through the `IdentityManager::getSslConfig()` method, which returns a `QSslConfiguration` containing both the client certificate and private key. moonlight-qt:184-191 

This SSL configuration is applied to all network requests in the `openConnection` method via `request.setSslConfiguration()`. moonlight-qt:486-489 

## The `/launch` Interface Specifically

When the `startApp` method is called to launch a game, it makes an HTTPS request to the `/launch` endpoint using the base HTTPS URL. moonlight-qt:205-228 

This request goes through `openConnection`, which automatically includes the client certificate for mutual TLS authentication with the host server.

## Pairing Process for Mutual Trust

Before the client certificate can be used for authentication, a pairing process must occur. During pairing, the client sends its certificate to the server and receives the server's certificate in return. moonlight-qt:217-248 

The server certificate is then pinned and stored in the `NvComputer` object for future SSL validation. moonlight-qt:419-439 

## Certificate Validation

If there's an SSL handshake failure or certificate mismatch (error 401), Moonlight falls back to HTTP and can re-initiate pairing to obtain updated certificates. moonlight-qt:143-160 

## Notes

- The client certificate uses a common name of "NVIDIA GameStream Client" moonlight-qt:70-74 
- The certificate has a 20-year validity period moonlight-qt:51-66 
- The `/launch` endpoint uses a 120-second timeout compared to the standard 5-second timeout for other requests moonlight-qt:15-19 
- Certificate pinning prevents man-in-the-middle attacks by ensuring SSL errors are only ignored if they match the previously paired server certificate moonlight-qt:429-434
### Citations
**File:** app/backend/identitymanager.cpp (L29-110)
```cpp
void IdentityManager::createCredentials(QSettings& settings)
{
    X509* cert = X509_new();
    THROW_BAD_ALLOC_IF_NULL(cert);

    EVP_PKEY_CTX* ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_RSA, NULL);
    THROW_BAD_ALLOC_IF_NULL(ctx);

    EVP_PKEY_keygen_init(ctx);
    EVP_PKEY_CTX_set_rsa_keygen_bits(ctx, 2048);

    // pk must be initialized on input
    EVP_PKEY* pk = NULL;
    EVP_PKEY_keygen(ctx, &pk);

    EVP_PKEY_CTX_free(ctx);
    THROW_BAD_ALLOC_IF_NULL(pk);

    X509_set_version(cert, 2);
    ASN1_INTEGER_set(X509_get_serialNumber(cert), 0);
#if OPENSSL_VERSION_NUMBER < 0x10100000L
    X509_gmtime_adj(X509_get_notBefore(cert), 0);
    X509_gmtime_adj(X509_get_notAfter(cert), 60 * 60 * 24 * 365 * 20); // 20 yrs
#else
    ASN1_TIME* before = ASN1_STRING_dup(X509_get0_notBefore(cert));
    THROW_BAD_ALLOC_IF_NULL(before);
    ASN1_TIME* after = ASN1_STRING_dup(X509_get0_notAfter(cert));
    THROW_BAD_ALLOC_IF_NULL(after);

    X509_gmtime_adj(before, 0);
    X509_gmtime_adj(after, 60 * 60 * 24 * 365 * 20); // 20 yrs

    X509_set1_notBefore(cert, before);
    X509_set1_notAfter(cert, after);

    ASN1_STRING_free(before);
    ASN1_STRING_free(after);
#endif

    X509_set_pubkey(cert, pk);

    X509_NAME* name = X509_get_subject_name(cert);
    X509_NAME_add_entry_by_txt(name, "CN", MBSTRING_ASC,
                               reinterpret_cast<unsigned char *>(const_cast<char*>("NVIDIA GameStream Client")),
                               -1, -1, 0);
    X509_set_issuer_name(cert, name);

    X509_sign(cert, pk, EVP_sha256());

    BIO* biokey = BIO_new(BIO_s_mem());
    THROW_BAD_ALLOC_IF_NULL(biokey);
    PEM_write_bio_PrivateKey(biokey, pk, NULL, NULL, 0, NULL, NULL);

    BIO* biocert = BIO_new(BIO_s_mem());
    THROW_BAD_ALLOC_IF_NULL(biocert);
    PEM_write_bio_X509(biocert, cert);

    BUF_MEM* mem;
    BIO_get_mem_ptr(biokey, &mem);
    m_CachedPrivateKey = QByteArray(mem->data, (int)mem->length);

    BIO_get_mem_ptr(biocert, &mem);
    m_CachedPemCert = QByteArray(mem->data, (int)mem->length);

    X509_free(cert);
    EVP_PKEY_free(pk);
    BIO_free(biokey);
    BIO_free(biocert);

    // Check that the new keypair is valid before persisting it
    if (getSslCertificate().isNull()) {
        qFatal("Newly generated certificate is unreadable");
    }
    if (getSslKey().isNull()) {
        qFatal("Newly generated private key is unreadable");
    }

    settings.setValue(SER_CERT, m_CachedPemCert);
    settings.setValue(SER_KEY, m_CachedPrivateKey);

    qInfo() << "Wrote new identity credentials to settings";
}
```
**File:** app/backend/identitymanager.cpp (L112-139)
```cpp
IdentityManager::IdentityManager()
{
    QSettings settings;

    m_CachedPemCert = settings.value(SER_CERT).toByteArray();
    m_CachedPrivateKey = settings.value(SER_KEY).toByteArray();

    if (m_CachedPemCert.isEmpty() || m_CachedPrivateKey.isEmpty()) {
        qInfo() << "No existing credentials found";
        createCredentials(settings);
    }
    else if (getSslCertificate().isNull()) {
        qWarning() << "Certificate is unreadable";
        createCredentials(settings);
    }
    else if (getSslKey().isNull()) {
        qWarning() << "Private key is unreadable";
        createCredentials(settings);
    }

    // We should have valid credentials now. If not, we're screwed
    if (getSslCertificate().isNull()) {
        qFatal("Certificate is unreadable");
    }
    if (getSslKey().isNull()) {
        qFatal("Private key is unreadable");
    }
}
```
**File:** app/backend/identitymanager.cpp (L184-191)
```cpp
QSslConfiguration
IdentityManager::getSslConfig()
{
    QSslConfiguration sslConfig(QSslConfiguration::defaultConfiguration());
    sslConfig.setLocalCertificate(getSslCertificate());
    sslConfig.setPrivateKey(getSslKey());
    return sslConfig;
}
```
**File:** app/backend/nvhttp.cpp (L15-19)
```cpp
#define FAST_FAIL_TIMEOUT_MS 2000
#define REQUEST_TIMEOUT_MS 5000
#define LAUNCH_TIMEOUT_MS 120000
#define RESUME_TIMEOUT_MS 30000
#define QUIT_TIMEOUT_MS 30000
```
**File:** app/backend/nvhttp.cpp (L143-160)
```cpp
        catch (const GfeHttpResponseException& e)
        {
            if (e.getStatusCode() == 401)
            {
                // Certificate validation error, fallback to HTTP
                serverInfo = openConnectionToString(m_BaseUrlHttp,
                                                    "serverinfo",
                                                    nullptr,
                                                    fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                                    logLevel);
                verifyResponseStatus(serverInfo);
            }
            else
            {
                // Rethrow real errors
                throw e;
            }
        }
```
**File:** app/backend/nvhttp.cpp (L205-228)
```cpp
    QString response =
            openConnectionToString(m_BaseUrlHttps,
                                   verb,
                                   "appid="+QString::number(appId)+
                                   "&mode="+QString::number(streamConfig->width)+"x"+
                                   QString::number(streamConfig->height)+"x"+
                                   // Using an FPS value over 60 causes SOPS to default to 720p60,
                                   // so force it to 0 to ensure the correct resolution is set. We
                                   // used to use 60 here but that locked the frame rate to 60 FPS
                                   // on GFE 3.20.3. We don't need this hack for Sunshine.
                                   QString::number((streamConfig->fps > 60 && isGfe) ? 0 : streamConfig->fps)+
                                   "&additionalStates=1&sops="+QString::number(sops ? 1 : 0)+
                                   "&rikey="+QByteArray(streamConfig->remoteInputAesKey, sizeof(streamConfig->remoteInputAesKey)).toHex()+
                                   "&rikeyid="+QString::number(riKeyId)+
                                   ((streamConfig->supportedVideoFormats & VIDEO_FORMAT_MASK_10BIT) ?
                                       "&hdrMode=1&clientHdrCapVersion=0&clientHdrCapSupportedFlagsInUint32=0&clientHdrCapMetaDataId=NV_STATIC_METADATA_TYPE_1&clientHdrCapDisplayData=0x0x0x0x0x0x0x0x0x0x0" :
                                        "")+
                                   "&localAudioPlayMode="+QString::number(localAudio ? 1 : 0)+
                                   "&surroundAudioInfo="+QString::number(SURROUNDAUDIOINFO_FROM_AUDIO_CONFIGURATION(streamConfig->audioConfiguration))+
                                   "&remoteControllersBitmap="+QString::number(gamepadMask)+
                                   "&gcmap="+QString::number(gamepadMask)+
                                   "&gcpersist="+QString::number(persistGameControllersOnDisconnect ? 1 : 0)+
                                   LiGetLaunchUrlQueryParameters(),
                                   LAUNCH_TIMEOUT_MS);
```
**File:** app/backend/nvhttp.cpp (L419-439)
```cpp
void NvHTTP::handleSslErrors(QNetworkReply* reply, const QList<QSslError>& errors)
{
    bool ignoreErrors = true;

    if (m_ServerCert.isNull()) {
        // We should never make an HTTPS request without a cert
        Q_ASSERT(!m_ServerCert.isNull());
        return;
    }

    for (const QSslError& error : errors) {
        if (m_ServerCert != error.certificate()) {
            ignoreErrors = false;
            break;
        }
    }

    if (ignoreErrors) {
        reply->ignoreSslErrors(errors);
    }
}
```
**File:** app/backend/nvhttp.cpp (L486-489)
```cpp
    QNetworkRequest request(url);

    // Add our client certificate
    request.setSslConfiguration(IdentityManager::get()->getSslConfig());
```
**File:** app/backend/nvpairingmanager.cpp (L217-248)
```cpp
    QString getCert = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&phrase=getservercert&salt=" +
                                                    salt.toHex() + "&clientcert=" + IdentityManager::get()->getCertificate().toHex(),
                                                    0);
    NvHTTP::verifyResponseStatus(getCert);
    if (NvHTTP::getXmlString(getCert, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #1";
        return PairState::FAILED;
    }

    QByteArray serverCertStr = NvHTTP::getXmlStringFromHex(getCert, "plaincert");
    if (serverCertStr == nullptr)
    {
        qCritical() << "Server likely already pairing";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::ALREADY_IN_PROGRESS;
    }

    QSslCertificate unverifiedServerCert = QSslCertificate(serverCertStr);
    if (unverifiedServerCert.isNull()) {
        Q_ASSERT(!unverifiedServerCert.isNull());

        qCritical() << "Failed to parse plaincert";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    // Pin this cert for TLS until pairing is complete. If successful, we will propagate
    // the cert into the NvComputer object and persist it.
    m_Http.setServerCert(unverifiedServerCert);
```
## Q6
How to pair up computer?
### Answer
The pairing process in Moonlight uses a 5-phase handshake protocol to securely exchange certificates between the client and server. Here's how it works:

## Client Certificate Generation and Storage

The client certificate is a self-signed X.509 certificate that is generated when Moonlight first runs. It uses a 2048-bit RSA key pair with SHA-256 signature and has a 20-year validity period. moonlight-qt:29-110 

The certificate and private key are stored in QSettings and cached in memory for subsequent use. moonlight-qt:112-139 

## The 5-Phase Pairing Process

The pairing process is implemented in the `NvPairingManager::pair()` method: moonlight-qt:191-354 

### Phase 1: Certificate Exchange

The client sends its certificate to the server as a hex-encoded string in the `clientcert` parameter of an HTTP request. At the same time, it receives the server's certificate in the response: moonlight-qt:217-227 

The server returns its certificate in the `plaincert` field of the XML response: moonlight-qt:229-244 

### Phase 2-5: Challenge-Response Authentication

Once the server certificate is received, it is immediately pinned to the HTTP client for all subsequent HTTPS requests: moonlight-qt:246-248 

The remaining phases involve encrypted challenge-response exchanges and signature verification to authenticate both parties and validate the PIN.

## Certificate Pinning

The `setServerCert()` method stores the server certificate for use in HTTPS connections: moonlight-qt:43-46 

During HTTPS connections, the `handleSslErrors()` method verifies that the server certificate matches the pinned certificate, preventing man-in-the-middle attacks: moonlight-qt:419-439 

## Persisting the Server Certificate

After successful pairing, the server certificate is stored in the `NvComputer` object: moonlight-qt:113-113 

The certificate is then persisted to settings by calling `saveHost()`: moonlight-qt:599-603 

## Notes

The pairing process uses AES-128-ECB encryption for challenge exchanges, with the encryption key derived from a salted PIN hash (SHA-256 for Gen 7+ servers, SHA-1 for older versions). The client certificate is sent as plain hex-encoded PEM data in Phase 1, while the server certificate is also returned as hex-encoded PEM. This certificate exchange happens over HTTP initially, but all subsequent pairing phases use HTTPS with the newly pinned certificate to ensure secure communication.
### Citations
**File:** app/backend/identitymanager.cpp (L29-110)
```cpp
void IdentityManager::createCredentials(QSettings& settings)
{
    X509* cert = X509_new();
    THROW_BAD_ALLOC_IF_NULL(cert);

    EVP_PKEY_CTX* ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_RSA, NULL);
    THROW_BAD_ALLOC_IF_NULL(ctx);

    EVP_PKEY_keygen_init(ctx);
    EVP_PKEY_CTX_set_rsa_keygen_bits(ctx, 2048);

    // pk must be initialized on input
    EVP_PKEY* pk = NULL;
    EVP_PKEY_keygen(ctx, &pk);

    EVP_PKEY_CTX_free(ctx);
    THROW_BAD_ALLOC_IF_NULL(pk);

    X509_set_version(cert, 2);
    ASN1_INTEGER_set(X509_get_serialNumber(cert), 0);
#if OPENSSL_VERSION_NUMBER < 0x10100000L
    X509_gmtime_adj(X509_get_notBefore(cert), 0);
    X509_gmtime_adj(X509_get_notAfter(cert), 60 * 60 * 24 * 365 * 20); // 20 yrs
#else
    ASN1_TIME* before = ASN1_STRING_dup(X509_get0_notBefore(cert));
    THROW_BAD_ALLOC_IF_NULL(before);
    ASN1_TIME* after = ASN1_STRING_dup(X509_get0_notAfter(cert));
    THROW_BAD_ALLOC_IF_NULL(after);

    X509_gmtime_adj(before, 0);
    X509_gmtime_adj(after, 60 * 60 * 24 * 365 * 20); // 20 yrs

    X509_set1_notBefore(cert, before);
    X509_set1_notAfter(cert, after);

    ASN1_STRING_free(before);
    ASN1_STRING_free(after);
#endif

    X509_set_pubkey(cert, pk);

    X509_NAME* name = X509_get_subject_name(cert);
    X509_NAME_add_entry_by_txt(name, "CN", MBSTRING_ASC,
                               reinterpret_cast<unsigned char *>(const_cast<char*>("NVIDIA GameStream Client")),
                               -1, -1, 0);
    X509_set_issuer_name(cert, name);

    X509_sign(cert, pk, EVP_sha256());

    BIO* biokey = BIO_new(BIO_s_mem());
    THROW_BAD_ALLOC_IF_NULL(biokey);
    PEM_write_bio_PrivateKey(biokey, pk, NULL, NULL, 0, NULL, NULL);

    BIO* biocert = BIO_new(BIO_s_mem());
    THROW_BAD_ALLOC_IF_NULL(biocert);
    PEM_write_bio_X509(biocert, cert);

    BUF_MEM* mem;
    BIO_get_mem_ptr(biokey, &mem);
    m_CachedPrivateKey = QByteArray(mem->data, (int)mem->length);

    BIO_get_mem_ptr(biocert, &mem);
    m_CachedPemCert = QByteArray(mem->data, (int)mem->length);

    X509_free(cert);
    EVP_PKEY_free(pk);
    BIO_free(biokey);
    BIO_free(biocert);

    // Check that the new keypair is valid before persisting it
    if (getSslCertificate().isNull()) {
        qFatal("Newly generated certificate is unreadable");
    }
    if (getSslKey().isNull()) {
        qFatal("Newly generated private key is unreadable");
    }

    settings.setValue(SER_CERT, m_CachedPemCert);
    settings.setValue(SER_KEY, m_CachedPrivateKey);

    qInfo() << "Wrote new identity credentials to settings";
}
```
**File:** app/backend/identitymanager.cpp (L112-139)
```cpp
IdentityManager::IdentityManager()
{
    QSettings settings;

    m_CachedPemCert = settings.value(SER_CERT).toByteArray();
    m_CachedPrivateKey = settings.value(SER_KEY).toByteArray();

    if (m_CachedPemCert.isEmpty() || m_CachedPrivateKey.isEmpty()) {
        qInfo() << "No existing credentials found";
        createCredentials(settings);
    }
    else if (getSslCertificate().isNull()) {
        qWarning() << "Certificate is unreadable";
        createCredentials(settings);
    }
    else if (getSslKey().isNull()) {
        qWarning() << "Private key is unreadable";
        createCredentials(settings);
    }

    // We should have valid credentials now. If not, we're screwed
    if (getSslCertificate().isNull()) {
        qFatal("Certificate is unreadable");
    }
    if (getSslKey().isNull()) {
        qFatal("Private key is unreadable");
    }
}
```
**File:** app/backend/nvpairingmanager.cpp (L191-354)
```cpp
NvPairingManager::pair(QString appVersion, QString pin, QSslCertificate& serverCert)
{
    int serverMajorVersion = NvHTTP::parseQuad(appVersion).at(0);
    qInfo() << "Pairing with server generation:" << serverMajorVersion;

    QCryptographicHash::Algorithm hashAlgo;
    int hashLength;
    if (serverMajorVersion >= 7)
    {
        // Gen 7+ uses SHA-256 hashing
        hashAlgo = QCryptographicHash::Sha256;
        hashLength = 32;
    }
    else
    {
        // Prior to Gen 7 uses SHA-1 hashing
        hashAlgo = QCryptographicHash::Sha1;
        hashLength = 20;
    }

    QByteArray salt = generateRandomBytes(16);
    QByteArray saltedPin = saltPin(salt, pin);

    QByteArray aesKey = QCryptographicHash::hash(saltedPin, hashAlgo).constData();
    aesKey.truncate(16);

    QString getCert = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&phrase=getservercert&salt=" +
                                                    salt.toHex() + "&clientcert=" + IdentityManager::get()->getCertificate().toHex(),
                                                    0);
    NvHTTP::verifyResponseStatus(getCert);
    if (NvHTTP::getXmlString(getCert, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #1";
        return PairState::FAILED;
    }

    QByteArray serverCertStr = NvHTTP::getXmlStringFromHex(getCert, "plaincert");
    if (serverCertStr == nullptr)
    {
        qCritical() << "Server likely already pairing";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::ALREADY_IN_PROGRESS;
    }

    QSslCertificate unverifiedServerCert = QSslCertificate(serverCertStr);
    if (unverifiedServerCert.isNull()) {
        Q_ASSERT(!unverifiedServerCert.isNull());

        qCritical() << "Failed to parse plaincert";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    // Pin this cert for TLS until pairing is complete. If successful, we will propagate
    // the cert into the NvComputer object and persist it.
    m_Http.setServerCert(unverifiedServerCert);

    QByteArray randomChallenge = generateRandomBytes(16);
    QByteArray encryptedChallenge = encrypt(randomChallenge, aesKey);
    QString challengeXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                         "pair",
                                                         "devicename=roth&updateState=1&clientchallenge=" +
                                                         encryptedChallenge.toHex(),
                                                         REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(challengeXml);
    if (NvHTTP::getXmlString(challengeXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #2";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray challengeResponseData = decrypt(m_Http.getXmlStringFromHex(challengeXml, "challengeresponse"), aesKey);
    QByteArray clientSecretData = generateRandomBytes(16);
    QByteArray challengeResponse;
    QByteArray serverResponse(challengeResponseData.data(), hashLength);

#if (OPENSSL_VERSION_NUMBER < 0x10002000L)
    ASN1_BIT_STRING *asnSignature = m_Cert->signature;
#elif (OPENSSL_VERSION_NUMBER < 0x10100000L)
    ASN1_BIT_STRING *asnSignature;
    X509_get0_signature(&asnSignature, NULL, m_Cert);
#else
    const ASN1_BIT_STRING *asnSignature;
    X509_get0_signature(&asnSignature, NULL, m_Cert);
#endif

    challengeResponse.append(challengeResponseData.data() + hashLength, 16);
    challengeResponse.append(reinterpret_cast<char*>(asnSignature->data), asnSignature->length);
    challengeResponse.append(clientSecretData);

    QByteArray paddedHash = QCryptographicHash::hash(challengeResponse, hashAlgo);
    paddedHash.resize(32);
    QByteArray encryptedChallengeResponseHash = encrypt(paddedHash, aesKey);
    QString respXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&serverchallengeresp=" +
                                                    encryptedChallengeResponseHash.toHex(),
                                                    REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(respXml);
    if (NvHTTP::getXmlString(respXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #3";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray pairingSecret = NvHTTP::getXmlStringFromHex(respXml, "pairingsecret");
    QByteArray serverSecret = pairingSecret.left(16);
    QByteArray serverSignature = pairingSecret.mid(16);

    if (!verifySignature(serverSecret,
                         serverSignature,
                         serverCertStr))
    {
        qCritical() << "MITM detected";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray expectedResponseData;
    expectedResponseData.append(randomChallenge);
    expectedResponseData.append(getSignatureFromPemCert(serverCertStr));
    expectedResponseData.append(serverSecret);
    if (QCryptographicHash::hash(expectedResponseData, hashAlgo) != serverResponse)
    {
        qCritical() << "Incorrect PIN";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::PIN_WRONG;
    }

    QByteArray clientPairingSecret;
    clientPairingSecret.append(clientSecretData);
    clientPairingSecret.append(signMessage(clientSecretData));

    QString secretRespXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                          "pair",
                                                          "devicename=roth&updateState=1&clientpairingsecret=" +
                                                          clientPairingSecret.toHex(),
                                                          REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(secretRespXml);
    if (NvHTTP::getXmlString(secretRespXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #4";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QString pairChallengeXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttps,
                                                             "pair",
                                                             "devicename=roth&updateState=1&phrase=pairchallenge",
                                                             REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(pairChallengeXml);
    if (NvHTTP::getXmlString(pairChallengeXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #5";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    serverCert = std::move(unverifiedServerCert);
    return PairState::PAIRED;
```
**File:** app/backend/nvhttp.cpp (L43-46)
```cpp
void NvHTTP::setServerCert(QSslCertificate serverCert)
{
    m_ServerCert = serverCert;
}
```
**File:** app/backend/nvhttp.cpp (L419-439)
```cpp
void NvHTTP::handleSslErrors(QNetworkReply* reply, const QList<QSslError>& errors)
{
    bool ignoreErrors = true;

    if (m_ServerCert.isNull()) {
        // We should never make an HTTPS request without a cert
        Q_ASSERT(!m_ServerCert.isNull());
        return;
    }

    for (const QSslError& error : errors) {
        if (m_ServerCert != error.certificate()) {
            ignoreErrors = false;
            break;
        }
    }

    if (ignoreErrors) {
        reply->ignoreSslErrors(errors);
    }
}
```
**File:** app/backend/nvcomputer.h (L113-113)
```text
    QSslCertificate serverCert;
```
**File:** app/backend/computermanager.cpp (L599-603)
```cpp
           case NvPairingManager::PairState::PAIRED:
               // Persist the newly pinned server certificate for this host
               m_ComputerManager->saveHost(m_Computer);

               emit pairingCompleted(m_Computer, nullptr);
```
## Q7
When the client has launched/started the game and begun streaming before disconnecting, how does the client recover the connection?
### Answer
You're asking about how Moonlight handles connection recovery when a streaming session disconnects after it has already started.

## Answer

When a streaming session disconnects, Moonlight determines whether to call `/launch` or `/resume` based on the `currentgame` value from the host's `/serverinfo` response. moonlight-qt:1586-1586 

### Resume vs Launch Decision

In `Session::startConnectionAsync()`, the code checks if `m_Computer->currentgame` is non-zero (indicating a game is already running on the host): moonlight-qt:1556-1557 

If the game is already running, it calls `NvHTTP::startApp()` with the `"resume"` parameter instead of `"launch"`: moonlight-qt:1586-1593 

```cpp
http.startApp(m_Computer->currentgame != 0 ? "resume" : "launch",
              m_Computer->isNvidiaServerSoftware,
              m_App.id, &m_StreamConfig,
              enableGameOptimizations,
              m_Preferences->playAudioOnHost,
              m_InputHandler->getAttachedGamepadMask(),
              !m_Preferences->multiController,
              rtspSessionUrl);
```

### How Resume Works

The `/resume` endpoint tells the host to reconnect to an existing game session rather than starting a new one.<cite /> This preserves the game state and allows the client to rejoin the same streaming session.<cite />

The same connection establishment process follows after calling `/resume` - the RTSP session URL is obtained from the response and passed to `LiStartConnection()` to establish the streaming connection. moonlight-qt:1678-1680 

### State Detection

The host's state is tracked through periodic `/serverinfo` polling, which updates the `currentgame` field in the `NvComputer` object.<cite /> When the state shows `SUNSHINE_SERVER_BUSY` (as in your earlier example) with a non-zero `currentgame` value, Moonlight knows a game is already running and will use resume instead of launch.<cite />

## Notes

The resume functionality allows seamless reconnection to an existing game session without restarting the game on the host. This is particularly useful for temporary network interruptions or when the client application crashes but the host game continues running. The same certificate authentication and connection establishment process is used for both launch and resume operations.

Wiki pages you might want to explore:
- [User Interface System (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2)
- [Streaming Core (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#4)
### Citations
**File:** app/streaming/session.cpp (L1556-1557)
```cpp
    Q_ASSERT(m_Computer->currentGameId == 0 ||
             m_Computer->currentGameId == m_App.id);
```
**File:** app/streaming/session.cpp (L1586-1593)
```cpp
        http.startApp(m_Computer->currentGameId != 0 ? "resume" : "launch",
                      m_Computer->isNvidiaServerSoftware,
                      m_App.id, &m_StreamConfig,
                      enableGameOptimizations,
                      m_Preferences->playAudioOnHost,
                      m_InputHandler->getAttachedGamepadMask(),
                      !m_Preferences->multiController,
                      rtspSessionUrl);
```
**File:** app/streaming/session.cpp (L1678-1680)
```cpp
    int err = LiStartConnection(&hostInfo, &m_StreamConfig, &k_ConnCallbacks,
                                &m_VideoCallbacks, &m_AudioCallbacks,
                                NULL, 0, NULL, 0);
```
## Q8
How does the client terminate the connection?
### Answer
You're asking about how Moonlight terminates a streaming connection when the user wants to disconnect.

## Answer

Moonlight provides multiple ways to terminate a streaming connection:

### User-Initiated Disconnection

Users can disconnect from an active streaming session using keyboard shortcuts or gamepad button combinations. The UI displays a tip showing these options: **Ctrl+Alt+Shift+Q** for keyboard or **Start+Select+L1+R1** for gamepad. moonlight-qt:167-168 

### Connection Termination Flow

When a connection terminates, the `Session::clConnectionTerminated()` callback is invoked with an error code. moonlight-qt:98-155  This callback:

1. **Performs port testing** to diagnose connectivity issues if the termination was unexpected moonlight-qt:100-101 

2. **Determines if termination was graceful** - If the error code is `ML_ERROR_GRACEFUL_TERMINATION`, no error dialog is shown moonlight-qt:105-106 

3. **Displays error messages** for unexpected terminations (network issues, video encoding errors, etc.) moonlight-qt:108-144 

4. **Pushes a quit event** to the SDL event loop to exit the streaming session moonlight-qt:150-154 

### UI Cleanup After Termination

After the session ends, the `StreamSegue::sessionFinished()` method handles cleanup: moonlight-qt:73-108 

1. **Re-enables gamepad navigation** for the UI moonlight-qt:79-80 

2. **Pops the stream view** from the navigation stack to return to the previous screen moonlight-qt:93-94 

3. **Shows the main window** again moonlight-qt:96-97 

4. **Displays any error dialogs** if the termination was unexpected moonlight-qt:103-106 

The session object is then garbage collected to free resources. moonlight-qt:110-116 

### Quitting Running Apps

Moonlight can also terminate a running game on the host without streaming it. The `ComputerManager::quitRunningApp()` method creates a `PendingQuitTask` that sends a quit request to the host server. moonlight-qt:675-682  This is used when users want to stop a game remotely without connecting to it.

## Notes

The termination process distinguishes between graceful disconnections (user-initiated) and unexpected terminations (network errors, encoding failures). For unexpected terminations, Moonlight performs network diagnostics and displays helpful error messages to guide troubleshooting. The same cleanup process applies whether the user disconnects manually or the connection fails unexpectedly.

Wiki pages you might want to explore:
- [User Interface System (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2)
- [PC Discovery View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.1)
### Citations
**File:** app/gui/StreamSegue.qml (L73-108)
```text
    function sessionFinished(portTestResult)
    {
        if (portTestResult !== 0 && portTestResult !== -1 && streamSegueErrorDialog.text) {
            streamSegueErrorDialog.text += "\n\n" + qsTr("This PC's Internet connection is blocking Moonlight. Streaming over the Internet may not work while connected to this network.")
        }

        // Re-enable GUI gamepad usage now
        SdlGamepadKeyNavigation.enable()

        if (quitAfter) {
            if (streamSegueErrorDialog.text) {
                // Quit when the error dialog is acknowledged
                streamSegueErrorDialog.quitAfter = quitAfter
                streamSegueErrorDialog.open()
            }
            else {
                // Quit immediately
                Qt.quit()
            }
        } else {
            // Exit this view
            stackView.pop()

            // Show the Qt window again after streaming
            window.visible = true

            // Display any launch errors. We do this after
            // the Qt UI is visible again to prevent losing
            // focus on the dialog which would impact gamepad
            // users.
            if (streamSegueErrorDialog.text) {
                streamSegueErrorDialog.quitAfter = quitAfter
                streamSegueErrorDialog.open()
            }
        }
    }
```
**File:** app/gui/StreamSegue.qml (L110-116)
```text
    function sessionReadyForDeletion()
    {
        // Garbage collect the Session object since it's pretty heavyweight
        // and keeps other libraries (like SDL_TTF) around until it is deleted.
        session = null
        gc()
    }
```
**File:** app/gui/StreamSegue.qml (L167-168)
```text
            hintText.text = qsTr("Tip:") + " " + qsTr("Press %1 to disconnect your session").arg(SdlGamepadKeyNavigation.getConnectedGamepads() > 0 ?
                                                  qsTr("Start+Select+L1+R1") : qsTr("Ctrl+Alt+Shift+Q"))
```
**File:** app/streaming/session.cpp (L98-155)
```cpp
void Session::clConnectionTerminated(int errorCode)
{
    unsigned int portFlags = LiGetPortFlagsFromTerminationErrorCode(errorCode);
    s_ActiveSession->m_PortTestResults = LiTestClientConnectivity(CONN_TEST_SERVER, 443, portFlags);

    // Display the termination dialog if this was not intended
    switch (errorCode) {
    case ML_ERROR_GRACEFUL_TERMINATION:
        break;

    case ML_ERROR_NO_VIDEO_TRAFFIC:
        s_ActiveSession->m_UnexpectedTermination = true;

        char ports[128];
        SDL_assert(portFlags != 0);
        LiStringifyPortFlags(portFlags, ", ", ports, sizeof(ports));
        emit s_ActiveSession->displayLaunchError(tr("No video received from host.") + "\n\n"+
                                                 tr("Check your firewall and port forwarding rules for port(s): %1").arg(ports));
        break;

    case ML_ERROR_NO_VIDEO_FRAME:
        s_ActiveSession->m_UnexpectedTermination = true;
        emit s_ActiveSession->displayLaunchError(tr("Your network connection isn't performing well. Reduce your video bitrate setting or try a faster connection."));
        break;

    case ML_ERROR_PROTECTED_CONTENT:
    case ML_ERROR_UNEXPECTED_EARLY_TERMINATION:
        s_ActiveSession->m_UnexpectedTermination = true;
        emit s_ActiveSession->displayLaunchError(tr("Something went wrong on your host PC when starting the stream.") + "\n\n" +
                                                 tr("Make sure you don't have any DRM-protected content open on your host PC. You can also try restarting your host PC."));
        break;

    case ML_ERROR_FRAME_CONVERSION:
        s_ActiveSession->m_UnexpectedTermination = true;
        emit s_ActiveSession->displayLaunchError(tr("The host PC reported a fatal video encoding error.") + "\n\n" +
                                                 tr("Try disabling HDR mode, changing the streaming resolution, or changing your host PC's display resolution."));
        break;

    default:
        s_ActiveSession->m_UnexpectedTermination = true;

        // We'll assume large errors are hex values
        bool hexError = qAbs(errorCode) > 1000;
        emit s_ActiveSession->displayLaunchError(tr("Connection terminated") + "\n\n" +
                                                 tr("Error code: %1").arg(errorCode, hexError ? 8 : 0, hexError ? 16 : 10, QChar('0')));
        break;
    }

    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION,
                 "Connection terminated: %d",
                 errorCode);

    // Push a quit event to the main loop
    SDL_Event event;
    event.type = SDL_QUIT;
    event.quit.timestamp = SDL_GetTicks();
    SDL_PushEvent(&event);
}
```
**File:** app/backend/computermanager.cpp (L675-682)
```cpp
void ComputerManager::quitRunningApp(NvComputer* computer)
{
    QWriteLocker lock(&computer->lock);
    computer->pendingQuit = true;

    PendingQuitTask* quit = new PendingQuitTask(this, computer);
    QThreadPool::globalInstance()->start(quit);
}
```
## Q9
Please list all the APIs used for the client and server interaction, including their purposes and required parameters, and list the APIs needed for the entire process from adding a computer to selecting one in the app list and starting a connection to ending the connection.
### Answer
Based on my analysis of the Moonlight codebase, here are all the client-server interaction APIs used throughout the entire process:

## 1. **Adding a Computer**

### Server Discovery - `serverinfo` API
**Purpose**: Discover and retrieve information about the host PC, including pairing status, current game, server version, and HTTPS port. moonlight-qt:124-187 

**Required Parameters**:
- `uniqueid`: Common UID for Moonlight clients (fixed: "0123456789ABCDEF")
- `uuid`: Random UUID for the request

**Protocol**: HTTP initially (before pairing), then HTTPS (after pairing)

### Pairing - 5-Phase Cryptographic Handshake

**Purpose**: Establish trust between client and host PC through certificate exchange and PIN verification. moonlight-qt:191-355 

**Phase 1 - Get Server Certificate**:
- Endpoint: `pair`
- Parameters:
  - `devicename=roth`
  - `updateState=1`
  - `phrase=getservercert`
  - `salt`: 16-byte random salt (hex)
  - `clientcert`: Client certificate (hex)

**Phase 2 - Client Challenge**:
- Endpoint: `pair`
- Parameters:
  - `devicename=roth`
  - `updateState=1`
  - `clientchallenge`: Encrypted 16-byte challenge (hex)

**Phase 3 - Server Challenge Response**:
- Endpoint: `pair`
- Parameters:
  - `devicename=roth`
  - `updateState=1`
  - `serverchallengeresp`: Encrypted challenge response hash (hex)

**Phase 4 - Client Pairing Secret**:
- Endpoint: `pair`
- Parameters:
  - `devicename=roth`
  - `updateState=1`
  - `clientpairingsecret`: Client secret + signature (hex)

**Phase 5 - Final Challenge (HTTPS)**:
- Endpoint: `pair`
- Parameters:
  - `devicename=roth`
  - `updateState=1`
  - `phrase=pairchallenge`

**Protocol**: HTTP for phases 1-4, HTTPS for phase 5

## 2. **Selecting an App**

### App List - `applist` API
**Purpose**: Retrieve the list of available applications on the host PC. moonlight-qt:288-328 

**Required Parameters**:
- `uniqueid`: "0123456789ABCDEF"
- `uuid`: Random UUID

**Protocol**: HTTPS (requires prior pairing)

**Response**: XML with app information including:
- `AppTitle`: Application name
- `ID`: Application ID
- `IsHdrSupported`: HDR capability
- `IsAppCollectorGame`: Whether it's an App Collector game

### Box Art - `getBoxArt` API
**Purpose**: Download application cover art/thumbnails. moonlight-qt:178-179 moonlight-qt:107-129 

**Required Parameters**:
- `appId`: Application ID

**Protocol**: HTTPS
**Response**: Image data (various formats, cached as PNG locally)

## 3. **Starting a Streaming Connection**

### Launch/Resume - `launch` or `resume` API
**Purpose**: Start a new streaming session or resume an existing one. moonlight-qt:190-236 moonlight-qt:1582-1600 

**Endpoint**: `launch` (new session) or `resume` (existing session)

**Required Parameters**:
- `uniqueid`: "0123456789ABCDEF"
- `uuid`: Random UUID
- `appid`: Application ID to launch
- `mode`: Resolution and FPS (format: `{width}x{height}x{fps}`)
- `additionalStates=1`: Enable additional states
- `sops`: Stream optimization settings (0 or 1)
- `rikey`: Remote input AES key (hex)
- `rikeyid`: Remote input key ID
- `hdrMode`: HDR mode flag (included if HDR supported)
- `clientHdrCapVersion`, `clientHdrCapSupportedFlagsInUint32`, `clientHdrCapMetaDataId`, `clientHdrCapDisplayData`: HDR capability parameters (if HDR mode)
- `localAudioPlayMode`: Play audio on host (0 or 1)
- `surroundAudioInfo`: Surround audio configuration
- `remoteControllersBitmap`: Gamepad mask
- `gcmap`: Gamepad controller map
- `gcpersist`: Persist game controllers on disconnect (0 or 1)
- Additional parameters from `LiGetLaunchUrlQueryParameters()`

**Protocol**: HTTPS

**Response**: XML containing `sessionUrl0` (RTSP session URL)

**Decision Logic**: The verb is determined based on whether a game is currently running: moonlight-qt:1586-1593 

## 4. **Ending a Streaming Connection**

### Quit App - `cancel` API
**Purpose**: Terminate the currently running application on the host PC. moonlight-qt:238-259 

**Required Parameters**:
- `uniqueid`: "0123456789ABCDEF"
- `uuid`: Random UUID

**Protocol**: HTTPS

**Timeout**: 30 seconds

**Note**: The quit operation is optional based on user preferences: moonlight-qt:1554-1558 

## Additional APIs

### Wake-on-LAN
**Purpose**: Wake up a sleeping/powered-off host PC. moonlight-qt:1-50 

**Protocol**: UDP magic packets sent to multiple addresses and ports (9, 47009, and dynamic ports 47998-48010)

### Unpair - `unpair` API
**Purpose**: Remove pairing relationship (used during pairing failures). moonlight-qt:232-234 

**Required Parameters**: Standard uniqueid and uuid

**Protocol**: HTTP

## Notes

- All HTTP/HTTPS requests use a common `uniqueid` of "0123456789ABCDEF" to allow Moonlight clients to manage each other's sessions
- Each request includes a random `uuid` parameter generated via `QUuid::createUuid()`
- Certificate pinning is implemented for HTTPS connections to prevent MITM attacks
- Timeouts vary by operation: 2s (fast-fail), 5s (normal), 30s (resume/quit), 120s (launch)
- The base URL format is `http(s)://{host}:{port}/{command}?{parameters}`
### Citations
**File:** app/backend/nvhttp.cpp (L124-187)
```cpp
NvHTTP::getServerInfo(NvLogLevel logLevel, bool fastFail)
{
    QString serverInfo;

    // Check if we have a pinned cert and HTTPS port for this host yet
    if (!m_ServerCert.isNull() && httpsPort() != 0)
    {
        try
        {
            // Always try HTTPS first, since it properly reports
            // pairing status (and a few other attributes).
            serverInfo = openConnectionToString(m_BaseUrlHttps,
                                                "serverinfo",
                                                nullptr,
                                                fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                                logLevel);
            // Throws if the request failed
            verifyResponseStatus(serverInfo);
        }
        catch (const GfeHttpResponseException& e)
        {
            if (e.getStatusCode() == 401)
            {
                // Certificate validation error, fallback to HTTP
                serverInfo = openConnectionToString(m_BaseUrlHttp,
                                                    "serverinfo",
                                                    nullptr,
                                                    fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                                    logLevel);
                verifyResponseStatus(serverInfo);
            }
            else
            {
                // Rethrow real errors
                throw e;
            }
        }
    }
    else
    {
        // Only use HTTP prior to pairing or fetching HTTPS port
        serverInfo = openConnectionToString(m_BaseUrlHttp,
                                            "serverinfo",
                                            nullptr,
                                            fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                            logLevel);
        verifyResponseStatus(serverInfo);

        // Populate the HTTPS port
        uint16_t httpsPort = getXmlString(serverInfo, "HttpsPort").toUShort();
        if (httpsPort == 0) {
            httpsPort = DEFAULT_HTTPS_PORT;
        }
        setHttpsPort(httpsPort);

        // If we just needed to determine the HTTPS port, we'll try again over
        // HTTPS now that we have the port number
        if (!m_ServerCert.isNull()) {
            return getServerInfo(logLevel, fastFail);
        }
    }

    return serverInfo;
}
```
**File:** app/backend/nvhttp.cpp (L190-236)
```cpp
NvHTTP::startApp(QString verb,
                 bool isGfe,
                 int appId,
                 PSTREAM_CONFIGURATION streamConfig,
                 bool sops,
                 bool localAudio,
                 int gamepadMask,
                 bool persistGameControllersOnDisconnect,
                 QString& rtspSessionUrl)
{
    int riKeyId;

    memcpy(&riKeyId, streamConfig->remoteInputAesIv, sizeof(riKeyId));
    riKeyId = qFromBigEndian(riKeyId);

    QString response =
            openConnectionToString(m_BaseUrlHttps,
                                   verb,
                                   "appid="+QString::number(appId)+
                                   "&mode="+QString::number(streamConfig->width)+"x"+
                                   QString::number(streamConfig->height)+"x"+
                                   // Using an FPS value over 60 causes SOPS to default to 720p60,
                                   // so force it to 0 to ensure the correct resolution is set. We
                                   // used to use 60 here but that locked the frame rate to 60 FPS
                                   // on GFE 3.20.3. We don't need this hack for Sunshine.
                                   QString::number((streamConfig->fps > 60 && isGfe) ? 0 : streamConfig->fps)+
                                   "&additionalStates=1&sops="+QString::number(sops ? 1 : 0)+
                                   "&rikey="+QByteArray(streamConfig->remoteInputAesKey, sizeof(streamConfig->remoteInputAesKey)).toHex()+
                                   "&rikeyid="+QString::number(riKeyId)+
                                   ((streamConfig->supportedVideoFormats & VIDEO_FORMAT_MASK_10BIT) ?
                                       "&hdrMode=1&clientHdrCapVersion=0&clientHdrCapSupportedFlagsInUint32=0&clientHdrCapMetaDataId=NV_STATIC_METADATA_TYPE_1&clientHdrCapDisplayData=0x0x0x0x0x0x0x0x0x0x0" :
                                        "")+
                                   "&localAudioPlayMode="+QString::number(localAudio ? 1 : 0)+
                                   "&surroundAudioInfo="+QString::number(SURROUNDAUDIOINFO_FROM_AUDIO_CONFIGURATION(streamConfig->audioConfiguration))+
                                   "&remoteControllersBitmap="+QString::number(gamepadMask)+
                                   "&gcmap="+QString::number(gamepadMask)+
                                   "&gcpersist="+QString::number(persistGameControllersOnDisconnect ? 1 : 0)+
                                   LiGetLaunchUrlQueryParameters(),
                                   LAUNCH_TIMEOUT_MS);

    qInfo() << "Launch response:" << response;

    // Throws if the request failed
    verifyResponseStatus(response);

    rtspSessionUrl = getXmlString(response, "sessionUrl0");
}
```
**File:** app/backend/nvhttp.cpp (L238-259)
```cpp
void
NvHTTP::quitApp()
{
    QString response =
            openConnectionToString(m_BaseUrlHttps,
                                   "cancel",
                                   nullptr,
                                   QUIT_TIMEOUT_MS);

    qInfo() << "Quit response:" << response;

    // Throws if the request failed
    verifyResponseStatus(response);

    // Newer GFE versions will just return success even if quitting fails
    // if we're not the original requester.
    if (getCurrentGame(getServerInfo(NvHTTP::NVLL_ERROR)) != 0) {
        // Generate a synthetic GfeResponseException letting the caller know
        // that they can't kill someone else's stream.
        throw GfeHttpResponseException(599, "");
    }
}
```
**File:** app/backend/nvhttp.cpp (L288-328)
```cpp
QVector<NvApp>
NvHTTP::getAppList()
{
    QString appxml = openConnectionToString(m_BaseUrlHttps,
                                            "applist",
                                            nullptr,
                                            REQUEST_TIMEOUT_MS,
                                            NvLogLevel::NVLL_ERROR);
    verifyResponseStatus(appxml);

    QXmlStreamReader xmlReader(appxml);
    QVector<NvApp> apps;
    while (!xmlReader.atEnd()) {
        while (xmlReader.readNextStartElement()) {
            auto name = xmlReader.name();
            if (name == QString("App")) {
                // We must have a valid app before advancing to the next one
                if (!apps.isEmpty() && !apps.last().isInitialized()) {
                    qWarning() << "Invalid applist XML";
                    Q_ASSERT(false);
                    return QVector<NvApp>();
                }
                apps.append(NvApp());
            }
            else if (name == QString("AppTitle")) {
                apps.last().name = xmlReader.readElementText();
            }
            else if (name == QString("ID")) {
                apps.last().id = xmlReader.readElementText().toInt();
            }
            else if (name == QString("IsHdrSupported")) {
                apps.last().hdrSupported = xmlReader.readElementText() == "1";
            }
            else if (name == QString("IsAppCollectorGame")) {
                apps.last().isAppCollectorGame = xmlReader.readElementText() == "1";
            }
        }
    }

    return apps;
}
```
**File:** app/backend/nvpairingmanager.cpp (L191-355)
```cpp
NvPairingManager::pair(QString appVersion, QString pin, QSslCertificate& serverCert)
{
    int serverMajorVersion = NvHTTP::parseQuad(appVersion).at(0);
    qInfo() << "Pairing with server generation:" << serverMajorVersion;

    QCryptographicHash::Algorithm hashAlgo;
    int hashLength;
    if (serverMajorVersion >= 7)
    {
        // Gen 7+ uses SHA-256 hashing
        hashAlgo = QCryptographicHash::Sha256;
        hashLength = 32;
    }
    else
    {
        // Prior to Gen 7 uses SHA-1 hashing
        hashAlgo = QCryptographicHash::Sha1;
        hashLength = 20;
    }

    QByteArray salt = generateRandomBytes(16);
    QByteArray saltedPin = saltPin(salt, pin);

    QByteArray aesKey = QCryptographicHash::hash(saltedPin, hashAlgo).constData();
    aesKey.truncate(16);

    QString getCert = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&phrase=getservercert&salt=" +
                                                    salt.toHex() + "&clientcert=" + IdentityManager::get()->getCertificate().toHex(),
                                                    0);
    NvHTTP::verifyResponseStatus(getCert);
    if (NvHTTP::getXmlString(getCert, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #1";
        return PairState::FAILED;
    }

    QByteArray serverCertStr = NvHTTP::getXmlStringFromHex(getCert, "plaincert");
    if (serverCertStr == nullptr)
    {
        qCritical() << "Server likely already pairing";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::ALREADY_IN_PROGRESS;
    }

    QSslCertificate unverifiedServerCert = QSslCertificate(serverCertStr);
    if (unverifiedServerCert.isNull()) {
        Q_ASSERT(!unverifiedServerCert.isNull());

        qCritical() << "Failed to parse plaincert";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    // Pin this cert for TLS until pairing is complete. If successful, we will propagate
    // the cert into the NvComputer object and persist it.
    m_Http.setServerCert(unverifiedServerCert);

    QByteArray randomChallenge = generateRandomBytes(16);
    QByteArray encryptedChallenge = encrypt(randomChallenge, aesKey);
    QString challengeXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                         "pair",
                                                         "devicename=roth&updateState=1&clientchallenge=" +
                                                         encryptedChallenge.toHex(),
                                                         REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(challengeXml);
    if (NvHTTP::getXmlString(challengeXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #2";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray challengeResponseData = decrypt(m_Http.getXmlStringFromHex(challengeXml, "challengeresponse"), aesKey);
    QByteArray clientSecretData = generateRandomBytes(16);
    QByteArray challengeResponse;
    QByteArray serverResponse(challengeResponseData.data(), hashLength);

#if (OPENSSL_VERSION_NUMBER < 0x10002000L)
    ASN1_BIT_STRING *asnSignature = m_Cert->signature;
#elif (OPENSSL_VERSION_NUMBER < 0x10100000L)
    ASN1_BIT_STRING *asnSignature;
    X509_get0_signature(&asnSignature, NULL, m_Cert);
#else
    const ASN1_BIT_STRING *asnSignature;
    X509_get0_signature(&asnSignature, NULL, m_Cert);
#endif

    challengeResponse.append(challengeResponseData.data() + hashLength, 16);
    challengeResponse.append(reinterpret_cast<char*>(asnSignature->data), asnSignature->length);
    challengeResponse.append(clientSecretData);

    QByteArray paddedHash = QCryptographicHash::hash(challengeResponse, hashAlgo);
    paddedHash.resize(32);
    QByteArray encryptedChallengeResponseHash = encrypt(paddedHash, aesKey);
    QString respXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&serverchallengeresp=" +
                                                    encryptedChallengeResponseHash.toHex(),
                                                    REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(respXml);
    if (NvHTTP::getXmlString(respXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #3";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray pairingSecret = NvHTTP::getXmlStringFromHex(respXml, "pairingsecret");
    QByteArray serverSecret = pairingSecret.left(16);
    QByteArray serverSignature = pairingSecret.mid(16);

    if (!verifySignature(serverSecret,
                         serverSignature,
                         serverCertStr))
    {
        qCritical() << "MITM detected";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray expectedResponseData;
    expectedResponseData.append(randomChallenge);
    expectedResponseData.append(getSignatureFromPemCert(serverCertStr));
    expectedResponseData.append(serverSecret);
    if (QCryptographicHash::hash(expectedResponseData, hashAlgo) != serverResponse)
    {
        qCritical() << "Incorrect PIN";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::PIN_WRONG;
    }

    QByteArray clientPairingSecret;
    clientPairingSecret.append(clientSecretData);
    clientPairingSecret.append(signMessage(clientSecretData));

    QString secretRespXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                          "pair",
                                                          "devicename=roth&updateState=1&clientpairingsecret=" +
                                                          clientPairingSecret.toHex(),
                                                          REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(secretRespXml);
    if (NvHTTP::getXmlString(secretRespXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #4";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QString pairChallengeXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttps,
                                                             "pair",
                                                             "devicename=roth&updateState=1&phrase=pairchallenge",
                                                             REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(pairChallengeXml);
    if (NvHTTP::getXmlString(pairChallengeXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #5";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    serverCert = std::move(unverifiedServerCert);
    return PairState::PAIRED;
}
```
**File:** app/backend/nvhttp.h (L178-179)
```text
    QImage
    getBoxArt(int appId);
```
**File:** app/backend/boxartmanager.cpp (L107-129)
```cpp
QUrl BoxArtManager::loadBoxArtFromNetwork(NvComputer* computer, int appId)
{
    NvHTTP http(computer);

    QString cachePath = getFilePathForBoxArt(computer, appId);
    QImage image;
    try {
        image = http.getBoxArt(appId);
    } catch (...) {}

    // Cache the box art on disk if it loaded
    if (!image.isNull()) {
        if (image.save(cachePath)) {
            return QUrl::fromLocalFile(cachePath);
        }
        else {
            // A failed save() may leave a zero byte file. Make sure that's removed.
            QFile(cachePath).remove();
        }
    }

    return QUrl();
}
```
**File:** app/streaming/session.cpp (L1554-1558)
```cpp
    // The UI should have ensured the old game was already quit
    // if we decide to stream a different game.
    Q_ASSERT(m_Computer->currentGameId == 0 ||
             m_Computer->currentGameId == m_App.id);

```
**File:** app/streaming/session.cpp (L1582-1600)
```cpp
    QString rtspSessionUrl;

    try {
        NvHTTP http(m_Computer);
        http.startApp(m_Computer->currentGameId != 0 ? "resume" : "launch",
                      m_Computer->isNvidiaServerSoftware,
                      m_App.id, &m_StreamConfig,
                      enableGameOptimizations,
                      m_Preferences->playAudioOnHost,
                      m_InputHandler->getAttachedGamepadMask(),
                      !m_Preferences->multiController,
                      rtspSessionUrl);
    } catch (const GfeHttpResponseException& e) {
        emit displayLaunchError(tr("Host returned error: %1").arg(e.toQString()));
        return false;
    } catch (const QtNetworkReplyException& e) {
        emit displayLaunchError(e.toQString());
        return false;
    }
```
**File:** app/backend/nvcomputer.cpp (L1-50)
```cpp
#include "nvcomputer.h"
#include "nvapp.h"
#include "settings/compatfetcher.h"

#include <QUdpSocket>
#include <QHostInfo>
#include <QNetworkInterface>
#include <QNetworkProxy>

#define SER_NAME "hostname"
#define SER_UUID "uuid"
#define SER_MAC "mac"
#define SER_LOCALADDR "localaddress"
#define SER_LOCALPORT "localport"
#define SER_REMOTEADDR "remoteaddress"
#define SER_REMOTEPORT "remoteport"
#define SER_MANUALADDR "manualaddress"
#define SER_MANUALPORT "manualport"
#define SER_IPV6ADDR "ipv6address"
#define SER_IPV6PORT "ipv6port"
#define SER_APPLIST "apps"
#define SER_SRVCERT "srvcert"
#define SER_CUSTOMNAME "customname"
#define SER_NVIDIASOFTWARE "nvidiasw"

NvComputer::NvComputer(QSettings& settings)
{
    this->name = settings.value(SER_NAME).toString();
    this->uuid = settings.value(SER_UUID).toString();
    this->hasCustomName = settings.value(SER_CUSTOMNAME).toBool();
    this->macAddress = settings.value(SER_MAC).toByteArray();
    this->localAddress = NvAddress(settings.value(SER_LOCALADDR).toString(),
                                   settings.value(SER_LOCALPORT, QVariant(DEFAULT_HTTP_PORT)).toUInt());
    this->remoteAddress = NvAddress(settings.value(SER_REMOTEADDR).toString(),
                                    settings.value(SER_REMOTEPORT, QVariant(DEFAULT_HTTP_PORT)).toUInt());
    this->ipv6Address = NvAddress(settings.value(SER_IPV6ADDR).toString(),
                                  settings.value(SER_IPV6PORT, QVariant(DEFAULT_HTTP_PORT)).toUInt());
    this->manualAddress = NvAddress(settings.value(SER_MANUALADDR).toString(),
                                    settings.value(SER_MANUALPORT, QVariant(DEFAULT_HTTP_PORT)).toUInt());
    this->serverCert = QSslCertificate(settings.value(SER_SRVCERT).toByteArray());
    this->isNvidiaServerSoftware = settings.value(SER_NVIDIASOFTWARE).toBool();

    int appCount = settings.beginReadArray(SER_APPLIST);
    this->appList.reserve(appCount);
    for (int i = 0; i < appCount; i++) {
        settings.setArrayIndex(i);

        NvApp app(settings);
        this->appList.append(app);
    }
```
## Q10
The server completes the pairing by inputting the PIN code displayed by the client. How does the client wait for the server's response to complete the pairing during the time the PIN code is generated and the user inputs the PIN on the server side?
### Answer
You're asking about how the Moonlight client waits for the server to complete pairing after displaying the PIN code to the user.

## Answer

The client doesn't actively poll or wait for the server's response during pairing. Instead, the pairing process is **synchronous and blocking** - the client sends requests sequentially through all 5 phases and waits for each response before proceeding to the next phase.

### Pairing Execution Flow

When the user clicks on an unpaired PC, the client generates a PIN and displays it in a dialog: moonlight-qt:239-246 

The pairing task runs in a background thread via `PendingPairingTask`: moonlight-qt:564-582 

### The Blocking Nature of Pairing

Inside `NvPairingManager::pair()`, each phase makes an HTTP/HTTPS request and **blocks waiting for the response** before proceeding: moonlight-qt:217-227 

The server validates the PIN during Phase 3 (server challenge response). If the user hasn't entered the PIN yet on the server side, the server simply doesn't respond or returns an error, causing the pairing to fail: moonlight-qt:287-298 

### PIN Validation

The PIN validation happens when the client sends the encrypted challenge response hash in Phase 3. The server decrypts this using the PIN-derived key and verifies it matches the expected value: moonlight-qt:313-322 

If the PIN is incorrect (user entered wrong PIN on server), the server returns a response that causes the client to detect `PIN_WRONG` state: moonlight-qt:585-586 

### UI Feedback

While pairing is in progress, the dialog remains open showing the PIN: moonlight-qt:302-310 

When pairing completes (successfully or with error), the `pairingCompleted` signal is emitted, which closes the dialog: moonlight-qt:47-58 

## Notes

The pairing process uses HTTP request timeouts (defined as `REQUEST_TIMEOUT_MS`) to prevent indefinite waiting. If the user takes too long to enter the PIN on the server, the HTTP request will timeout and pairing will fail. The client doesn't implement any retry logic or polling mechanism - it's a single synchronous attempt that either succeeds or fails based on the server's responses to the 5-phase handshake.

Wiki pages you might want to explore:
- [User Interface System (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2)
- [PC Discovery View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.1)
### Citations
**File:** app/gui/PcView.qml (L47-58)
```text
    function pairingComplete(error)
    {
        // Close the PIN dialog
        pairDialog.close()

        // Display a failed dialog if we got an error
        if (error !== undefined) {
            errorDialog.text = error
            errorDialog.helpText = ""
            errorDialog.open()
        }
    }
```
**File:** app/gui/PcView.qml (L239-246)
```text
                    var pin = computerModel.generatePinString()

                    // Kick off pairing in the background
                    computerModel.pairComputer(index, pin)

                    // Display the pairing dialog
                    pairDialog.pin = pin
                    pairDialog.open()
```
**File:** app/gui/PcView.qml (L302-310)
```text
        // don't allow edits to the rest of the window while open
        property string pin : "0000"
        text:qsTr("Please enter %1 on your host PC. This dialog will close when pairing is completed.").arg(pin)+"\n\n"+
             qsTr("If your host PC is running Sunshine, navigate to the Sunshine web UI to enter the PIN.")
        standardButtons: Dialog.Cancel
        onRejected: {
            // FIXME: We should interrupt pairing here
        }
    }
```
**File:** app/backend/computermanager.cpp (L564-582)
```cpp
    PendingPairingTask(ComputerManager* computerManager, NvComputer* computer, QString pin)
        : m_ComputerManager(computerManager),
          m_Computer(computer),
          m_Pin(pin)
    {
        connect(this, &PendingPairingTask::pairingCompleted,
                computerManager, &ComputerManager::pairingCompleted);
    }

signals:
    void pairingCompleted(NvComputer* computer, QString error);

private:
    void run()
    {
        NvPairingManager pairingManager(m_Computer);

        try {
           NvPairingManager::PairState result = pairingManager.pair(m_Computer->appVersion, m_Pin, m_Computer->serverCert);
```
**File:** app/backend/computermanager.cpp (L585-586)
```cpp
           case NvPairingManager::PairState::PIN_WRONG:
               emit pairingCompleted(m_Computer, tr("The PIN from the PC didn't match. Please try again."));
```
**File:** app/backend/nvpairingmanager.cpp (L217-227)
```cpp
    QString getCert = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&phrase=getservercert&salt=" +
                                                    salt.toHex() + "&clientcert=" + IdentityManager::get()->getCertificate().toHex(),
                                                    0);
    NvHTTP::verifyResponseStatus(getCert);
    if (NvHTTP::getXmlString(getCert, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #1";
        return PairState::FAILED;
    }
```
**File:** app/backend/nvpairingmanager.cpp (L287-298)
```cpp
    QString respXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&serverchallengeresp=" +
                                                    encryptedChallengeResponseHash.toHex(),
                                                    REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(respXml);
    if (NvHTTP::getXmlString(respXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #3";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }
```
**File:** app/backend/nvpairingmanager.cpp (L313-322)
```cpp
    QByteArray expectedResponseData;
    expectedResponseData.append(randomChallenge);
    expectedResponseData.append(getSignatureFromPemCert(serverCertStr));
    expectedResponseData.append(serverSecret);
    if (QCryptographicHash::hash(expectedResponseData, hashAlgo) != serverResponse)
    {
        qCritical() << "Incorrect PIN";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::PIN_WRONG;
    }
```
# DeepWiki Q&A with Code Context for Repository: moonlight-stream/moonlight-qt
## Q1
how to get /launch and /serverinfo info from server?
### Answer
Based on the code context, you're asking about how Moonlight retrieves `/launch` and `/serverinfo` information from the host server.

## Answer

Moonlight uses the `NvHTTP` class to communicate with the host server and retrieve information through HTTP/HTTPS endpoints. moonlight-qt:124-187 

### Getting `/serverinfo`

The `NvHTTP::getServerInfo()` method fetches server information: moonlight-qt:124-140 

The method first attempts to use HTTPS if a pinned certificate is available, then falls back to HTTP if needed. moonlight-qt:143-160  If no certificate exists yet, it uses HTTP initially to fetch the HTTPS port, then retries over HTTPS. moonlight-qt:162-183 

This is called during PC discovery when adding a new host: moonlight-qt:809-818 

The response is then used to create or update an `NvComputer` object: moonlight-qt:820-821 

### Getting `/launch` info

The `/launch` endpoint is called via `NvHTTP::startApp()` when starting a streaming session: moonlight-qt:1585-1593 

This happens in `Session::startConnectionAsync()` after the user selects an app to stream. moonlight-qt:1548-1600  The method passes streaming configuration parameters and receives back an RTSP session URL that's used to establish the actual streaming connection. moonlight-qt:1582-1593 

## Notes

The `NvHTTP` class handles all HTTP/HTTPS communication with the host server, including certificate pinning for security. The `/serverinfo` endpoint is polled regularly to monitor PC status, while `/launch` (or `/resume`) is only called when initiating a streaming session. Both endpoints use the base URL constructed from the host's address and appropriate port (HTTP 47989 or HTTPS 47984 by default).

Wiki pages you might want to explore:
- [User Interface System (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2)
- [PC Discovery View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.1)
### Citations
**File:** app/backend/nvhttp.cpp (L124-187)
```cpp
NvHTTP::getServerInfo(NvLogLevel logLevel, bool fastFail)
{
    QString serverInfo;

    // Check if we have a pinned cert and HTTPS port for this host yet
    if (!m_ServerCert.isNull() && httpsPort() != 0)
    {
        try
        {
            // Always try HTTPS first, since it properly reports
            // pairing status (and a few other attributes).
            serverInfo = openConnectionToString(m_BaseUrlHttps,
                                                "serverinfo",
                                                nullptr,
                                                fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                                logLevel);
            // Throws if the request failed
            verifyResponseStatus(serverInfo);
        }
        catch (const GfeHttpResponseException& e)
        {
            if (e.getStatusCode() == 401)
            {
                // Certificate validation error, fallback to HTTP
                serverInfo = openConnectionToString(m_BaseUrlHttp,
                                                    "serverinfo",
                                                    nullptr,
                                                    fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                                    logLevel);
                verifyResponseStatus(serverInfo);
            }
            else
            {
                // Rethrow real errors
                throw e;
            }
        }
    }
    else
    {
        // Only use HTTP prior to pairing or fetching HTTPS port
        serverInfo = openConnectionToString(m_BaseUrlHttp,
                                            "serverinfo",
                                            nullptr,
                                            fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                            logLevel);
        verifyResponseStatus(serverInfo);

        // Populate the HTTPS port
        uint16_t httpsPort = getXmlString(serverInfo, "HttpsPort").toUShort();
        if (httpsPort == 0) {
            httpsPort = DEFAULT_HTTPS_PORT;
        }
        setHttpsPort(httpsPort);

        // If we just needed to determine the HTTPS port, we'll try again over
        // HTTPS now that we have the port number
        if (!m_ServerCert.isNull()) {
            return getServerInfo(logLevel, fastFail);
        }
    }

    return serverInfo;
}
```
**File:** app/backend/computermanager.cpp (L809-818)
```cpp
        // Perform initial serverinfo fetch over HTTP since we don't know which cert to use
        QString serverInfo = fetchServerInfo(http);
        if (serverInfo.isEmpty() && !m_MdnsIpv6Address.isNull()) {
            // Retry using the global IPv6 address if the IPv4 or link-local IPv6 address fails
            http.setAddress(m_MdnsIpv6Address);
            serverInfo = fetchServerInfo(http);
        }
        if (serverInfo.isEmpty()) {
            return;
        }
```
**File:** app/backend/computermanager.cpp (L820-821)
```cpp
        // Create initial newComputer using HTTP serverinfo with no pinned cert
        NvComputer* newComputer = new NvComputer(http, serverInfo);
```
**File:** app/streaming/session.cpp (L1548-1600)
```cpp
bool Session::startConnectionAsync()
{
    // Wait 1.5 seconds before connecting to let the user
    // have time to read any messages present on the segue
    SDL_Delay(1500);

    // The UI should have ensured the old game was already quit
    // if we decide to stream a different game.
    Q_ASSERT(m_Computer->currentGameId == 0 ||
             m_Computer->currentGameId == m_App.id);

    bool enableGameOptimizations;
    if (m_Computer->isNvidiaServerSoftware) {
        // GFE will set all settings to 720p60 if it doesn't recognize
        // the chosen resolution. Avoid that by disabling SOPS when it
        // is not streaming a supported resolution.
        enableGameOptimizations = false;
        for (const NvDisplayMode &mode : m_Computer->displayModes) {
            if (mode.width == m_StreamConfig.width &&
                    mode.height == m_StreamConfig.height) {
                SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION,
                            "Found host supported resolution: %dx%d",
                            mode.width, mode.height);
                enableGameOptimizations = m_Preferences->gameOptimizations;
                break;
            }
        }
    }
    else {
        // Always send SOPS to Sunshine because we may repurpose the
        // option to control whether the display mode is adjusted
        enableGameOptimizations = m_Preferences->gameOptimizations;
    }

    QString rtspSessionUrl;

    try {
        NvHTTP http(m_Computer);
        http.startApp(m_Computer->currentGameId != 0 ? "resume" : "launch",
                      m_Computer->isNvidiaServerSoftware,
                      m_App.id, &m_StreamConfig,
                      enableGameOptimizations,
                      m_Preferences->playAudioOnHost,
                      m_InputHandler->getAttachedGamepadMask(),
                      !m_Preferences->multiController,
                      rtspSessionUrl);
    } catch (const GfeHttpResponseException& e) {
        emit displayLaunchError(tr("Host returned error: %1").arg(e.toQString()));
        return false;
    } catch (const QtNetworkReplyException& e) {
        emit displayLaunchError(e.toQString());
        return false;
    }
```
## Q2
How to parse the information returned by the above 2 interfaces and provide it to the function for establishing a streaming connection?
### Answer
You're asking about how Moonlight parses the responses from `/serverinfo` and `/launch` endpoints and uses that information to establish a streaming connection.

## Answer

### Parsing `/serverinfo` Response

The `/serverinfo` response is parsed to create/update an `NvComputer` object that stores host capabilities. moonlight-qt:754-782  The `NvHTTP::getServerInfo()` method returns an XML string that gets parsed to extract server properties like:<cite />

- Server codec mode support (`serverCodecModeSupport`)
- GFE version (`gfeVersion`)
- App version (`appVersion`)
- Display modes
- Current game ID

These properties are stored in the `NvComputer` object and later used during session validation and configuration.<cite />

### Parsing `/launch` Response and Establishing Connection

When starting a stream, `NvHTTP::startApp()` is called with the `STREAM_CONFIGURATION` structure containing all streaming parameters (resolution, FPS, bitrate, codec preferences, etc.). moonlight-qt:189-236  The method constructs a URL with query parameters including:<cite />

- Resolution and FPS (`mode` parameter)
- HDR settings
- Audio configuration
- Gamepad mask
- Remote input encryption keys

The response is parsed to extract the `rtspSessionUrl` using `getXmlString(response, "sessionUrl0")`. moonlight-qt:235-235 

### Providing Information to Connection Function

After receiving the `/launch` response, the parsed information is used to populate a `SERVER_INFORMATION` structure: moonlight-qt:1602-1624 

```cpp
SERVER_INFORMATION hostInfo;
hostInfo.address = hostnameStr.data();
hostInfo.serverInfoAppVersion = siAppVersion.data();
hostInfo.serverCodecModeSupport = m_Computer->serverCodecModeSupport;
hostInfo.serverInfoGfeVersion = siGfeVersion.data();
hostInfo.rtspSessionUrl = rtspSessionUrlStr.data();
```

This structure, along with the `STREAM_CONFIGURATION` and callback structures, is passed to `LiStartConnection()` to establish the actual streaming connection: moonlight-qt:1678-1685 

The `LiStartConnection()` function (from the moonlight-common-c library) uses:
- The RTSP session URL from `/launch` response to establish the RTSP control channel
- Server codec support from `/serverinfo` to negotiate video formats
- Stream configuration to set up video/audio decoders

### Validation Before Connection

Before calling `LiStartConnection()`, the session validates that the host supports the requested features by checking `m_Computer->serverCodecModeSupport` against the requested video formats. moonlight-qt:1117-1152  For example, it verifies YUV 4:4:4 support and adjusts the supported video formats list accordingly.<cite />

## Notes

The parsing happens in two stages: first during PC discovery (parsing `/serverinfo` into `NvComputer` properties), then during session start (parsing `/launch` response for RTSP URL). The `NvComputer` object acts as a bridge, storing server capabilities that are later referenced when configuring the `SERVER_INFORMATION` structure for `LiStartConnection()`. The actual XML parsing is handled by helper functions like `getXmlString()` in the `NvHTTP` class.

Wiki pages you might want to explore:
- [Settings View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.2)
- [Input Handling (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#4.7)
### Citations
**File:** app/backend/computermanager.cpp (L754-782)
```cpp
    QString fetchServerInfo(NvHTTP& http)
    {
        QString serverInfo;

        // Do nothing if we're quitting
        if (m_AboutToQuit) {
            return QString();
        }

        try {
            // There's a race condition between GameStream servers reporting presence over
            // mDNS and the HTTPS server being ready to respond to our queries. To work
            // around this issue, we will issue the request again after a few seconds if
            // we see a ServiceUnavailableError error.
            try {
                serverInfo = http.getServerInfo(NvHTTP::NVLL_VERBOSE);
            } catch (const QtNetworkReplyException& e) {
                if (e.getError() == QNetworkReply::ServiceUnavailableError) {
                    qWarning() << "Retrying request in 5 seconds after ServiceUnavailableError";
                    QThread::sleep(5);
                    serverInfo = http.getServerInfo(NvHTTP::NVLL_VERBOSE);
                    qInfo() << "Retry successful";
                }
                else {
                    // Rethrow other errors
                    throw e;
                }
            }
            return serverInfo;
```
**File:** app/backend/nvhttp.cpp (L189-236)
```cpp
void
NvHTTP::startApp(QString verb,
                 bool isGfe,
                 int appId,
                 PSTREAM_CONFIGURATION streamConfig,
                 bool sops,
                 bool localAudio,
                 int gamepadMask,
                 bool persistGameControllersOnDisconnect,
                 QString& rtspSessionUrl)
{
    int riKeyId;

    memcpy(&riKeyId, streamConfig->remoteInputAesIv, sizeof(riKeyId));
    riKeyId = qFromBigEndian(riKeyId);

    QString response =
            openConnectionToString(m_BaseUrlHttps,
                                   verb,
                                   "appid="+QString::number(appId)+
                                   "&mode="+QString::number(streamConfig->width)+"x"+
                                   QString::number(streamConfig->height)+"x"+
                                   // Using an FPS value over 60 causes SOPS to default to 720p60,
                                   // so force it to 0 to ensure the correct resolution is set. We
                                   // used to use 60 here but that locked the frame rate to 60 FPS
                                   // on GFE 3.20.3. We don't need this hack for Sunshine.
                                   QString::number((streamConfig->fps > 60 && isGfe) ? 0 : streamConfig->fps)+
                                   "&additionalStates=1&sops="+QString::number(sops ? 1 : 0)+
                                   "&rikey="+QByteArray(streamConfig->remoteInputAesKey, sizeof(streamConfig->remoteInputAesKey)).toHex()+
                                   "&rikeyid="+QString::number(riKeyId)+
                                   ((streamConfig->supportedVideoFormats & VIDEO_FORMAT_MASK_10BIT) ?
                                       "&hdrMode=1&clientHdrCapVersion=0&clientHdrCapSupportedFlagsInUint32=0&clientHdrCapMetaDataId=NV_STATIC_METADATA_TYPE_1&clientHdrCapDisplayData=0x0x0x0x0x0x0x0x0x0x0" :
                                        "")+
                                   "&localAudioPlayMode="+QString::number(localAudio ? 1 : 0)+
                                   "&surroundAudioInfo="+QString::number(SURROUNDAUDIOINFO_FROM_AUDIO_CONFIGURATION(streamConfig->audioConfiguration))+
                                   "&remoteControllersBitmap="+QString::number(gamepadMask)+
                                   "&gcmap="+QString::number(gamepadMask)+
                                   "&gcpersist="+QString::number(persistGameControllersOnDisconnect ? 1 : 0)+
                                   LiGetLaunchUrlQueryParameters(),
                                   LAUNCH_TIMEOUT_MS);

    qInfo() << "Launch response:" << response;

    // Throws if the request failed
    verifyResponseStatus(response);

    rtspSessionUrl = getXmlString(response, "sessionUrl0");
}
```
**File:** app/streaming/session.cpp (L1117-1152)
```cpp
    if (m_Preferences->enableYUV444) {
        if (!(m_Computer->serverCodecModeSupport & SCM_MASK_YUV444)) {
            emitLaunchWarning(tr("Your host PC doesn't support YUV 4:4:4 streaming."));
            m_SupportedVideoFormats.removeByMask(VIDEO_FORMAT_MASK_YUV444);
        }
        else {
            m_SupportedVideoFormats.removeByMask(~m_SupportedVideoFormats.maskByServerCodecModes(m_Computer->serverCodecModeSupport));

            if (!m_SupportedVideoFormats.isEmpty() &&
                !(m_SupportedVideoFormats.front() & VIDEO_FORMAT_MASK_YUV444)) {
                emitLaunchWarning(tr("Your host PC doesn't support YUV 4:4:4 streaming for selected video codec."));
            }
            else if (m_Preferences->videoDecoderSelection != StreamingPreferences::VDS_FORCE_SOFTWARE) {
                while (!m_SupportedVideoFormats.isEmpty() &&
                       (m_SupportedVideoFormats.front() & VIDEO_FORMAT_MASK_YUV444) &&
                       getDecoderAvailability(testWindow,
                                              m_Preferences->videoDecoderSelection,
                                              m_SupportedVideoFormats.front(),
                                              m_StreamConfig.width,
                                              m_StreamConfig.height,
                                              m_StreamConfig.fps) != DecoderAvailability::Hardware) {
                    if (m_Preferences->videoDecoderSelection == StreamingPreferences::VDS_FORCE_HARDWARE) {
                        m_SupportedVideoFormats.removeFirst();
                    }
                    else {
                        emitLaunchWarning(tr("Using software decoding due to your selection to force YUV 4:4:4 without GPU support. This may cause poor streaming performance."));
                        break;
                    }
                }
                if (!m_SupportedVideoFormats.isEmpty() &&
                    !(m_SupportedVideoFormats.front() & VIDEO_FORMAT_MASK_YUV444)) {
                    emitLaunchWarning(tr("This PC's GPU doesn't support YUV 4:4:4 decoding for selected video codec."));
                }
            }
        }
    }
```
**File:** app/streaming/session.cpp (L1602-1624)
```cpp
    QByteArray hostnameStr = m_Computer->activeAddress.address().toLatin1();
    QByteArray siAppVersion = m_Computer->appVersion.toLatin1();

    SERVER_INFORMATION hostInfo;
    hostInfo.address = hostnameStr.data();
    hostInfo.serverInfoAppVersion = siAppVersion.data();
    hostInfo.serverCodecModeSupport = m_Computer->serverCodecModeSupport;

    // Older GFE versions didn't have this field
    QByteArray siGfeVersion;
    if (!m_Computer->gfeVersion.isEmpty()) {
        siGfeVersion = m_Computer->gfeVersion.toLatin1();
    }
    if (!siGfeVersion.isEmpty()) {
        hostInfo.serverInfoGfeVersion = siGfeVersion.data();
    }

    // Older GFE and Sunshine versions didn't have this field
    QByteArray rtspSessionUrlStr;
    if (!rtspSessionUrl.isEmpty()) {
        rtspSessionUrlStr = rtspSessionUrl.toLatin1();
        hostInfo.rtspSessionUrl = rtspSessionUrlStr.data();
    }
```
**File:** app/streaming/session.cpp (L1678-1685)
```cpp
    int err = LiStartConnection(&hostInfo, &m_StreamConfig, &k_ConnCallbacks,
                                &m_VideoCallbacks, &m_AudioCallbacks,
                                NULL, 0, NULL, 0);
    if (err != 0) {
        // We already displayed an error dialog in the stage failure
        // listener.
        return false;
    }
```
## Q3
how to get "Remote input encryption keys"
### Answer
You're asking about how Moonlight generates the "Remote input encryption keys" that are sent to the host server during the `/launch` request.

## Answer

The remote input encryption keys (`rikey` and `rikeyid`) are randomly generated AES encryption keys used to secure input data sent from the client to the host during streaming. moonlight-qt:692-696 

### Key Generation

During session initialization in `Session::initialize()`, Moonlight generates these keys using OpenSSL's cryptographically secure random number generator:

```cpp
RAND_bytes(reinterpret_cast<unsigned char*>(m_StreamConfig.remoteInputAesKey),
           sizeof(m_StreamConfig.remoteInputAesKey));

// Only the first 4 bytes are populated in the RI key IV
RAND_bytes(reinterpret_cast<unsigned char*>(m_StreamConfig.remoteInputAesIv), 4);
``` moonlight-qt:692-696 

The `remoteInputAesKey` is a full AES key (16 bytes), while `remoteInputAesIv` only uses the first 4 bytes as an initialization vector. moonlight-qt:692-696 

### Sending Keys to Host

These generated keys are then sent to the host server when calling the `/launch` endpoint in `NvHTTP::startApp()`. moonlight-qt:200-218  The method:

1. Extracts the key ID from the IV by reading the first 4 bytes as a big-endian integer moonlight-qt:200-203 
2. Converts the AES key to hexadecimal format using `QByteArray(...).toHex()` moonlight-qt:217-217 
3. Includes both values as query parameters: `rikey=<hex_key>&rikeyid=<key_id>` moonlight-qt:217-218 

### Security Considerations

For security, these keys are automatically redacted from log files to prevent exposure. moonlight-qt:108-110  The logging system uses regex patterns to strip `rikey` and `rikeyid` values before writing to logs. moonlight-qt:88-88 

## Notes

The remote input encryption is part of Moonlight's security features to protect input data (keyboard, mouse, gamepad) transmitted during streaming. The keys are generated fresh for each streaming session and are stored in the `STREAM_CONFIGURATION` structure (`m_StreamConfig`) which is later passed to `LiStartConnection()` to establish the connection. moonlight-qt:1584-1593 

Wiki pages you might want to explore:
- [PC Discovery View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.1)
### Citations
**File:** app/streaming/session.cpp (L692-696)
```cpp
    RAND_bytes(reinterpret_cast<unsigned char*>(m_StreamConfig.remoteInputAesKey),
               sizeof(m_StreamConfig.remoteInputAesKey));

    // Only the first 4 bytes are populated in the RI key IV
    RAND_bytes(reinterpret_cast<unsigned char*>(m_StreamConfig.remoteInputAesIv), 4);
```
**File:** app/streaming/session.cpp (L1584-1593)
```cpp
    try {
        NvHTTP http(m_Computer);
        http.startApp(m_Computer->currentGameId != 0 ? "resume" : "launch",
                      m_Computer->isNvidiaServerSoftware,
                      m_App.id, &m_StreamConfig,
                      enableGameOptimizations,
                      m_Preferences->playAudioOnHost,
                      m_InputHandler->getAttachedGamepadMask(),
                      !m_Preferences->multiController,
                      rtspSessionUrl);
```
**File:** app/backend/nvhttp.cpp (L200-218)
```cpp
    int riKeyId;

    memcpy(&riKeyId, streamConfig->remoteInputAesIv, sizeof(riKeyId));
    riKeyId = qFromBigEndian(riKeyId);

    QString response =
            openConnectionToString(m_BaseUrlHttps,
                                   verb,
                                   "appid="+QString::number(appId)+
                                   "&mode="+QString::number(streamConfig->width)+"x"+
                                   QString::number(streamConfig->height)+"x"+
                                   // Using an FPS value over 60 causes SOPS to default to 720p60,
                                   // so force it to 0 to ensure the correct resolution is set. We
                                   // used to use 60 here but that locked the frame rate to 60 FPS
                                   // on GFE 3.20.3. We don't need this hack for Sunshine.
                                   QString::number((streamConfig->fps > 60 && isGfe) ? 0 : streamConfig->fps)+
                                   "&additionalStates=1&sops="+QString::number(sops ? 1 : 0)+
                                   "&rikey="+QByteArray(streamConfig->remoteInputAesKey, sizeof(streamConfig->remoteInputAesKey)).toHex()+
                                   "&rikeyid="+QString::number(riKeyId)+
```
**File:** app/main.cpp (L108-110)
```cpp
    // Strip session encryption keys and IVs from the logs
    message.replace(k_RikeyRegex, "&rikey=REDACTED");
    message.replace(k_RikeyIdRegex, "&rikeyid=REDACTED");
```
**File:** app/deploy/linux/com.moonlight_stream.Moonlight.appdata.xml (L88-88)
```text
					<li>Per-session keys (rikey and rikeyid values) are now automatically stripped from logs</li>
```
## Q4
<?xml version="1.0" encoding="utf-8"?>
<root status_code="200">
  <hostname>Html5syt</hostname>
  <appversion>7.1.431.-1</appversion>
<GfeVersion>3.23.0.74</GfeVersion>
  <uniqueid>F98186B1-DE02-2328-279E-0A461FBCEC47</uniqueid>
  <HttpsPort>47984</HttpsPort>
  <ExternalPort>47989</ExternalPort>
<MaxLumaPixelsHEVC>1869449984</MaxLumaPixelsHEVC>
  <mac>00:00:00:00:00:00</mac>
  <LocalIP>127.0.0.1</LocalIP>
  <ServerCodecModeSupport>257</ServerCodecModeSupport>
<PairStatus>0</PairStatus>
  <currentgame>1191261554</currentgame>
  <state>SUNSHINE_SERVER_BUSY</state>
</root>
This is a response from a serverinfo, please tell me which parameters are used to establish the connection in it?
### Answer
You're asking which parameters from the `/serverinfo` XML response are used when establishing a streaming connection in Moonlight.

## Answer

From the `/serverinfo` response you provided, the following parameters are used to establish the streaming connection:

### Parameters Used in Connection Establishment

**`ServerCodecModeSupport` (value: 257)** - This is stored in the `NvComputer` object and later passed to `LiStartConnection()` via the `SERVER_INFORMATION` structure. moonlight-qt:1608-1608  It indicates which video codecs and formats the host supports, and is used to negotiate the video format during connection setup. moonlight-qt:1608-1608 

**`appversion` (value: 7.1.431.-1)** - This is stored as `m_Computer->appVersion` and passed to `LiStartConnection()` as `hostInfo.serverInfoAppVersion`. moonlight-qt:1603-1607  The connection library uses this to determine host capabilities and compatibility. moonlight-qt:1603-1607 

**`GfeVersion` (value: 3.23.0.74)** - This is stored as `m_Computer->gfeVersion` and passed to `LiStartConnection()` as `hostInfo.serverInfoGfeVersion`. moonlight-qt:1611-1617  It's used to determine if the host is running GFE or Sunshine and adjust behavior accordingly. moonlight-qt:1560-1580 

**`LocalIP` (value: 127.0.0.1)** - The host's address is used to construct the base URLs for HTTP/HTTPS communication and is passed to `LiStartConnection()` as `hostInfo.address`. moonlight-qt:1602-1606 

**`HttpsPort` (value: 47984)** - Used to construct the HTTPS base URL for secure communication with the host, including the `/launch` endpoint call. moonlight-qt:173-177 

### Parameters NOT Directly Used in Connection

The following parameters are informational but not directly passed to the connection function:

- `hostname`, `uniqueid`, `ExternalPort`, `MaxLumaPixelsHEVC`, `mac` - These are stored in the `NvComputer` object for display and management purposes but aren't passed to `LiStartConnection()`.<cite />
- `PairStatus` - Used to determine if pairing is needed before streaming, but not used during connection establishment.<cite />
- `currentgame` and `state` - Used to determine if the host is already streaming, which affects whether to call `/launch` or `/resume`. moonlight-qt:1586-1586 

## Notes

The `state` value "SUNSHINE_SERVER_BUSY" indicates the host is currently streaming (as confirmed by the non-zero `currentgame` value). moonlight-qt:112-116  In this case, Moonlight would call `/resume` instead of `/launch` if you're trying to connect to the same game. moonlight-qt:1586-1586  The `ServerCodecModeSupport` value of 257 indicates support for H.264 (bit 0) and H.265/HEVC (bit 8).<cite />

Wiki pages you might want to explore:
- [PC Discovery View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.1)
### Citations
**File:** app/streaming/session.cpp (L1560-1580)
```cpp
    if (m_Computer->isNvidiaServerSoftware) {
        // GFE will set all settings to 720p60 if it doesn't recognize
        // the chosen resolution. Avoid that by disabling SOPS when it
        // is not streaming a supported resolution.
        enableGameOptimizations = false;
        for (const NvDisplayMode &mode : m_Computer->displayModes) {
            if (mode.width == m_StreamConfig.width &&
                    mode.height == m_StreamConfig.height) {
                SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION,
                            "Found host supported resolution: %dx%d",
                            mode.width, mode.height);
                enableGameOptimizations = m_Preferences->gameOptimizations;
                break;
            }
        }
    }
    else {
        // Always send SOPS to Sunshine because we may repurpose the
        // option to control whether the display mode is adjusted
        enableGameOptimizations = m_Preferences->gameOptimizations;
    }
```
**File:** app/streaming/session.cpp (L1586-1586)
```cpp
        http.startApp(m_Computer->currentGameId != 0 ? "resume" : "launch",
```
**File:** app/streaming/session.cpp (L1602-1607)
```cpp
    QByteArray hostnameStr = m_Computer->activeAddress.address().toLatin1();
    QByteArray siAppVersion = m_Computer->appVersion.toLatin1();

    SERVER_INFORMATION hostInfo;
    hostInfo.address = hostnameStr.data();
    hostInfo.serverInfoAppVersion = siAppVersion.data();
```
**File:** app/streaming/session.cpp (L1608-1608)
```cpp
    hostInfo.serverCodecModeSupport = m_Computer->serverCodecModeSupport;
```
**File:** app/streaming/session.cpp (L1611-1617)
```cpp
    QByteArray siGfeVersion;
    if (!m_Computer->gfeVersion.isEmpty()) {
        siGfeVersion = m_Computer->gfeVersion.toLatin1();
    }
    if (!siGfeVersion.isEmpty()) {
        hostInfo.serverInfoGfeVersion = siGfeVersion.data();
    }
```
**File:** app/backend/nvhttp.cpp (L112-116)
```cpp
    QString serverState = getXmlString(serverInfo, "state");
    if (serverState != nullptr && serverState.endsWith("_SERVER_BUSY"))
    {
        return getXmlString(serverInfo, "currentgame").toInt();
    }
```
**File:** app/backend/nvhttp.cpp (L173-177)
```cpp
        uint16_t httpsPort = getXmlString(serverInfo, "HttpsPort").toUShort();
        if (httpsPort == 0) {
            httpsPort = DEFAULT_HTTPS_PORT;
        }
        setHttpsPort(httpsPort);
```
## Q5
When I call the /launch interface, the server requires me to provide a client certificate. How can I obtain this certificate?
### Answer
Moonlight obtains and provides client certificates through a multi-step process involving certificate generation, pairing, and SSL configuration:

## Client Certificate Generation

When Moonlight first launches, the `IdentityManager` class automatically generates a self-signed 2048-bit RSA certificate and private key pair if none exist. moonlight-qt:29-110 

These credentials are stored persistently in QSettings and cached in memory for reuse. moonlight-qt:112-139 

## Attaching Certificates to Requests

For every HTTPS request (including `/launch`), Moonlight attaches the client certificate through the `IdentityManager::getSslConfig()` method, which returns a `QSslConfiguration` containing both the client certificate and private key. moonlight-qt:184-191 

This SSL configuration is applied to all network requests in the `openConnection` method via `request.setSslConfiguration()`. moonlight-qt:486-489 

## The `/launch` Interface Specifically

When the `startApp` method is called to launch a game, it makes an HTTPS request to the `/launch` endpoint using the base HTTPS URL. moonlight-qt:205-228 

This request goes through `openConnection`, which automatically includes the client certificate for mutual TLS authentication with the host server.

## Pairing Process for Mutual Trust

Before the client certificate can be used for authentication, a pairing process must occur. During pairing, the client sends its certificate to the server and receives the server's certificate in return. moonlight-qt:217-248 

The server certificate is then pinned and stored in the `NvComputer` object for future SSL validation. moonlight-qt:419-439 

## Certificate Validation

If there's an SSL handshake failure or certificate mismatch (error 401), Moonlight falls back to HTTP and can re-initiate pairing to obtain updated certificates. moonlight-qt:143-160 

## Notes

- The client certificate uses a common name of "NVIDIA GameStream Client" moonlight-qt:70-74 
- The certificate has a 20-year validity period moonlight-qt:51-66 
- The `/launch` endpoint uses a 120-second timeout compared to the standard 5-second timeout for other requests moonlight-qt:15-19 
- Certificate pinning prevents man-in-the-middle attacks by ensuring SSL errors are only ignored if they match the previously paired server certificate moonlight-qt:429-434
### Citations
**File:** app/backend/identitymanager.cpp (L29-110)
```cpp
void IdentityManager::createCredentials(QSettings& settings)
{
    X509* cert = X509_new();
    THROW_BAD_ALLOC_IF_NULL(cert);

    EVP_PKEY_CTX* ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_RSA, NULL);
    THROW_BAD_ALLOC_IF_NULL(ctx);

    EVP_PKEY_keygen_init(ctx);
    EVP_PKEY_CTX_set_rsa_keygen_bits(ctx, 2048);

    // pk must be initialized on input
    EVP_PKEY* pk = NULL;
    EVP_PKEY_keygen(ctx, &pk);

    EVP_PKEY_CTX_free(ctx);
    THROW_BAD_ALLOC_IF_NULL(pk);

    X509_set_version(cert, 2);
    ASN1_INTEGER_set(X509_get_serialNumber(cert), 0);
#if OPENSSL_VERSION_NUMBER < 0x10100000L
    X509_gmtime_adj(X509_get_notBefore(cert), 0);
    X509_gmtime_adj(X509_get_notAfter(cert), 60 * 60 * 24 * 365 * 20); // 20 yrs
#else
    ASN1_TIME* before = ASN1_STRING_dup(X509_get0_notBefore(cert));
    THROW_BAD_ALLOC_IF_NULL(before);
    ASN1_TIME* after = ASN1_STRING_dup(X509_get0_notAfter(cert));
    THROW_BAD_ALLOC_IF_NULL(after);

    X509_gmtime_adj(before, 0);
    X509_gmtime_adj(after, 60 * 60 * 24 * 365 * 20); // 20 yrs

    X509_set1_notBefore(cert, before);
    X509_set1_notAfter(cert, after);

    ASN1_STRING_free(before);
    ASN1_STRING_free(after);
#endif

    X509_set_pubkey(cert, pk);

    X509_NAME* name = X509_get_subject_name(cert);
    X509_NAME_add_entry_by_txt(name, "CN", MBSTRING_ASC,
                               reinterpret_cast<unsigned char *>(const_cast<char*>("NVIDIA GameStream Client")),
                               -1, -1, 0);
    X509_set_issuer_name(cert, name);

    X509_sign(cert, pk, EVP_sha256());

    BIO* biokey = BIO_new(BIO_s_mem());
    THROW_BAD_ALLOC_IF_NULL(biokey);
    PEM_write_bio_PrivateKey(biokey, pk, NULL, NULL, 0, NULL, NULL);

    BIO* biocert = BIO_new(BIO_s_mem());
    THROW_BAD_ALLOC_IF_NULL(biocert);
    PEM_write_bio_X509(biocert, cert);

    BUF_MEM* mem;
    BIO_get_mem_ptr(biokey, &mem);
    m_CachedPrivateKey = QByteArray(mem->data, (int)mem->length);

    BIO_get_mem_ptr(biocert, &mem);
    m_CachedPemCert = QByteArray(mem->data, (int)mem->length);

    X509_free(cert);
    EVP_PKEY_free(pk);
    BIO_free(biokey);
    BIO_free(biocert);

    // Check that the new keypair is valid before persisting it
    if (getSslCertificate().isNull()) {
        qFatal("Newly generated certificate is unreadable");
    }
    if (getSslKey().isNull()) {
        qFatal("Newly generated private key is unreadable");
    }

    settings.setValue(SER_CERT, m_CachedPemCert);
    settings.setValue(SER_KEY, m_CachedPrivateKey);

    qInfo() << "Wrote new identity credentials to settings";
}
```
**File:** app/backend/identitymanager.cpp (L112-139)
```cpp
IdentityManager::IdentityManager()
{
    QSettings settings;

    m_CachedPemCert = settings.value(SER_CERT).toByteArray();
    m_CachedPrivateKey = settings.value(SER_KEY).toByteArray();

    if (m_CachedPemCert.isEmpty() || m_CachedPrivateKey.isEmpty()) {
        qInfo() << "No existing credentials found";
        createCredentials(settings);
    }
    else if (getSslCertificate().isNull()) {
        qWarning() << "Certificate is unreadable";
        createCredentials(settings);
    }
    else if (getSslKey().isNull()) {
        qWarning() << "Private key is unreadable";
        createCredentials(settings);
    }

    // We should have valid credentials now. If not, we're screwed
    if (getSslCertificate().isNull()) {
        qFatal("Certificate is unreadable");
    }
    if (getSslKey().isNull()) {
        qFatal("Private key is unreadable");
    }
}
```
**File:** app/backend/identitymanager.cpp (L184-191)
```cpp
QSslConfiguration
IdentityManager::getSslConfig()
{
    QSslConfiguration sslConfig(QSslConfiguration::defaultConfiguration());
    sslConfig.setLocalCertificate(getSslCertificate());
    sslConfig.setPrivateKey(getSslKey());
    return sslConfig;
}
```
**File:** app/backend/nvhttp.cpp (L15-19)
```cpp
#define FAST_FAIL_TIMEOUT_MS 2000
#define REQUEST_TIMEOUT_MS 5000
#define LAUNCH_TIMEOUT_MS 120000
#define RESUME_TIMEOUT_MS 30000
#define QUIT_TIMEOUT_MS 30000
```
**File:** app/backend/nvhttp.cpp (L143-160)
```cpp
        catch (const GfeHttpResponseException& e)
        {
            if (e.getStatusCode() == 401)
            {
                // Certificate validation error, fallback to HTTP
                serverInfo = openConnectionToString(m_BaseUrlHttp,
                                                    "serverinfo",
                                                    nullptr,
                                                    fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                                    logLevel);
                verifyResponseStatus(serverInfo);
            }
            else
            {
                // Rethrow real errors
                throw e;
            }
        }
```
**File:** app/backend/nvhttp.cpp (L205-228)
```cpp
    QString response =
            openConnectionToString(m_BaseUrlHttps,
                                   verb,
                                   "appid="+QString::number(appId)+
                                   "&mode="+QString::number(streamConfig->width)+"x"+
                                   QString::number(streamConfig->height)+"x"+
                                   // Using an FPS value over 60 causes SOPS to default to 720p60,
                                   // so force it to 0 to ensure the correct resolution is set. We
                                   // used to use 60 here but that locked the frame rate to 60 FPS
                                   // on GFE 3.20.3. We don't need this hack for Sunshine.
                                   QString::number((streamConfig->fps > 60 && isGfe) ? 0 : streamConfig->fps)+
                                   "&additionalStates=1&sops="+QString::number(sops ? 1 : 0)+
                                   "&rikey="+QByteArray(streamConfig->remoteInputAesKey, sizeof(streamConfig->remoteInputAesKey)).toHex()+
                                   "&rikeyid="+QString::number(riKeyId)+
                                   ((streamConfig->supportedVideoFormats & VIDEO_FORMAT_MASK_10BIT) ?
                                       "&hdrMode=1&clientHdrCapVersion=0&clientHdrCapSupportedFlagsInUint32=0&clientHdrCapMetaDataId=NV_STATIC_METADATA_TYPE_1&clientHdrCapDisplayData=0x0x0x0x0x0x0x0x0x0x0" :
                                        "")+
                                   "&localAudioPlayMode="+QString::number(localAudio ? 1 : 0)+
                                   "&surroundAudioInfo="+QString::number(SURROUNDAUDIOINFO_FROM_AUDIO_CONFIGURATION(streamConfig->audioConfiguration))+
                                   "&remoteControllersBitmap="+QString::number(gamepadMask)+
                                   "&gcmap="+QString::number(gamepadMask)+
                                   "&gcpersist="+QString::number(persistGameControllersOnDisconnect ? 1 : 0)+
                                   LiGetLaunchUrlQueryParameters(),
                                   LAUNCH_TIMEOUT_MS);
```
**File:** app/backend/nvhttp.cpp (L419-439)
```cpp
void NvHTTP::handleSslErrors(QNetworkReply* reply, const QList<QSslError>& errors)
{
    bool ignoreErrors = true;

    if (m_ServerCert.isNull()) {
        // We should never make an HTTPS request without a cert
        Q_ASSERT(!m_ServerCert.isNull());
        return;
    }

    for (const QSslError& error : errors) {
        if (m_ServerCert != error.certificate()) {
            ignoreErrors = false;
            break;
        }
    }

    if (ignoreErrors) {
        reply->ignoreSslErrors(errors);
    }
}
```
**File:** app/backend/nvhttp.cpp (L486-489)
```cpp
    QNetworkRequest request(url);

    // Add our client certificate
    request.setSslConfiguration(IdentityManager::get()->getSslConfig());
```
**File:** app/backend/nvpairingmanager.cpp (L217-248)
```cpp
    QString getCert = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&phrase=getservercert&salt=" +
                                                    salt.toHex() + "&clientcert=" + IdentityManager::get()->getCertificate().toHex(),
                                                    0);
    NvHTTP::verifyResponseStatus(getCert);
    if (NvHTTP::getXmlString(getCert, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #1";
        return PairState::FAILED;
    }

    QByteArray serverCertStr = NvHTTP::getXmlStringFromHex(getCert, "plaincert");
    if (serverCertStr == nullptr)
    {
        qCritical() << "Server likely already pairing";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::ALREADY_IN_PROGRESS;
    }

    QSslCertificate unverifiedServerCert = QSslCertificate(serverCertStr);
    if (unverifiedServerCert.isNull()) {
        Q_ASSERT(!unverifiedServerCert.isNull());

        qCritical() << "Failed to parse plaincert";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    // Pin this cert for TLS until pairing is complete. If successful, we will propagate
    // the cert into the NvComputer object and persist it.
    m_Http.setServerCert(unverifiedServerCert);
```
## Q6
How to pair up computer?
### Answer
The pairing process in Moonlight uses a 5-phase handshake protocol to securely exchange certificates between the client and server. Here's how it works:

## Client Certificate Generation and Storage

The client certificate is a self-signed X.509 certificate that is generated when Moonlight first runs. It uses a 2048-bit RSA key pair with SHA-256 signature and has a 20-year validity period. moonlight-qt:29-110 

The certificate and private key are stored in QSettings and cached in memory for subsequent use. moonlight-qt:112-139 

## The 5-Phase Pairing Process

The pairing process is implemented in the `NvPairingManager::pair()` method: moonlight-qt:191-354 

### Phase 1: Certificate Exchange

The client sends its certificate to the server as a hex-encoded string in the `clientcert` parameter of an HTTP request. At the same time, it receives the server's certificate in the response: moonlight-qt:217-227 

The server returns its certificate in the `plaincert` field of the XML response: moonlight-qt:229-244 

### Phase 2-5: Challenge-Response Authentication

Once the server certificate is received, it is immediately pinned to the HTTP client for all subsequent HTTPS requests: moonlight-qt:246-248 

The remaining phases involve encrypted challenge-response exchanges and signature verification to authenticate both parties and validate the PIN.

## Certificate Pinning

The `setServerCert()` method stores the server certificate for use in HTTPS connections: moonlight-qt:43-46 

During HTTPS connections, the `handleSslErrors()` method verifies that the server certificate matches the pinned certificate, preventing man-in-the-middle attacks: moonlight-qt:419-439 

## Persisting the Server Certificate

After successful pairing, the server certificate is stored in the `NvComputer` object: moonlight-qt:113-113 

The certificate is then persisted to settings by calling `saveHost()`: moonlight-qt:599-603 

## Notes

The pairing process uses AES-128-ECB encryption for challenge exchanges, with the encryption key derived from a salted PIN hash (SHA-256 for Gen 7+ servers, SHA-1 for older versions). The client certificate is sent as plain hex-encoded PEM data in Phase 1, while the server certificate is also returned as hex-encoded PEM. This certificate exchange happens over HTTP initially, but all subsequent pairing phases use HTTPS with the newly pinned certificate to ensure secure communication.
### Citations
**File:** app/backend/identitymanager.cpp (L29-110)
```cpp
void IdentityManager::createCredentials(QSettings& settings)
{
    X509* cert = X509_new();
    THROW_BAD_ALLOC_IF_NULL(cert);

    EVP_PKEY_CTX* ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_RSA, NULL);
    THROW_BAD_ALLOC_IF_NULL(ctx);

    EVP_PKEY_keygen_init(ctx);
    EVP_PKEY_CTX_set_rsa_keygen_bits(ctx, 2048);

    // pk must be initialized on input
    EVP_PKEY* pk = NULL;
    EVP_PKEY_keygen(ctx, &pk);

    EVP_PKEY_CTX_free(ctx);
    THROW_BAD_ALLOC_IF_NULL(pk);

    X509_set_version(cert, 2);
    ASN1_INTEGER_set(X509_get_serialNumber(cert), 0);
#if OPENSSL_VERSION_NUMBER < 0x10100000L
    X509_gmtime_adj(X509_get_notBefore(cert), 0);
    X509_gmtime_adj(X509_get_notAfter(cert), 60 * 60 * 24 * 365 * 20); // 20 yrs
#else
    ASN1_TIME* before = ASN1_STRING_dup(X509_get0_notBefore(cert));
    THROW_BAD_ALLOC_IF_NULL(before);
    ASN1_TIME* after = ASN1_STRING_dup(X509_get0_notAfter(cert));
    THROW_BAD_ALLOC_IF_NULL(after);

    X509_gmtime_adj(before, 0);
    X509_gmtime_adj(after, 60 * 60 * 24 * 365 * 20); // 20 yrs

    X509_set1_notBefore(cert, before);
    X509_set1_notAfter(cert, after);

    ASN1_STRING_free(before);
    ASN1_STRING_free(after);
#endif

    X509_set_pubkey(cert, pk);

    X509_NAME* name = X509_get_subject_name(cert);
    X509_NAME_add_entry_by_txt(name, "CN", MBSTRING_ASC,
                               reinterpret_cast<unsigned char *>(const_cast<char*>("NVIDIA GameStream Client")),
                               -1, -1, 0);
    X509_set_issuer_name(cert, name);

    X509_sign(cert, pk, EVP_sha256());

    BIO* biokey = BIO_new(BIO_s_mem());
    THROW_BAD_ALLOC_IF_NULL(biokey);
    PEM_write_bio_PrivateKey(biokey, pk, NULL, NULL, 0, NULL, NULL);

    BIO* biocert = BIO_new(BIO_s_mem());
    THROW_BAD_ALLOC_IF_NULL(biocert);
    PEM_write_bio_X509(biocert, cert);

    BUF_MEM* mem;
    BIO_get_mem_ptr(biokey, &mem);
    m_CachedPrivateKey = QByteArray(mem->data, (int)mem->length);

    BIO_get_mem_ptr(biocert, &mem);
    m_CachedPemCert = QByteArray(mem->data, (int)mem->length);

    X509_free(cert);
    EVP_PKEY_free(pk);
    BIO_free(biokey);
    BIO_free(biocert);

    // Check that the new keypair is valid before persisting it
    if (getSslCertificate().isNull()) {
        qFatal("Newly generated certificate is unreadable");
    }
    if (getSslKey().isNull()) {
        qFatal("Newly generated private key is unreadable");
    }

    settings.setValue(SER_CERT, m_CachedPemCert);
    settings.setValue(SER_KEY, m_CachedPrivateKey);

    qInfo() << "Wrote new identity credentials to settings";
}
```
**File:** app/backend/identitymanager.cpp (L112-139)
```cpp
IdentityManager::IdentityManager()
{
    QSettings settings;

    m_CachedPemCert = settings.value(SER_CERT).toByteArray();
    m_CachedPrivateKey = settings.value(SER_KEY).toByteArray();

    if (m_CachedPemCert.isEmpty() || m_CachedPrivateKey.isEmpty()) {
        qInfo() << "No existing credentials found";
        createCredentials(settings);
    }
    else if (getSslCertificate().isNull()) {
        qWarning() << "Certificate is unreadable";
        createCredentials(settings);
    }
    else if (getSslKey().isNull()) {
        qWarning() << "Private key is unreadable";
        createCredentials(settings);
    }

    // We should have valid credentials now. If not, we're screwed
    if (getSslCertificate().isNull()) {
        qFatal("Certificate is unreadable");
    }
    if (getSslKey().isNull()) {
        qFatal("Private key is unreadable");
    }
}
```
**File:** app/backend/nvpairingmanager.cpp (L191-354)
```cpp
NvPairingManager::pair(QString appVersion, QString pin, QSslCertificate& serverCert)
{
    int serverMajorVersion = NvHTTP::parseQuad(appVersion).at(0);
    qInfo() << "Pairing with server generation:" << serverMajorVersion;

    QCryptographicHash::Algorithm hashAlgo;
    int hashLength;
    if (serverMajorVersion >= 7)
    {
        // Gen 7+ uses SHA-256 hashing
        hashAlgo = QCryptographicHash::Sha256;
        hashLength = 32;
    }
    else
    {
        // Prior to Gen 7 uses SHA-1 hashing
        hashAlgo = QCryptographicHash::Sha1;
        hashLength = 20;
    }

    QByteArray salt = generateRandomBytes(16);
    QByteArray saltedPin = saltPin(salt, pin);

    QByteArray aesKey = QCryptographicHash::hash(saltedPin, hashAlgo).constData();
    aesKey.truncate(16);

    QString getCert = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&phrase=getservercert&salt=" +
                                                    salt.toHex() + "&clientcert=" + IdentityManager::get()->getCertificate().toHex(),
                                                    0);
    NvHTTP::verifyResponseStatus(getCert);
    if (NvHTTP::getXmlString(getCert, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #1";
        return PairState::FAILED;
    }

    QByteArray serverCertStr = NvHTTP::getXmlStringFromHex(getCert, "plaincert");
    if (serverCertStr == nullptr)
    {
        qCritical() << "Server likely already pairing";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::ALREADY_IN_PROGRESS;
    }

    QSslCertificate unverifiedServerCert = QSslCertificate(serverCertStr);
    if (unverifiedServerCert.isNull()) {
        Q_ASSERT(!unverifiedServerCert.isNull());

        qCritical() << "Failed to parse plaincert";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    // Pin this cert for TLS until pairing is complete. If successful, we will propagate
    // the cert into the NvComputer object and persist it.
    m_Http.setServerCert(unverifiedServerCert);

    QByteArray randomChallenge = generateRandomBytes(16);
    QByteArray encryptedChallenge = encrypt(randomChallenge, aesKey);
    QString challengeXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                         "pair",
                                                         "devicename=roth&updateState=1&clientchallenge=" +
                                                         encryptedChallenge.toHex(),
                                                         REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(challengeXml);
    if (NvHTTP::getXmlString(challengeXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #2";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray challengeResponseData = decrypt(m_Http.getXmlStringFromHex(challengeXml, "challengeresponse"), aesKey);
    QByteArray clientSecretData = generateRandomBytes(16);
    QByteArray challengeResponse;
    QByteArray serverResponse(challengeResponseData.data(), hashLength);

#if (OPENSSL_VERSION_NUMBER < 0x10002000L)
    ASN1_BIT_STRING *asnSignature = m_Cert->signature;
#elif (OPENSSL_VERSION_NUMBER < 0x10100000L)
    ASN1_BIT_STRING *asnSignature;
    X509_get0_signature(&asnSignature, NULL, m_Cert);
#else
    const ASN1_BIT_STRING *asnSignature;
    X509_get0_signature(&asnSignature, NULL, m_Cert);
#endif

    challengeResponse.append(challengeResponseData.data() + hashLength, 16);
    challengeResponse.append(reinterpret_cast<char*>(asnSignature->data), asnSignature->length);
    challengeResponse.append(clientSecretData);

    QByteArray paddedHash = QCryptographicHash::hash(challengeResponse, hashAlgo);
    paddedHash.resize(32);
    QByteArray encryptedChallengeResponseHash = encrypt(paddedHash, aesKey);
    QString respXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&serverchallengeresp=" +
                                                    encryptedChallengeResponseHash.toHex(),
                                                    REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(respXml);
    if (NvHTTP::getXmlString(respXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #3";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray pairingSecret = NvHTTP::getXmlStringFromHex(respXml, "pairingsecret");
    QByteArray serverSecret = pairingSecret.left(16);
    QByteArray serverSignature = pairingSecret.mid(16);

    if (!verifySignature(serverSecret,
                         serverSignature,
                         serverCertStr))
    {
        qCritical() << "MITM detected";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray expectedResponseData;
    expectedResponseData.append(randomChallenge);
    expectedResponseData.append(getSignatureFromPemCert(serverCertStr));
    expectedResponseData.append(serverSecret);
    if (QCryptographicHash::hash(expectedResponseData, hashAlgo) != serverResponse)
    {
        qCritical() << "Incorrect PIN";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::PIN_WRONG;
    }

    QByteArray clientPairingSecret;
    clientPairingSecret.append(clientSecretData);
    clientPairingSecret.append(signMessage(clientSecretData));

    QString secretRespXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                          "pair",
                                                          "devicename=roth&updateState=1&clientpairingsecret=" +
                                                          clientPairingSecret.toHex(),
                                                          REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(secretRespXml);
    if (NvHTTP::getXmlString(secretRespXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #4";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QString pairChallengeXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttps,
                                                             "pair",
                                                             "devicename=roth&updateState=1&phrase=pairchallenge",
                                                             REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(pairChallengeXml);
    if (NvHTTP::getXmlString(pairChallengeXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #5";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    serverCert = std::move(unverifiedServerCert);
    return PairState::PAIRED;
```
**File:** app/backend/nvhttp.cpp (L43-46)
```cpp
void NvHTTP::setServerCert(QSslCertificate serverCert)
{
    m_ServerCert = serverCert;
}
```
**File:** app/backend/nvhttp.cpp (L419-439)
```cpp
void NvHTTP::handleSslErrors(QNetworkReply* reply, const QList<QSslError>& errors)
{
    bool ignoreErrors = true;

    if (m_ServerCert.isNull()) {
        // We should never make an HTTPS request without a cert
        Q_ASSERT(!m_ServerCert.isNull());
        return;
    }

    for (const QSslError& error : errors) {
        if (m_ServerCert != error.certificate()) {
            ignoreErrors = false;
            break;
        }
    }

    if (ignoreErrors) {
        reply->ignoreSslErrors(errors);
    }
}
```
**File:** app/backend/nvcomputer.h (L113-113)
```text
    QSslCertificate serverCert;
```
**File:** app/backend/computermanager.cpp (L599-603)
```cpp
           case NvPairingManager::PairState::PAIRED:
               // Persist the newly pinned server certificate for this host
               m_ComputerManager->saveHost(m_Computer);

               emit pairingCompleted(m_Computer, nullptr);
```
## Q7
When the client has launched/started the game and begun streaming before disconnecting, how does the client recover the connection?
### Answer
You're asking about how Moonlight handles connection recovery when a streaming session disconnects after it has already started.

## Answer

When a streaming session disconnects, Moonlight determines whether to call `/launch` or `/resume` based on the `currentgame` value from the host's `/serverinfo` response. moonlight-qt:1586-1586 

### Resume vs Launch Decision

In `Session::startConnectionAsync()`, the code checks if `m_Computer->currentgame` is non-zero (indicating a game is already running on the host): moonlight-qt:1556-1557 

If the game is already running, it calls `NvHTTP::startApp()` with the `"resume"` parameter instead of `"launch"`: moonlight-qt:1586-1593 

```cpp
http.startApp(m_Computer->currentgame != 0 ? "resume" : "launch",
              m_Computer->isNvidiaServerSoftware,
              m_App.id, &m_StreamConfig,
              enableGameOptimizations,
              m_Preferences->playAudioOnHost,
              m_InputHandler->getAttachedGamepadMask(),
              !m_Preferences->multiController,
              rtspSessionUrl);
```

### How Resume Works

The `/resume` endpoint tells the host to reconnect to an existing game session rather than starting a new one.<cite /> This preserves the game state and allows the client to rejoin the same streaming session.<cite />

The same connection establishment process follows after calling `/resume` - the RTSP session URL is obtained from the response and passed to `LiStartConnection()` to establish the streaming connection. moonlight-qt:1678-1680 

### State Detection

The host's state is tracked through periodic `/serverinfo` polling, which updates the `currentgame` field in the `NvComputer` object.<cite /> When the state shows `SUNSHINE_SERVER_BUSY` (as in your earlier example) with a non-zero `currentgame` value, Moonlight knows a game is already running and will use resume instead of launch.<cite />

## Notes

The resume functionality allows seamless reconnection to an existing game session without restarting the game on the host. This is particularly useful for temporary network interruptions or when the client application crashes but the host game continues running. The same certificate authentication and connection establishment process is used for both launch and resume operations.

Wiki pages you might want to explore:
- [User Interface System (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2)
- [Streaming Core (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#4)
### Citations
**File:** app/streaming/session.cpp (L1556-1557)
```cpp
    Q_ASSERT(m_Computer->currentGameId == 0 ||
             m_Computer->currentGameId == m_App.id);
```
**File:** app/streaming/session.cpp (L1586-1593)
```cpp
        http.startApp(m_Computer->currentGameId != 0 ? "resume" : "launch",
                      m_Computer->isNvidiaServerSoftware,
                      m_App.id, &m_StreamConfig,
                      enableGameOptimizations,
                      m_Preferences->playAudioOnHost,
                      m_InputHandler->getAttachedGamepadMask(),
                      !m_Preferences->multiController,
                      rtspSessionUrl);
```
**File:** app/streaming/session.cpp (L1678-1680)
```cpp
    int err = LiStartConnection(&hostInfo, &m_StreamConfig, &k_ConnCallbacks,
                                &m_VideoCallbacks, &m_AudioCallbacks,
                                NULL, 0, NULL, 0);
```
## Q8
How does the client terminate the connection?
### Answer
You're asking about how Moonlight terminates a streaming connection when the user wants to disconnect.

## Answer

Moonlight provides multiple ways to terminate a streaming connection:

### User-Initiated Disconnection

Users can disconnect from an active streaming session using keyboard shortcuts or gamepad button combinations. The UI displays a tip showing these options: **Ctrl+Alt+Shift+Q** for keyboard or **Start+Select+L1+R1** for gamepad. moonlight-qt:167-168 

### Connection Termination Flow

When a connection terminates, the `Session::clConnectionTerminated()` callback is invoked with an error code. moonlight-qt:98-155  This callback:

1. **Performs port testing** to diagnose connectivity issues if the termination was unexpected moonlight-qt:100-101 

2. **Determines if termination was graceful** - If the error code is `ML_ERROR_GRACEFUL_TERMINATION`, no error dialog is shown moonlight-qt:105-106 

3. **Displays error messages** for unexpected terminations (network issues, video encoding errors, etc.) moonlight-qt:108-144 

4. **Pushes a quit event** to the SDL event loop to exit the streaming session moonlight-qt:150-154 

### UI Cleanup After Termination

After the session ends, the `StreamSegue::sessionFinished()` method handles cleanup: moonlight-qt:73-108 

1. **Re-enables gamepad navigation** for the UI moonlight-qt:79-80 

2. **Pops the stream view** from the navigation stack to return to the previous screen moonlight-qt:93-94 

3. **Shows the main window** again moonlight-qt:96-97 

4. **Displays any error dialogs** if the termination was unexpected moonlight-qt:103-106 

The session object is then garbage collected to free resources. moonlight-qt:110-116 

### Quitting Running Apps

Moonlight can also terminate a running game on the host without streaming it. The `ComputerManager::quitRunningApp()` method creates a `PendingQuitTask` that sends a quit request to the host server. moonlight-qt:675-682  This is used when users want to stop a game remotely without connecting to it.

## Notes

The termination process distinguishes between graceful disconnections (user-initiated) and unexpected terminations (network errors, encoding failures). For unexpected terminations, Moonlight performs network diagnostics and displays helpful error messages to guide troubleshooting. The same cleanup process applies whether the user disconnects manually or the connection fails unexpectedly.

Wiki pages you might want to explore:
- [User Interface System (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2)
- [PC Discovery View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.1)
### Citations
**File:** app/gui/StreamSegue.qml (L73-108)
```text
    function sessionFinished(portTestResult)
    {
        if (portTestResult !== 0 && portTestResult !== -1 && streamSegueErrorDialog.text) {
            streamSegueErrorDialog.text += "\n\n" + qsTr("This PC's Internet connection is blocking Moonlight. Streaming over the Internet may not work while connected to this network.")
        }

        // Re-enable GUI gamepad usage now
        SdlGamepadKeyNavigation.enable()

        if (quitAfter) {
            if (streamSegueErrorDialog.text) {
                // Quit when the error dialog is acknowledged
                streamSegueErrorDialog.quitAfter = quitAfter
                streamSegueErrorDialog.open()
            }
            else {
                // Quit immediately
                Qt.quit()
            }
        } else {
            // Exit this view
            stackView.pop()

            // Show the Qt window again after streaming
            window.visible = true

            // Display any launch errors. We do this after
            // the Qt UI is visible again to prevent losing
            // focus on the dialog which would impact gamepad
            // users.
            if (streamSegueErrorDialog.text) {
                streamSegueErrorDialog.quitAfter = quitAfter
                streamSegueErrorDialog.open()
            }
        }
    }
```
**File:** app/gui/StreamSegue.qml (L110-116)
```text
    function sessionReadyForDeletion()
    {
        // Garbage collect the Session object since it's pretty heavyweight
        // and keeps other libraries (like SDL_TTF) around until it is deleted.
        session = null
        gc()
    }
```
**File:** app/gui/StreamSegue.qml (L167-168)
```text
            hintText.text = qsTr("Tip:") + " " + qsTr("Press %1 to disconnect your session").arg(SdlGamepadKeyNavigation.getConnectedGamepads() > 0 ?
                                                  qsTr("Start+Select+L1+R1") : qsTr("Ctrl+Alt+Shift+Q"))
```
**File:** app/streaming/session.cpp (L98-155)
```cpp
void Session::clConnectionTerminated(int errorCode)
{
    unsigned int portFlags = LiGetPortFlagsFromTerminationErrorCode(errorCode);
    s_ActiveSession->m_PortTestResults = LiTestClientConnectivity(CONN_TEST_SERVER, 443, portFlags);

    // Display the termination dialog if this was not intended
    switch (errorCode) {
    case ML_ERROR_GRACEFUL_TERMINATION:
        break;

    case ML_ERROR_NO_VIDEO_TRAFFIC:
        s_ActiveSession->m_UnexpectedTermination = true;

        char ports[128];
        SDL_assert(portFlags != 0);
        LiStringifyPortFlags(portFlags, ", ", ports, sizeof(ports));
        emit s_ActiveSession->displayLaunchError(tr("No video received from host.") + "\n\n"+
                                                 tr("Check your firewall and port forwarding rules for port(s): %1").arg(ports));
        break;

    case ML_ERROR_NO_VIDEO_FRAME:
        s_ActiveSession->m_UnexpectedTermination = true;
        emit s_ActiveSession->displayLaunchError(tr("Your network connection isn't performing well. Reduce your video bitrate setting or try a faster connection."));
        break;

    case ML_ERROR_PROTECTED_CONTENT:
    case ML_ERROR_UNEXPECTED_EARLY_TERMINATION:
        s_ActiveSession->m_UnexpectedTermination = true;
        emit s_ActiveSession->displayLaunchError(tr("Something went wrong on your host PC when starting the stream.") + "\n\n" +
                                                 tr("Make sure you don't have any DRM-protected content open on your host PC. You can also try restarting your host PC."));
        break;

    case ML_ERROR_FRAME_CONVERSION:
        s_ActiveSession->m_UnexpectedTermination = true;
        emit s_ActiveSession->displayLaunchError(tr("The host PC reported a fatal video encoding error.") + "\n\n" +
                                                 tr("Try disabling HDR mode, changing the streaming resolution, or changing your host PC's display resolution."));
        break;

    default:
        s_ActiveSession->m_UnexpectedTermination = true;

        // We'll assume large errors are hex values
        bool hexError = qAbs(errorCode) > 1000;
        emit s_ActiveSession->displayLaunchError(tr("Connection terminated") + "\n\n" +
                                                 tr("Error code: %1").arg(errorCode, hexError ? 8 : 0, hexError ? 16 : 10, QChar('0')));
        break;
    }

    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION,
                 "Connection terminated: %d",
                 errorCode);

    // Push a quit event to the main loop
    SDL_Event event;
    event.type = SDL_QUIT;
    event.quit.timestamp = SDL_GetTicks();
    SDL_PushEvent(&event);
}
```
**File:** app/backend/computermanager.cpp (L675-682)
```cpp
void ComputerManager::quitRunningApp(NvComputer* computer)
{
    QWriteLocker lock(&computer->lock);
    computer->pendingQuit = true;

    PendingQuitTask* quit = new PendingQuitTask(this, computer);
    QThreadPool::globalInstance()->start(quit);
}
```
## Q9
Please list all the APIs used for the client and server interaction, including their purposes and required parameters, and list the APIs needed for the entire process from adding a computer to selecting one in the app list and starting a connection to ending the connection.
### Answer
Based on my analysis of the Moonlight codebase, here are all the client-server interaction APIs used throughout the entire process:

## 1. **Adding a Computer**

### Server Discovery - `serverinfo` API
**Purpose**: Discover and retrieve information about the host PC, including pairing status, current game, server version, and HTTPS port. moonlight-qt:124-187 

**Required Parameters**:
- `uniqueid`: Common UID for Moonlight clients (fixed: "0123456789ABCDEF")
- `uuid`: Random UUID for the request

**Protocol**: HTTP initially (before pairing), then HTTPS (after pairing)

### Pairing - 5-Phase Cryptographic Handshake

**Purpose**: Establish trust between client and host PC through certificate exchange and PIN verification. moonlight-qt:191-355 

**Phase 1 - Get Server Certificate**:
- Endpoint: `pair`
- Parameters:
  - `devicename=roth`
  - `updateState=1`
  - `phrase=getservercert`
  - `salt`: 16-byte random salt (hex)
  - `clientcert`: Client certificate (hex)

**Phase 2 - Client Challenge**:
- Endpoint: `pair`
- Parameters:
  - `devicename=roth`
  - `updateState=1`
  - `clientchallenge`: Encrypted 16-byte challenge (hex)

**Phase 3 - Server Challenge Response**:
- Endpoint: `pair`
- Parameters:
  - `devicename=roth`
  - `updateState=1`
  - `serverchallengeresp`: Encrypted challenge response hash (hex)

**Phase 4 - Client Pairing Secret**:
- Endpoint: `pair`
- Parameters:
  - `devicename=roth`
  - `updateState=1`
  - `clientpairingsecret`: Client secret + signature (hex)

**Phase 5 - Final Challenge (HTTPS)**:
- Endpoint: `pair`
- Parameters:
  - `devicename=roth`
  - `updateState=1`
  - `phrase=pairchallenge`

**Protocol**: HTTP for phases 1-4, HTTPS for phase 5

## 2. **Selecting an App**

### App List - `applist` API
**Purpose**: Retrieve the list of available applications on the host PC. moonlight-qt:288-328 

**Required Parameters**:
- `uniqueid`: "0123456789ABCDEF"
- `uuid`: Random UUID

**Protocol**: HTTPS (requires prior pairing)

**Response**: XML with app information including:
- `AppTitle`: Application name
- `ID`: Application ID
- `IsHdrSupported`: HDR capability
- `IsAppCollectorGame`: Whether it's an App Collector game

### Box Art - `getBoxArt` API
**Purpose**: Download application cover art/thumbnails. moonlight-qt:178-179 moonlight-qt:107-129 

**Required Parameters**:
- `appId`: Application ID

**Protocol**: HTTPS
**Response**: Image data (various formats, cached as PNG locally)

## 3. **Starting a Streaming Connection**

### Launch/Resume - `launch` or `resume` API
**Purpose**: Start a new streaming session or resume an existing one. moonlight-qt:190-236 moonlight-qt:1582-1600 

**Endpoint**: `launch` (new session) or `resume` (existing session)

**Required Parameters**:
- `uniqueid`: "0123456789ABCDEF"
- `uuid`: Random UUID
- `appid`: Application ID to launch
- `mode`: Resolution and FPS (format: `{width}x{height}x{fps}`)
- `additionalStates=1`: Enable additional states
- `sops`: Stream optimization settings (0 or 1)
- `rikey`: Remote input AES key (hex)
- `rikeyid`: Remote input key ID
- `hdrMode`: HDR mode flag (included if HDR supported)
- `clientHdrCapVersion`, `clientHdrCapSupportedFlagsInUint32`, `clientHdrCapMetaDataId`, `clientHdrCapDisplayData`: HDR capability parameters (if HDR mode)
- `localAudioPlayMode`: Play audio on host (0 or 1)
- `surroundAudioInfo`: Surround audio configuration
- `remoteControllersBitmap`: Gamepad mask
- `gcmap`: Gamepad controller map
- `gcpersist`: Persist game controllers on disconnect (0 or 1)
- Additional parameters from `LiGetLaunchUrlQueryParameters()`

**Protocol**: HTTPS

**Response**: XML containing `sessionUrl0` (RTSP session URL)

**Decision Logic**: The verb is determined based on whether a game is currently running: moonlight-qt:1586-1593 

## 4. **Ending a Streaming Connection**

### Quit App - `cancel` API
**Purpose**: Terminate the currently running application on the host PC. moonlight-qt:238-259 

**Required Parameters**:
- `uniqueid`: "0123456789ABCDEF"
- `uuid`: Random UUID

**Protocol**: HTTPS

**Timeout**: 30 seconds

**Note**: The quit operation is optional based on user preferences: moonlight-qt:1554-1558 

## Additional APIs

### Wake-on-LAN
**Purpose**: Wake up a sleeping/powered-off host PC. moonlight-qt:1-50 

**Protocol**: UDP magic packets sent to multiple addresses and ports (9, 47009, and dynamic ports 47998-48010)

### Unpair - `unpair` API
**Purpose**: Remove pairing relationship (used during pairing failures). moonlight-qt:232-234 

**Required Parameters**: Standard uniqueid and uuid

**Protocol**: HTTP

## Notes

- All HTTP/HTTPS requests use a common `uniqueid` of "0123456789ABCDEF" to allow Moonlight clients to manage each other's sessions
- Each request includes a random `uuid` parameter generated via `QUuid::createUuid()`
- Certificate pinning is implemented for HTTPS connections to prevent MITM attacks
- Timeouts vary by operation: 2s (fast-fail), 5s (normal), 30s (resume/quit), 120s (launch)
- The base URL format is `http(s)://{host}:{port}/{command}?{parameters}`
### Citations
**File:** app/backend/nvhttp.cpp (L124-187)
```cpp
NvHTTP::getServerInfo(NvLogLevel logLevel, bool fastFail)
{
    QString serverInfo;

    // Check if we have a pinned cert and HTTPS port for this host yet
    if (!m_ServerCert.isNull() && httpsPort() != 0)
    {
        try
        {
            // Always try HTTPS first, since it properly reports
            // pairing status (and a few other attributes).
            serverInfo = openConnectionToString(m_BaseUrlHttps,
                                                "serverinfo",
                                                nullptr,
                                                fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                                logLevel);
            // Throws if the request failed
            verifyResponseStatus(serverInfo);
        }
        catch (const GfeHttpResponseException& e)
        {
            if (e.getStatusCode() == 401)
            {
                // Certificate validation error, fallback to HTTP
                serverInfo = openConnectionToString(m_BaseUrlHttp,
                                                    "serverinfo",
                                                    nullptr,
                                                    fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                                    logLevel);
                verifyResponseStatus(serverInfo);
            }
            else
            {
                // Rethrow real errors
                throw e;
            }
        }
    }
    else
    {
        // Only use HTTP prior to pairing or fetching HTTPS port
        serverInfo = openConnectionToString(m_BaseUrlHttp,
                                            "serverinfo",
                                            nullptr,
                                            fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                            logLevel);
        verifyResponseStatus(serverInfo);

        // Populate the HTTPS port
        uint16_t httpsPort = getXmlString(serverInfo, "HttpsPort").toUShort();
        if (httpsPort == 0) {
            httpsPort = DEFAULT_HTTPS_PORT;
        }
        setHttpsPort(httpsPort);

        // If we just needed to determine the HTTPS port, we'll try again over
        // HTTPS now that we have the port number
        if (!m_ServerCert.isNull()) {
            return getServerInfo(logLevel, fastFail);
        }
    }

    return serverInfo;
}
```
**File:** app/backend/nvhttp.cpp (L190-236)
```cpp
NvHTTP::startApp(QString verb,
                 bool isGfe,
                 int appId,
                 PSTREAM_CONFIGURATION streamConfig,
                 bool sops,
                 bool localAudio,
                 int gamepadMask,
                 bool persistGameControllersOnDisconnect,
                 QString& rtspSessionUrl)
{
    int riKeyId;

    memcpy(&riKeyId, streamConfig->remoteInputAesIv, sizeof(riKeyId));
    riKeyId = qFromBigEndian(riKeyId);

    QString response =
            openConnectionToString(m_BaseUrlHttps,
                                   verb,
                                   "appid="+QString::number(appId)+
                                   "&mode="+QString::number(streamConfig->width)+"x"+
                                   QString::number(streamConfig->height)+"x"+
                                   // Using an FPS value over 60 causes SOPS to default to 720p60,
                                   // so force it to 0 to ensure the correct resolution is set. We
                                   // used to use 60 here but that locked the frame rate to 60 FPS
                                   // on GFE 3.20.3. We don't need this hack for Sunshine.
                                   QString::number((streamConfig->fps > 60 && isGfe) ? 0 : streamConfig->fps)+
                                   "&additionalStates=1&sops="+QString::number(sops ? 1 : 0)+
                                   "&rikey="+QByteArray(streamConfig->remoteInputAesKey, sizeof(streamConfig->remoteInputAesKey)).toHex()+
                                   "&rikeyid="+QString::number(riKeyId)+
                                   ((streamConfig->supportedVideoFormats & VIDEO_FORMAT_MASK_10BIT) ?
                                       "&hdrMode=1&clientHdrCapVersion=0&clientHdrCapSupportedFlagsInUint32=0&clientHdrCapMetaDataId=NV_STATIC_METADATA_TYPE_1&clientHdrCapDisplayData=0x0x0x0x0x0x0x0x0x0x0" :
                                        "")+
                                   "&localAudioPlayMode="+QString::number(localAudio ? 1 : 0)+
                                   "&surroundAudioInfo="+QString::number(SURROUNDAUDIOINFO_FROM_AUDIO_CONFIGURATION(streamConfig->audioConfiguration))+
                                   "&remoteControllersBitmap="+QString::number(gamepadMask)+
                                   "&gcmap="+QString::number(gamepadMask)+
                                   "&gcpersist="+QString::number(persistGameControllersOnDisconnect ? 1 : 0)+
                                   LiGetLaunchUrlQueryParameters(),
                                   LAUNCH_TIMEOUT_MS);

    qInfo() << "Launch response:" << response;

    // Throws if the request failed
    verifyResponseStatus(response);

    rtspSessionUrl = getXmlString(response, "sessionUrl0");
}
```
**File:** app/backend/nvhttp.cpp (L238-259)
```cpp
void
NvHTTP::quitApp()
{
    QString response =
            openConnectionToString(m_BaseUrlHttps,
                                   "cancel",
                                   nullptr,
                                   QUIT_TIMEOUT_MS);

    qInfo() << "Quit response:" << response;

    // Throws if the request failed
    verifyResponseStatus(response);

    // Newer GFE versions will just return success even if quitting fails
    // if we're not the original requester.
    if (getCurrentGame(getServerInfo(NvHTTP::NVLL_ERROR)) != 0) {
        // Generate a synthetic GfeResponseException letting the caller know
        // that they can't kill someone else's stream.
        throw GfeHttpResponseException(599, "");
    }
}
```
**File:** app/backend/nvhttp.cpp (L288-328)
```cpp
QVector<NvApp>
NvHTTP::getAppList()
{
    QString appxml = openConnectionToString(m_BaseUrlHttps,
                                            "applist",
                                            nullptr,
                                            REQUEST_TIMEOUT_MS,
                                            NvLogLevel::NVLL_ERROR);
    verifyResponseStatus(appxml);

    QXmlStreamReader xmlReader(appxml);
    QVector<NvApp> apps;
    while (!xmlReader.atEnd()) {
        while (xmlReader.readNextStartElement()) {
            auto name = xmlReader.name();
            if (name == QString("App")) {
                // We must have a valid app before advancing to the next one
                if (!apps.isEmpty() && !apps.last().isInitialized()) {
                    qWarning() << "Invalid applist XML";
                    Q_ASSERT(false);
                    return QVector<NvApp>();
                }
                apps.append(NvApp());
            }
            else if (name == QString("AppTitle")) {
                apps.last().name = xmlReader.readElementText();
            }
            else if (name == QString("ID")) {
                apps.last().id = xmlReader.readElementText().toInt();
            }
            else if (name == QString("IsHdrSupported")) {
                apps.last().hdrSupported = xmlReader.readElementText() == "1";
            }
            else if (name == QString("IsAppCollectorGame")) {
                apps.last().isAppCollectorGame = xmlReader.readElementText() == "1";
            }
        }
    }

    return apps;
}
```
**File:** app/backend/nvpairingmanager.cpp (L191-355)
```cpp
NvPairingManager::pair(QString appVersion, QString pin, QSslCertificate& serverCert)
{
    int serverMajorVersion = NvHTTP::parseQuad(appVersion).at(0);
    qInfo() << "Pairing with server generation:" << serverMajorVersion;

    QCryptographicHash::Algorithm hashAlgo;
    int hashLength;
    if (serverMajorVersion >= 7)
    {
        // Gen 7+ uses SHA-256 hashing
        hashAlgo = QCryptographicHash::Sha256;
        hashLength = 32;
    }
    else
    {
        // Prior to Gen 7 uses SHA-1 hashing
        hashAlgo = QCryptographicHash::Sha1;
        hashLength = 20;
    }

    QByteArray salt = generateRandomBytes(16);
    QByteArray saltedPin = saltPin(salt, pin);

    QByteArray aesKey = QCryptographicHash::hash(saltedPin, hashAlgo).constData();
    aesKey.truncate(16);

    QString getCert = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&phrase=getservercert&salt=" +
                                                    salt.toHex() + "&clientcert=" + IdentityManager::get()->getCertificate().toHex(),
                                                    0);
    NvHTTP::verifyResponseStatus(getCert);
    if (NvHTTP::getXmlString(getCert, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #1";
        return PairState::FAILED;
    }

    QByteArray serverCertStr = NvHTTP::getXmlStringFromHex(getCert, "plaincert");
    if (serverCertStr == nullptr)
    {
        qCritical() << "Server likely already pairing";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::ALREADY_IN_PROGRESS;
    }

    QSslCertificate unverifiedServerCert = QSslCertificate(serverCertStr);
    if (unverifiedServerCert.isNull()) {
        Q_ASSERT(!unverifiedServerCert.isNull());

        qCritical() << "Failed to parse plaincert";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    // Pin this cert for TLS until pairing is complete. If successful, we will propagate
    // the cert into the NvComputer object and persist it.
    m_Http.setServerCert(unverifiedServerCert);

    QByteArray randomChallenge = generateRandomBytes(16);
    QByteArray encryptedChallenge = encrypt(randomChallenge, aesKey);
    QString challengeXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                         "pair",
                                                         "devicename=roth&updateState=1&clientchallenge=" +
                                                         encryptedChallenge.toHex(),
                                                         REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(challengeXml);
    if (NvHTTP::getXmlString(challengeXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #2";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray challengeResponseData = decrypt(m_Http.getXmlStringFromHex(challengeXml, "challengeresponse"), aesKey);
    QByteArray clientSecretData = generateRandomBytes(16);
    QByteArray challengeResponse;
    QByteArray serverResponse(challengeResponseData.data(), hashLength);

#if (OPENSSL_VERSION_NUMBER < 0x10002000L)
    ASN1_BIT_STRING *asnSignature = m_Cert->signature;
#elif (OPENSSL_VERSION_NUMBER < 0x10100000L)
    ASN1_BIT_STRING *asnSignature;
    X509_get0_signature(&asnSignature, NULL, m_Cert);
#else
    const ASN1_BIT_STRING *asnSignature;
    X509_get0_signature(&asnSignature, NULL, m_Cert);
#endif

    challengeResponse.append(challengeResponseData.data() + hashLength, 16);
    challengeResponse.append(reinterpret_cast<char*>(asnSignature->data), asnSignature->length);
    challengeResponse.append(clientSecretData);

    QByteArray paddedHash = QCryptographicHash::hash(challengeResponse, hashAlgo);
    paddedHash.resize(32);
    QByteArray encryptedChallengeResponseHash = encrypt(paddedHash, aesKey);
    QString respXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&serverchallengeresp=" +
                                                    encryptedChallengeResponseHash.toHex(),
                                                    REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(respXml);
    if (NvHTTP::getXmlString(respXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #3";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray pairingSecret = NvHTTP::getXmlStringFromHex(respXml, "pairingsecret");
    QByteArray serverSecret = pairingSecret.left(16);
    QByteArray serverSignature = pairingSecret.mid(16);

    if (!verifySignature(serverSecret,
                         serverSignature,
                         serverCertStr))
    {
        qCritical() << "MITM detected";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray expectedResponseData;
    expectedResponseData.append(randomChallenge);
    expectedResponseData.append(getSignatureFromPemCert(serverCertStr));
    expectedResponseData.append(serverSecret);
    if (QCryptographicHash::hash(expectedResponseData, hashAlgo) != serverResponse)
    {
        qCritical() << "Incorrect PIN";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::PIN_WRONG;
    }

    QByteArray clientPairingSecret;
    clientPairingSecret.append(clientSecretData);
    clientPairingSecret.append(signMessage(clientSecretData));

    QString secretRespXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                          "pair",
                                                          "devicename=roth&updateState=1&clientpairingsecret=" +
                                                          clientPairingSecret.toHex(),
                                                          REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(secretRespXml);
    if (NvHTTP::getXmlString(secretRespXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #4";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QString pairChallengeXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttps,
                                                             "pair",
                                                             "devicename=roth&updateState=1&phrase=pairchallenge",
                                                             REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(pairChallengeXml);
    if (NvHTTP::getXmlString(pairChallengeXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #5";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    serverCert = std::move(unverifiedServerCert);
    return PairState::PAIRED;
}
```
**File:** app/backend/nvhttp.h (L178-179)
```text
    QImage
    getBoxArt(int appId);
```
**File:** app/backend/boxartmanager.cpp (L107-129)
```cpp
QUrl BoxArtManager::loadBoxArtFromNetwork(NvComputer* computer, int appId)
{
    NvHTTP http(computer);

    QString cachePath = getFilePathForBoxArt(computer, appId);
    QImage image;
    try {
        image = http.getBoxArt(appId);
    } catch (...) {}

    // Cache the box art on disk if it loaded
    if (!image.isNull()) {
        if (image.save(cachePath)) {
            return QUrl::fromLocalFile(cachePath);
        }
        else {
            // A failed save() may leave a zero byte file. Make sure that's removed.
            QFile(cachePath).remove();
        }
    }

    return QUrl();
}
```
**File:** app/streaming/session.cpp (L1554-1558)
```cpp
    // The UI should have ensured the old game was already quit
    // if we decide to stream a different game.
    Q_ASSERT(m_Computer->currentGameId == 0 ||
             m_Computer->currentGameId == m_App.id);

```
**File:** app/streaming/session.cpp (L1582-1600)
```cpp
    QString rtspSessionUrl;

    try {
        NvHTTP http(m_Computer);
        http.startApp(m_Computer->currentGameId != 0 ? "resume" : "launch",
                      m_Computer->isNvidiaServerSoftware,
                      m_App.id, &m_StreamConfig,
                      enableGameOptimizations,
                      m_Preferences->playAudioOnHost,
                      m_InputHandler->getAttachedGamepadMask(),
                      !m_Preferences->multiController,
                      rtspSessionUrl);
    } catch (const GfeHttpResponseException& e) {
        emit displayLaunchError(tr("Host returned error: %1").arg(e.toQString()));
        return false;
    } catch (const QtNetworkReplyException& e) {
        emit displayLaunchError(e.toQString());
        return false;
    }
```
**File:** app/backend/nvcomputer.cpp (L1-50)
```cpp
#include "nvcomputer.h"
#include "nvapp.h"
#include "settings/compatfetcher.h"

#include <QUdpSocket>
#include <QHostInfo>
#include <QNetworkInterface>
#include <QNetworkProxy>

#define SER_NAME "hostname"
#define SER_UUID "uuid"
#define SER_MAC "mac"
#define SER_LOCALADDR "localaddress"
#define SER_LOCALPORT "localport"
#define SER_REMOTEADDR "remoteaddress"
#define SER_REMOTEPORT "remoteport"
#define SER_MANUALADDR "manualaddress"
#define SER_MANUALPORT "manualport"
#define SER_IPV6ADDR "ipv6address"
#define SER_IPV6PORT "ipv6port"
#define SER_APPLIST "apps"
#define SER_SRVCERT "srvcert"
#define SER_CUSTOMNAME "customname"
#define SER_NVIDIASOFTWARE "nvidiasw"

NvComputer::NvComputer(QSettings& settings)
{
    this->name = settings.value(SER_NAME).toString();
    this->uuid = settings.value(SER_UUID).toString();
    this->hasCustomName = settings.value(SER_CUSTOMNAME).toBool();
    this->macAddress = settings.value(SER_MAC).toByteArray();
    this->localAddress = NvAddress(settings.value(SER_LOCALADDR).toString(),
                                   settings.value(SER_LOCALPORT, QVariant(DEFAULT_HTTP_PORT)).toUInt());
    this->remoteAddress = NvAddress(settings.value(SER_REMOTEADDR).toString(),
                                    settings.value(SER_REMOTEPORT, QVariant(DEFAULT_HTTP_PORT)).toUInt());
    this->ipv6Address = NvAddress(settings.value(SER_IPV6ADDR).toString(),
                                  settings.value(SER_IPV6PORT, QVariant(DEFAULT_HTTP_PORT)).toUInt());
    this->manualAddress = NvAddress(settings.value(SER_MANUALADDR).toString(),
                                    settings.value(SER_MANUALPORT, QVariant(DEFAULT_HTTP_PORT)).toUInt());
    this->serverCert = QSslCertificate(settings.value(SER_SRVCERT).toByteArray());
    this->isNvidiaServerSoftware = settings.value(SER_NVIDIASOFTWARE).toBool();

    int appCount = settings.beginReadArray(SER_APPLIST);
    this->appList.reserve(appCount);
    for (int i = 0; i < appCount; i++) {
        settings.setArrayIndex(i);

        NvApp app(settings);
        this->appList.append(app);
    }
```
## Q10
The server completes the pairing by inputting the PIN code displayed by the client. How does the client wait for the server's response to complete the pairing during the time the PIN code is generated and the user inputs the PIN on the server side?
### Answer
You're asking about how the Moonlight client waits for the server to complete pairing after displaying the PIN code to the user.

## Answer

The client doesn't actively poll or wait for the server's response during pairing. Instead, the pairing process is **synchronous and blocking** - the client sends requests sequentially through all 5 phases and waits for each response before proceeding to the next phase.

### Pairing Execution Flow

When the user clicks on an unpaired PC, the client generates a PIN and displays it in a dialog: moonlight-qt:239-246 

The pairing task runs in a background thread via `PendingPairingTask`: moonlight-qt:564-582 

### The Blocking Nature of Pairing

Inside `NvPairingManager::pair()`, each phase makes an HTTP/HTTPS request and **blocks waiting for the response** before proceeding: moonlight-qt:217-227 

The server validates the PIN during Phase 3 (server challenge response). If the user hasn't entered the PIN yet on the server side, the server simply doesn't respond or returns an error, causing the pairing to fail: moonlight-qt:287-298 

### PIN Validation

The PIN validation happens when the client sends the encrypted challenge response hash in Phase 3. The server decrypts this using the PIN-derived key and verifies it matches the expected value: moonlight-qt:313-322 

If the PIN is incorrect (user entered wrong PIN on server), the server returns a response that causes the client to detect `PIN_WRONG` state: moonlight-qt:585-586 

### UI Feedback

While pairing is in progress, the dialog remains open showing the PIN: moonlight-qt:302-310 

When pairing completes (successfully or with error), the `pairingCompleted` signal is emitted, which closes the dialog: moonlight-qt:47-58 

## Notes

The pairing process uses HTTP request timeouts (defined as `REQUEST_TIMEOUT_MS`) to prevent indefinite waiting. If the user takes too long to enter the PIN on the server, the HTTP request will timeout and pairing will fail. The client doesn't implement any retry logic or polling mechanism - it's a single synchronous attempt that either succeeds or fails based on the server's responses to the 5-phase handshake.

Wiki pages you might want to explore:
- [User Interface System (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2)
- [PC Discovery View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.1)
### Citations
**File:** app/gui/PcView.qml (L47-58)
```text
    function pairingComplete(error)
    {
        // Close the PIN dialog
        pairDialog.close()

        // Display a failed dialog if we got an error
        if (error !== undefined) {
            errorDialog.text = error
            errorDialog.helpText = ""
            errorDialog.open()
        }
    }
```
**File:** app/gui/PcView.qml (L239-246)
```text
                    var pin = computerModel.generatePinString()

                    // Kick off pairing in the background
                    computerModel.pairComputer(index, pin)

                    // Display the pairing dialog
                    pairDialog.pin = pin
                    pairDialog.open()
```
**File:** app/gui/PcView.qml (L302-310)
```text
        // don't allow edits to the rest of the window while open
        property string pin : "0000"
        text:qsTr("Please enter %1 on your host PC. This dialog will close when pairing is completed.").arg(pin)+"\n\n"+
             qsTr("If your host PC is running Sunshine, navigate to the Sunshine web UI to enter the PIN.")
        standardButtons: Dialog.Cancel
        onRejected: {
            // FIXME: We should interrupt pairing here
        }
    }
```
**File:** app/backend/computermanager.cpp (L564-582)
```cpp
    PendingPairingTask(ComputerManager* computerManager, NvComputer* computer, QString pin)
        : m_ComputerManager(computerManager),
          m_Computer(computer),
          m_Pin(pin)
    {
        connect(this, &PendingPairingTask::pairingCompleted,
                computerManager, &ComputerManager::pairingCompleted);
    }

signals:
    void pairingCompleted(NvComputer* computer, QString error);

private:
    void run()
    {
        NvPairingManager pairingManager(m_Computer);

        try {
           NvPairingManager::PairState result = pairingManager.pair(m_Computer->appVersion, m_Pin, m_Computer->serverCert);
```
**File:** app/backend/computermanager.cpp (L585-586)
```cpp
           case NvPairingManager::PairState::PIN_WRONG:
               emit pairingCompleted(m_Computer, tr("The PIN from the PC didn't match. Please try again."));
```
**File:** app/backend/nvpairingmanager.cpp (L217-227)
```cpp
    QString getCert = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&phrase=getservercert&salt=" +
                                                    salt.toHex() + "&clientcert=" + IdentityManager::get()->getCertificate().toHex(),
                                                    0);
    NvHTTP::verifyResponseStatus(getCert);
    if (NvHTTP::getXmlString(getCert, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #1";
        return PairState::FAILED;
    }
```
**File:** app/backend/nvpairingmanager.cpp (L287-298)
```cpp
    QString respXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&serverchallengeresp=" +
                                                    encryptedChallengeResponseHash.toHex(),
                                                    REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(respXml);
    if (NvHTTP::getXmlString(respXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #3";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }
```
**File:** app/backend/nvpairingmanager.cpp (L313-322)
```cpp
    QByteArray expectedResponseData;
    expectedResponseData.append(randomChallenge);
    expectedResponseData.append(getSignatureFromPemCert(serverCertStr));
    expectedResponseData.append(serverSecret);
    if (QCryptographicHash::hash(expectedResponseData, hashAlgo) != serverResponse)
    {
        qCritical() << "Incorrect PIN";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::PIN_WRONG;
    }
```
# DeepWiki Q&A with Code Context for Repository: moonlight-stream/moonlight-qt
## Q1
how to get /launch and /serverinfo info from server?
### Answer
Based on the code context, you're asking about how Moonlight retrieves `/launch` and `/serverinfo` information from the host server.

## Answer

Moonlight uses the `NvHTTP` class to communicate with the host server and retrieve information through HTTP/HTTPS endpoints. moonlight-qt:124-187 

### Getting `/serverinfo`

The `NvHTTP::getServerInfo()` method fetches server information: moonlight-qt:124-140 

The method first attempts to use HTTPS if a pinned certificate is available, then falls back to HTTP if needed. moonlight-qt:143-160  If no certificate exists yet, it uses HTTP initially to fetch the HTTPS port, then retries over HTTPS. moonlight-qt:162-183 

This is called during PC discovery when adding a new host: moonlight-qt:809-818 

The response is then used to create or update an `NvComputer` object: moonlight-qt:820-821 

### Getting `/launch` info

The `/launch` endpoint is called via `NvHTTP::startApp()` when starting a streaming session: moonlight-qt:1585-1593 

This happens in `Session::startConnectionAsync()` after the user selects an app to stream. moonlight-qt:1548-1600  The method passes streaming configuration parameters and receives back an RTSP session URL that's used to establish the actual streaming connection. moonlight-qt:1582-1593 

## Notes

The `NvHTTP` class handles all HTTP/HTTPS communication with the host server, including certificate pinning for security. The `/serverinfo` endpoint is polled regularly to monitor PC status, while `/launch` (or `/resume`) is only called when initiating a streaming session. Both endpoints use the base URL constructed from the host's address and appropriate port (HTTP 47989 or HTTPS 47984 by default).

Wiki pages you might want to explore:
- [User Interface System (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2)
- [PC Discovery View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.1)
### Citations
**File:** app/backend/nvhttp.cpp (L124-187)
```cpp
NvHTTP::getServerInfo(NvLogLevel logLevel, bool fastFail)
{
    QString serverInfo;

    // Check if we have a pinned cert and HTTPS port for this host yet
    if (!m_ServerCert.isNull() && httpsPort() != 0)
    {
        try
        {
            // Always try HTTPS first, since it properly reports
            // pairing status (and a few other attributes).
            serverInfo = openConnectionToString(m_BaseUrlHttps,
                                                "serverinfo",
                                                nullptr,
                                                fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                                logLevel);
            // Throws if the request failed
            verifyResponseStatus(serverInfo);
        }
        catch (const GfeHttpResponseException& e)
        {
            if (e.getStatusCode() == 401)
            {
                // Certificate validation error, fallback to HTTP
                serverInfo = openConnectionToString(m_BaseUrlHttp,
                                                    "serverinfo",
                                                    nullptr,
                                                    fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                                    logLevel);
                verifyResponseStatus(serverInfo);
            }
            else
            {
                // Rethrow real errors
                throw e;
            }
        }
    }
    else
    {
        // Only use HTTP prior to pairing or fetching HTTPS port
        serverInfo = openConnectionToString(m_BaseUrlHttp,
                                            "serverinfo",
                                            nullptr,
                                            fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                            logLevel);
        verifyResponseStatus(serverInfo);

        // Populate the HTTPS port
        uint16_t httpsPort = getXmlString(serverInfo, "HttpsPort").toUShort();
        if (httpsPort == 0) {
            httpsPort = DEFAULT_HTTPS_PORT;
        }
        setHttpsPort(httpsPort);

        // If we just needed to determine the HTTPS port, we'll try again over
        // HTTPS now that we have the port number
        if (!m_ServerCert.isNull()) {
            return getServerInfo(logLevel, fastFail);
        }
    }

    return serverInfo;
}
```
**File:** app/backend/computermanager.cpp (L809-818)
```cpp
        // Perform initial serverinfo fetch over HTTP since we don't know which cert to use
        QString serverInfo = fetchServerInfo(http);
        if (serverInfo.isEmpty() && !m_MdnsIpv6Address.isNull()) {
            // Retry using the global IPv6 address if the IPv4 or link-local IPv6 address fails
            http.setAddress(m_MdnsIpv6Address);
            serverInfo = fetchServerInfo(http);
        }
        if (serverInfo.isEmpty()) {
            return;
        }
```
**File:** app/backend/computermanager.cpp (L820-821)
```cpp
        // Create initial newComputer using HTTP serverinfo with no pinned cert
        NvComputer* newComputer = new NvComputer(http, serverInfo);
```
**File:** app/streaming/session.cpp (L1548-1600)
```cpp
bool Session::startConnectionAsync()
{
    // Wait 1.5 seconds before connecting to let the user
    // have time to read any messages present on the segue
    SDL_Delay(1500);

    // The UI should have ensured the old game was already quit
    // if we decide to stream a different game.
    Q_ASSERT(m_Computer->currentGameId == 0 ||
             m_Computer->currentGameId == m_App.id);

    bool enableGameOptimizations;
    if (m_Computer->isNvidiaServerSoftware) {
        // GFE will set all settings to 720p60 if it doesn't recognize
        // the chosen resolution. Avoid that by disabling SOPS when it
        // is not streaming a supported resolution.
        enableGameOptimizations = false;
        for (const NvDisplayMode &mode : m_Computer->displayModes) {
            if (mode.width == m_StreamConfig.width &&
                    mode.height == m_StreamConfig.height) {
                SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION,
                            "Found host supported resolution: %dx%d",
                            mode.width, mode.height);
                enableGameOptimizations = m_Preferences->gameOptimizations;
                break;
            }
        }
    }
    else {
        // Always send SOPS to Sunshine because we may repurpose the
        // option to control whether the display mode is adjusted
        enableGameOptimizations = m_Preferences->gameOptimizations;
    }

    QString rtspSessionUrl;

    try {
        NvHTTP http(m_Computer);
        http.startApp(m_Computer->currentGameId != 0 ? "resume" : "launch",
                      m_Computer->isNvidiaServerSoftware,
                      m_App.id, &m_StreamConfig,
                      enableGameOptimizations,
                      m_Preferences->playAudioOnHost,
                      m_InputHandler->getAttachedGamepadMask(),
                      !m_Preferences->multiController,
                      rtspSessionUrl);
    } catch (const GfeHttpResponseException& e) {
        emit displayLaunchError(tr("Host returned error: %1").arg(e.toQString()));
        return false;
    } catch (const QtNetworkReplyException& e) {
        emit displayLaunchError(e.toQString());
        return false;
    }
```
## Q2
How to parse the information returned by the above 2 interfaces and provide it to the function for establishing a streaming connection?
### Answer
You're asking about how Moonlight parses the responses from `/serverinfo` and `/launch` endpoints and uses that information to establish a streaming connection.

## Answer

### Parsing `/serverinfo` Response

The `/serverinfo` response is parsed to create/update an `NvComputer` object that stores host capabilities. moonlight-qt:754-782  The `NvHTTP::getServerInfo()` method returns an XML string that gets parsed to extract server properties like:<cite />

- Server codec mode support (`serverCodecModeSupport`)
- GFE version (`gfeVersion`)
- App version (`appVersion`)
- Display modes
- Current game ID

These properties are stored in the `NvComputer` object and later used during session validation and configuration.<cite />

### Parsing `/launch` Response and Establishing Connection

When starting a stream, `NvHTTP::startApp()` is called with the `STREAM_CONFIGURATION` structure containing all streaming parameters (resolution, FPS, bitrate, codec preferences, etc.). moonlight-qt:189-236  The method constructs a URL with query parameters including:<cite />

- Resolution and FPS (`mode` parameter)
- HDR settings
- Audio configuration
- Gamepad mask
- Remote input encryption keys

The response is parsed to extract the `rtspSessionUrl` using `getXmlString(response, "sessionUrl0")`. moonlight-qt:235-235 

### Providing Information to Connection Function

After receiving the `/launch` response, the parsed information is used to populate a `SERVER_INFORMATION` structure: moonlight-qt:1602-1624 

```cpp
SERVER_INFORMATION hostInfo;
hostInfo.address = hostnameStr.data();
hostInfo.serverInfoAppVersion = siAppVersion.data();
hostInfo.serverCodecModeSupport = m_Computer->serverCodecModeSupport;
hostInfo.serverInfoGfeVersion = siGfeVersion.data();
hostInfo.rtspSessionUrl = rtspSessionUrlStr.data();
```

This structure, along with the `STREAM_CONFIGURATION` and callback structures, is passed to `LiStartConnection()` to establish the actual streaming connection: moonlight-qt:1678-1685 

The `LiStartConnection()` function (from the moonlight-common-c library) uses:
- The RTSP session URL from `/launch` response to establish the RTSP control channel
- Server codec support from `/serverinfo` to negotiate video formats
- Stream configuration to set up video/audio decoders

### Validation Before Connection

Before calling `LiStartConnection()`, the session validates that the host supports the requested features by checking `m_Computer->serverCodecModeSupport` against the requested video formats. moonlight-qt:1117-1152  For example, it verifies YUV 4:4:4 support and adjusts the supported video formats list accordingly.<cite />

## Notes

The parsing happens in two stages: first during PC discovery (parsing `/serverinfo` into `NvComputer` properties), then during session start (parsing `/launch` response for RTSP URL). The `NvComputer` object acts as a bridge, storing server capabilities that are later referenced when configuring the `SERVER_INFORMATION` structure for `LiStartConnection()`. The actual XML parsing is handled by helper functions like `getXmlString()` in the `NvHTTP` class.

Wiki pages you might want to explore:
- [Settings View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.2)
- [Input Handling (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#4.7)
### Citations
**File:** app/backend/computermanager.cpp (L754-782)
```cpp
    QString fetchServerInfo(NvHTTP& http)
    {
        QString serverInfo;

        // Do nothing if we're quitting
        if (m_AboutToQuit) {
            return QString();
        }

        try {
            // There's a race condition between GameStream servers reporting presence over
            // mDNS and the HTTPS server being ready to respond to our queries. To work
            // around this issue, we will issue the request again after a few seconds if
            // we see a ServiceUnavailableError error.
            try {
                serverInfo = http.getServerInfo(NvHTTP::NVLL_VERBOSE);
            } catch (const QtNetworkReplyException& e) {
                if (e.getError() == QNetworkReply::ServiceUnavailableError) {
                    qWarning() << "Retrying request in 5 seconds after ServiceUnavailableError";
                    QThread::sleep(5);
                    serverInfo = http.getServerInfo(NvHTTP::NVLL_VERBOSE);
                    qInfo() << "Retry successful";
                }
                else {
                    // Rethrow other errors
                    throw e;
                }
            }
            return serverInfo;
```
**File:** app/backend/nvhttp.cpp (L189-236)
```cpp
void
NvHTTP::startApp(QString verb,
                 bool isGfe,
                 int appId,
                 PSTREAM_CONFIGURATION streamConfig,
                 bool sops,
                 bool localAudio,
                 int gamepadMask,
                 bool persistGameControllersOnDisconnect,
                 QString& rtspSessionUrl)
{
    int riKeyId;

    memcpy(&riKeyId, streamConfig->remoteInputAesIv, sizeof(riKeyId));
    riKeyId = qFromBigEndian(riKeyId);

    QString response =
            openConnectionToString(m_BaseUrlHttps,
                                   verb,
                                   "appid="+QString::number(appId)+
                                   "&mode="+QString::number(streamConfig->width)+"x"+
                                   QString::number(streamConfig->height)+"x"+
                                   // Using an FPS value over 60 causes SOPS to default to 720p60,
                                   // so force it to 0 to ensure the correct resolution is set. We
                                   // used to use 60 here but that locked the frame rate to 60 FPS
                                   // on GFE 3.20.3. We don't need this hack for Sunshine.
                                   QString::number((streamConfig->fps > 60 && isGfe) ? 0 : streamConfig->fps)+
                                   "&additionalStates=1&sops="+QString::number(sops ? 1 : 0)+
                                   "&rikey="+QByteArray(streamConfig->remoteInputAesKey, sizeof(streamConfig->remoteInputAesKey)).toHex()+
                                   "&rikeyid="+QString::number(riKeyId)+
                                   ((streamConfig->supportedVideoFormats & VIDEO_FORMAT_MASK_10BIT) ?
                                       "&hdrMode=1&clientHdrCapVersion=0&clientHdrCapSupportedFlagsInUint32=0&clientHdrCapMetaDataId=NV_STATIC_METADATA_TYPE_1&clientHdrCapDisplayData=0x0x0x0x0x0x0x0x0x0x0" :
                                        "")+
                                   "&localAudioPlayMode="+QString::number(localAudio ? 1 : 0)+
                                   "&surroundAudioInfo="+QString::number(SURROUNDAUDIOINFO_FROM_AUDIO_CONFIGURATION(streamConfig->audioConfiguration))+
                                   "&remoteControllersBitmap="+QString::number(gamepadMask)+
                                   "&gcmap="+QString::number(gamepadMask)+
                                   "&gcpersist="+QString::number(persistGameControllersOnDisconnect ? 1 : 0)+
                                   LiGetLaunchUrlQueryParameters(),
                                   LAUNCH_TIMEOUT_MS);

    qInfo() << "Launch response:" << response;

    // Throws if the request failed
    verifyResponseStatus(response);

    rtspSessionUrl = getXmlString(response, "sessionUrl0");
}
```
**File:** app/streaming/session.cpp (L1117-1152)
```cpp
    if (m_Preferences->enableYUV444) {
        if (!(m_Computer->serverCodecModeSupport & SCM_MASK_YUV444)) {
            emitLaunchWarning(tr("Your host PC doesn't support YUV 4:4:4 streaming."));
            m_SupportedVideoFormats.removeByMask(VIDEO_FORMAT_MASK_YUV444);
        }
        else {
            m_SupportedVideoFormats.removeByMask(~m_SupportedVideoFormats.maskByServerCodecModes(m_Computer->serverCodecModeSupport));

            if (!m_SupportedVideoFormats.isEmpty() &&
                !(m_SupportedVideoFormats.front() & VIDEO_FORMAT_MASK_YUV444)) {
                emitLaunchWarning(tr("Your host PC doesn't support YUV 4:4:4 streaming for selected video codec."));
            }
            else if (m_Preferences->videoDecoderSelection != StreamingPreferences::VDS_FORCE_SOFTWARE) {
                while (!m_SupportedVideoFormats.isEmpty() &&
                       (m_SupportedVideoFormats.front() & VIDEO_FORMAT_MASK_YUV444) &&
                       getDecoderAvailability(testWindow,
                                              m_Preferences->videoDecoderSelection,
                                              m_SupportedVideoFormats.front(),
                                              m_StreamConfig.width,
                                              m_StreamConfig.height,
                                              m_StreamConfig.fps) != DecoderAvailability::Hardware) {
                    if (m_Preferences->videoDecoderSelection == StreamingPreferences::VDS_FORCE_HARDWARE) {
                        m_SupportedVideoFormats.removeFirst();
                    }
                    else {
                        emitLaunchWarning(tr("Using software decoding due to your selection to force YUV 4:4:4 without GPU support. This may cause poor streaming performance."));
                        break;
                    }
                }
                if (!m_SupportedVideoFormats.isEmpty() &&
                    !(m_SupportedVideoFormats.front() & VIDEO_FORMAT_MASK_YUV444)) {
                    emitLaunchWarning(tr("This PC's GPU doesn't support YUV 4:4:4 decoding for selected video codec."));
                }
            }
        }
    }
```
**File:** app/streaming/session.cpp (L1602-1624)
```cpp
    QByteArray hostnameStr = m_Computer->activeAddress.address().toLatin1();
    QByteArray siAppVersion = m_Computer->appVersion.toLatin1();

    SERVER_INFORMATION hostInfo;
    hostInfo.address = hostnameStr.data();
    hostInfo.serverInfoAppVersion = siAppVersion.data();
    hostInfo.serverCodecModeSupport = m_Computer->serverCodecModeSupport;

    // Older GFE versions didn't have this field
    QByteArray siGfeVersion;
    if (!m_Computer->gfeVersion.isEmpty()) {
        siGfeVersion = m_Computer->gfeVersion.toLatin1();
    }
    if (!siGfeVersion.isEmpty()) {
        hostInfo.serverInfoGfeVersion = siGfeVersion.data();
    }

    // Older GFE and Sunshine versions didn't have this field
    QByteArray rtspSessionUrlStr;
    if (!rtspSessionUrl.isEmpty()) {
        rtspSessionUrlStr = rtspSessionUrl.toLatin1();
        hostInfo.rtspSessionUrl = rtspSessionUrlStr.data();
    }
```
**File:** app/streaming/session.cpp (L1678-1685)
```cpp
    int err = LiStartConnection(&hostInfo, &m_StreamConfig, &k_ConnCallbacks,
                                &m_VideoCallbacks, &m_AudioCallbacks,
                                NULL, 0, NULL, 0);
    if (err != 0) {
        // We already displayed an error dialog in the stage failure
        // listener.
        return false;
    }
```
## Q3
how to get "Remote input encryption keys"
### Answer
You're asking about how Moonlight generates the "Remote input encryption keys" that are sent to the host server during the `/launch` request.

## Answer

The remote input encryption keys (`rikey` and `rikeyid`) are randomly generated AES encryption keys used to secure input data sent from the client to the host during streaming. moonlight-qt:692-696 

### Key Generation

During session initialization in `Session::initialize()`, Moonlight generates these keys using OpenSSL's cryptographically secure random number generator:

```cpp
RAND_bytes(reinterpret_cast<unsigned char*>(m_StreamConfig.remoteInputAesKey),
           sizeof(m_StreamConfig.remoteInputAesKey));

// Only the first 4 bytes are populated in the RI key IV
RAND_bytes(reinterpret_cast<unsigned char*>(m_StreamConfig.remoteInputAesIv), 4);
``` moonlight-qt:692-696 

The `remoteInputAesKey` is a full AES key (16 bytes), while `remoteInputAesIv` only uses the first 4 bytes as an initialization vector. moonlight-qt:692-696 

### Sending Keys to Host

These generated keys are then sent to the host server when calling the `/launch` endpoint in `NvHTTP::startApp()`. moonlight-qt:200-218  The method:

1. Extracts the key ID from the IV by reading the first 4 bytes as a big-endian integer moonlight-qt:200-203 
2. Converts the AES key to hexadecimal format using `QByteArray(...).toHex()` moonlight-qt:217-217 
3. Includes both values as query parameters: `rikey=<hex_key>&rikeyid=<key_id>` moonlight-qt:217-218 

### Security Considerations

For security, these keys are automatically redacted from log files to prevent exposure. moonlight-qt:108-110  The logging system uses regex patterns to strip `rikey` and `rikeyid` values before writing to logs. moonlight-qt:88-88 

## Notes

The remote input encryption is part of Moonlight's security features to protect input data (keyboard, mouse, gamepad) transmitted during streaming. The keys are generated fresh for each streaming session and are stored in the `STREAM_CONFIGURATION` structure (`m_StreamConfig`) which is later passed to `LiStartConnection()` to establish the connection. moonlight-qt:1584-1593 

Wiki pages you might want to explore:
- [PC Discovery View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.1)
### Citations
**File:** app/streaming/session.cpp (L692-696)
```cpp
    RAND_bytes(reinterpret_cast<unsigned char*>(m_StreamConfig.remoteInputAesKey),
               sizeof(m_StreamConfig.remoteInputAesKey));

    // Only the first 4 bytes are populated in the RI key IV
    RAND_bytes(reinterpret_cast<unsigned char*>(m_StreamConfig.remoteInputAesIv), 4);
```
**File:** app/streaming/session.cpp (L1584-1593)
```cpp
    try {
        NvHTTP http(m_Computer);
        http.startApp(m_Computer->currentGameId != 0 ? "resume" : "launch",
                      m_Computer->isNvidiaServerSoftware,
                      m_App.id, &m_StreamConfig,
                      enableGameOptimizations,
                      m_Preferences->playAudioOnHost,
                      m_InputHandler->getAttachedGamepadMask(),
                      !m_Preferences->multiController,
                      rtspSessionUrl);
```
**File:** app/backend/nvhttp.cpp (L200-218)
```cpp
    int riKeyId;

    memcpy(&riKeyId, streamConfig->remoteInputAesIv, sizeof(riKeyId));
    riKeyId = qFromBigEndian(riKeyId);

    QString response =
            openConnectionToString(m_BaseUrlHttps,
                                   verb,
                                   "appid="+QString::number(appId)+
                                   "&mode="+QString::number(streamConfig->width)+"x"+
                                   QString::number(streamConfig->height)+"x"+
                                   // Using an FPS value over 60 causes SOPS to default to 720p60,
                                   // so force it to 0 to ensure the correct resolution is set. We
                                   // used to use 60 here but that locked the frame rate to 60 FPS
                                   // on GFE 3.20.3. We don't need this hack for Sunshine.
                                   QString::number((streamConfig->fps > 60 && isGfe) ? 0 : streamConfig->fps)+
                                   "&additionalStates=1&sops="+QString::number(sops ? 1 : 0)+
                                   "&rikey="+QByteArray(streamConfig->remoteInputAesKey, sizeof(streamConfig->remoteInputAesKey)).toHex()+
                                   "&rikeyid="+QString::number(riKeyId)+
```
**File:** app/main.cpp (L108-110)
```cpp
    // Strip session encryption keys and IVs from the logs
    message.replace(k_RikeyRegex, "&rikey=REDACTED");
    message.replace(k_RikeyIdRegex, "&rikeyid=REDACTED");
```
**File:** app/deploy/linux/com.moonlight_stream.Moonlight.appdata.xml (L88-88)
```text
					<li>Per-session keys (rikey and rikeyid values) are now automatically stripped from logs</li>
```
## Q4
<?xml version="1.0" encoding="utf-8"?>
<root status_code="200">
  <hostname>Html5syt</hostname>
  <appversion>7.1.431.-1</appversion>
<GfeVersion>3.23.0.74</GfeVersion>
  <uniqueid>F98186B1-DE02-2328-279E-0A461FBCEC47</uniqueid>
  <HttpsPort>47984</HttpsPort>
  <ExternalPort>47989</ExternalPort>
<MaxLumaPixelsHEVC>1869449984</MaxLumaPixelsHEVC>
  <mac>00:00:00:00:00:00</mac>
  <LocalIP>127.0.0.1</LocalIP>
  <ServerCodecModeSupport>257</ServerCodecModeSupport>
<PairStatus>0</PairStatus>
  <currentgame>1191261554</currentgame>
  <state>SUNSHINE_SERVER_BUSY</state>
</root>
This is a response from a serverinfo, please tell me which parameters are used to establish the connection in it?
### Answer
You're asking which parameters from the `/serverinfo` XML response are used when establishing a streaming connection in Moonlight.

## Answer

From the `/serverinfo` response you provided, the following parameters are used to establish the streaming connection:

### Parameters Used in Connection Establishment

**`ServerCodecModeSupport` (value: 257)** - This is stored in the `NvComputer` object and later passed to `LiStartConnection()` via the `SERVER_INFORMATION` structure. moonlight-qt:1608-1608  It indicates which video codecs and formats the host supports, and is used to negotiate the video format during connection setup. moonlight-qt:1608-1608 

**`appversion` (value: 7.1.431.-1)** - This is stored as `m_Computer->appVersion` and passed to `LiStartConnection()` as `hostInfo.serverInfoAppVersion`. moonlight-qt:1603-1607  The connection library uses this to determine host capabilities and compatibility. moonlight-qt:1603-1607 

**`GfeVersion` (value: 3.23.0.74)** - This is stored as `m_Computer->gfeVersion` and passed to `LiStartConnection()` as `hostInfo.serverInfoGfeVersion`. moonlight-qt:1611-1617  It's used to determine if the host is running GFE or Sunshine and adjust behavior accordingly. moonlight-qt:1560-1580 

**`LocalIP` (value: 127.0.0.1)** - The host's address is used to construct the base URLs for HTTP/HTTPS communication and is passed to `LiStartConnection()` as `hostInfo.address`. moonlight-qt:1602-1606 

**`HttpsPort` (value: 47984)** - Used to construct the HTTPS base URL for secure communication with the host, including the `/launch` endpoint call. moonlight-qt:173-177 

### Parameters NOT Directly Used in Connection

The following parameters are informational but not directly passed to the connection function:

- `hostname`, `uniqueid`, `ExternalPort`, `MaxLumaPixelsHEVC`, `mac` - These are stored in the `NvComputer` object for display and management purposes but aren't passed to `LiStartConnection()`.<cite />
- `PairStatus` - Used to determine if pairing is needed before streaming, but not used during connection establishment.<cite />
- `currentgame` and `state` - Used to determine if the host is already streaming, which affects whether to call `/launch` or `/resume`. moonlight-qt:1586-1586 

## Notes

The `state` value "SUNSHINE_SERVER_BUSY" indicates the host is currently streaming (as confirmed by the non-zero `currentgame` value). moonlight-qt:112-116  In this case, Moonlight would call `/resume` instead of `/launch` if you're trying to connect to the same game. moonlight-qt:1586-1586  The `ServerCodecModeSupport` value of 257 indicates support for H.264 (bit 0) and H.265/HEVC (bit 8).<cite />

Wiki pages you might want to explore:
- [PC Discovery View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.1)
### Citations
**File:** app/streaming/session.cpp (L1560-1580)
```cpp
    if (m_Computer->isNvidiaServerSoftware) {
        // GFE will set all settings to 720p60 if it doesn't recognize
        // the chosen resolution. Avoid that by disabling SOPS when it
        // is not streaming a supported resolution.
        enableGameOptimizations = false;
        for (const NvDisplayMode &mode : m_Computer->displayModes) {
            if (mode.width == m_StreamConfig.width &&
                    mode.height == m_StreamConfig.height) {
                SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION,
                            "Found host supported resolution: %dx%d",
                            mode.width, mode.height);
                enableGameOptimizations = m_Preferences->gameOptimizations;
                break;
            }
        }
    }
    else {
        // Always send SOPS to Sunshine because we may repurpose the
        // option to control whether the display mode is adjusted
        enableGameOptimizations = m_Preferences->gameOptimizations;
    }
```
**File:** app/streaming/session.cpp (L1586-1586)
```cpp
        http.startApp(m_Computer->currentGameId != 0 ? "resume" : "launch",
```
**File:** app/streaming/session.cpp (L1602-1607)
```cpp
    QByteArray hostnameStr = m_Computer->activeAddress.address().toLatin1();
    QByteArray siAppVersion = m_Computer->appVersion.toLatin1();

    SERVER_INFORMATION hostInfo;
    hostInfo.address = hostnameStr.data();
    hostInfo.serverInfoAppVersion = siAppVersion.data();
```
**File:** app/streaming/session.cpp (L1608-1608)
```cpp
    hostInfo.serverCodecModeSupport = m_Computer->serverCodecModeSupport;
```
**File:** app/streaming/session.cpp (L1611-1617)
```cpp
    QByteArray siGfeVersion;
    if (!m_Computer->gfeVersion.isEmpty()) {
        siGfeVersion = m_Computer->gfeVersion.toLatin1();
    }
    if (!siGfeVersion.isEmpty()) {
        hostInfo.serverInfoGfeVersion = siGfeVersion.data();
    }
```
**File:** app/backend/nvhttp.cpp (L112-116)
```cpp
    QString serverState = getXmlString(serverInfo, "state");
    if (serverState != nullptr && serverState.endsWith("_SERVER_BUSY"))
    {
        return getXmlString(serverInfo, "currentgame").toInt();
    }
```
**File:** app/backend/nvhttp.cpp (L173-177)
```cpp
        uint16_t httpsPort = getXmlString(serverInfo, "HttpsPort").toUShort();
        if (httpsPort == 0) {
            httpsPort = DEFAULT_HTTPS_PORT;
        }
        setHttpsPort(httpsPort);
```
## Q5
When I call the /launch interface, the server requires me to provide a client certificate. How can I obtain this certificate?
### Answer
Moonlight obtains and provides client certificates through a multi-step process involving certificate generation, pairing, and SSL configuration:

## Client Certificate Generation

When Moonlight first launches, the `IdentityManager` class automatically generates a self-signed 2048-bit RSA certificate and private key pair if none exist. moonlight-qt:29-110 

These credentials are stored persistently in QSettings and cached in memory for reuse. moonlight-qt:112-139 

## Attaching Certificates to Requests

For every HTTPS request (including `/launch`), Moonlight attaches the client certificate through the `IdentityManager::getSslConfig()` method, which returns a `QSslConfiguration` containing both the client certificate and private key. moonlight-qt:184-191 

This SSL configuration is applied to all network requests in the `openConnection` method via `request.setSslConfiguration()`. moonlight-qt:486-489 

## The `/launch` Interface Specifically

When the `startApp` method is called to launch a game, it makes an HTTPS request to the `/launch` endpoint using the base HTTPS URL. moonlight-qt:205-228 

This request goes through `openConnection`, which automatically includes the client certificate for mutual TLS authentication with the host server.

## Pairing Process for Mutual Trust

Before the client certificate can be used for authentication, a pairing process must occur. During pairing, the client sends its certificate to the server and receives the server's certificate in return. moonlight-qt:217-248 

The server certificate is then pinned and stored in the `NvComputer` object for future SSL validation. moonlight-qt:419-439 

## Certificate Validation

If there's an SSL handshake failure or certificate mismatch (error 401), Moonlight falls back to HTTP and can re-initiate pairing to obtain updated certificates. moonlight-qt:143-160 

## Notes

- The client certificate uses a common name of "NVIDIA GameStream Client" moonlight-qt:70-74 
- The certificate has a 20-year validity period moonlight-qt:51-66 
- The `/launch` endpoint uses a 120-second timeout compared to the standard 5-second timeout for other requests moonlight-qt:15-19 
- Certificate pinning prevents man-in-the-middle attacks by ensuring SSL errors are only ignored if they match the previously paired server certificate moonlight-qt:429-434
### Citations
**File:** app/backend/identitymanager.cpp (L29-110)
```cpp
void IdentityManager::createCredentials(QSettings& settings)
{
    X509* cert = X509_new();
    THROW_BAD_ALLOC_IF_NULL(cert);

    EVP_PKEY_CTX* ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_RSA, NULL);
    THROW_BAD_ALLOC_IF_NULL(ctx);

    EVP_PKEY_keygen_init(ctx);
    EVP_PKEY_CTX_set_rsa_keygen_bits(ctx, 2048);

    // pk must be initialized on input
    EVP_PKEY* pk = NULL;
    EVP_PKEY_keygen(ctx, &pk);

    EVP_PKEY_CTX_free(ctx);
    THROW_BAD_ALLOC_IF_NULL(pk);

    X509_set_version(cert, 2);
    ASN1_INTEGER_set(X509_get_serialNumber(cert), 0);
#if OPENSSL_VERSION_NUMBER < 0x10100000L
    X509_gmtime_adj(X509_get_notBefore(cert), 0);
    X509_gmtime_adj(X509_get_notAfter(cert), 60 * 60 * 24 * 365 * 20); // 20 yrs
#else
    ASN1_TIME* before = ASN1_STRING_dup(X509_get0_notBefore(cert));
    THROW_BAD_ALLOC_IF_NULL(before);
    ASN1_TIME* after = ASN1_STRING_dup(X509_get0_notAfter(cert));
    THROW_BAD_ALLOC_IF_NULL(after);

    X509_gmtime_adj(before, 0);
    X509_gmtime_adj(after, 60 * 60 * 24 * 365 * 20); // 20 yrs

    X509_set1_notBefore(cert, before);
    X509_set1_notAfter(cert, after);

    ASN1_STRING_free(before);
    ASN1_STRING_free(after);
#endif

    X509_set_pubkey(cert, pk);

    X509_NAME* name = X509_get_subject_name(cert);
    X509_NAME_add_entry_by_txt(name, "CN", MBSTRING_ASC,
                               reinterpret_cast<unsigned char *>(const_cast<char*>("NVIDIA GameStream Client")),
                               -1, -1, 0);
    X509_set_issuer_name(cert, name);

    X509_sign(cert, pk, EVP_sha256());

    BIO* biokey = BIO_new(BIO_s_mem());
    THROW_BAD_ALLOC_IF_NULL(biokey);
    PEM_write_bio_PrivateKey(biokey, pk, NULL, NULL, 0, NULL, NULL);

    BIO* biocert = BIO_new(BIO_s_mem());
    THROW_BAD_ALLOC_IF_NULL(biocert);
    PEM_write_bio_X509(biocert, cert);

    BUF_MEM* mem;
    BIO_get_mem_ptr(biokey, &mem);
    m_CachedPrivateKey = QByteArray(mem->data, (int)mem->length);

    BIO_get_mem_ptr(biocert, &mem);
    m_CachedPemCert = QByteArray(mem->data, (int)mem->length);

    X509_free(cert);
    EVP_PKEY_free(pk);
    BIO_free(biokey);
    BIO_free(biocert);

    // Check that the new keypair is valid before persisting it
    if (getSslCertificate().isNull()) {
        qFatal("Newly generated certificate is unreadable");
    }
    if (getSslKey().isNull()) {
        qFatal("Newly generated private key is unreadable");
    }

    settings.setValue(SER_CERT, m_CachedPemCert);
    settings.setValue(SER_KEY, m_CachedPrivateKey);

    qInfo() << "Wrote new identity credentials to settings";
}
```
**File:** app/backend/identitymanager.cpp (L112-139)
```cpp
IdentityManager::IdentityManager()
{
    QSettings settings;

    m_CachedPemCert = settings.value(SER_CERT).toByteArray();
    m_CachedPrivateKey = settings.value(SER_KEY).toByteArray();

    if (m_CachedPemCert.isEmpty() || m_CachedPrivateKey.isEmpty()) {
        qInfo() << "No existing credentials found";
        createCredentials(settings);
    }
    else if (getSslCertificate().isNull()) {
        qWarning() << "Certificate is unreadable";
        createCredentials(settings);
    }
    else if (getSslKey().isNull()) {
        qWarning() << "Private key is unreadable";
        createCredentials(settings);
    }

    // We should have valid credentials now. If not, we're screwed
    if (getSslCertificate().isNull()) {
        qFatal("Certificate is unreadable");
    }
    if (getSslKey().isNull()) {
        qFatal("Private key is unreadable");
    }
}
```
**File:** app/backend/identitymanager.cpp (L184-191)
```cpp
QSslConfiguration
IdentityManager::getSslConfig()
{
    QSslConfiguration sslConfig(QSslConfiguration::defaultConfiguration());
    sslConfig.setLocalCertificate(getSslCertificate());
    sslConfig.setPrivateKey(getSslKey());
    return sslConfig;
}
```
**File:** app/backend/nvhttp.cpp (L15-19)
```cpp
#define FAST_FAIL_TIMEOUT_MS 2000
#define REQUEST_TIMEOUT_MS 5000
#define LAUNCH_TIMEOUT_MS 120000
#define RESUME_TIMEOUT_MS 30000
#define QUIT_TIMEOUT_MS 30000
```
**File:** app/backend/nvhttp.cpp (L143-160)
```cpp
        catch (const GfeHttpResponseException& e)
        {
            if (e.getStatusCode() == 401)
            {
                // Certificate validation error, fallback to HTTP
                serverInfo = openConnectionToString(m_BaseUrlHttp,
                                                    "serverinfo",
                                                    nullptr,
                                                    fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                                    logLevel);
                verifyResponseStatus(serverInfo);
            }
            else
            {
                // Rethrow real errors
                throw e;
            }
        }
```
**File:** app/backend/nvhttp.cpp (L205-228)
```cpp
    QString response =
            openConnectionToString(m_BaseUrlHttps,
                                   verb,
                                   "appid="+QString::number(appId)+
                                   "&mode="+QString::number(streamConfig->width)+"x"+
                                   QString::number(streamConfig->height)+"x"+
                                   // Using an FPS value over 60 causes SOPS to default to 720p60,
                                   // so force it to 0 to ensure the correct resolution is set. We
                                   // used to use 60 here but that locked the frame rate to 60 FPS
                                   // on GFE 3.20.3. We don't need this hack for Sunshine.
                                   QString::number((streamConfig->fps > 60 && isGfe) ? 0 : streamConfig->fps)+
                                   "&additionalStates=1&sops="+QString::number(sops ? 1 : 0)+
                                   "&rikey="+QByteArray(streamConfig->remoteInputAesKey, sizeof(streamConfig->remoteInputAesKey)).toHex()+
                                   "&rikeyid="+QString::number(riKeyId)+
                                   ((streamConfig->supportedVideoFormats & VIDEO_FORMAT_MASK_10BIT) ?
                                       "&hdrMode=1&clientHdrCapVersion=0&clientHdrCapSupportedFlagsInUint32=0&clientHdrCapMetaDataId=NV_STATIC_METADATA_TYPE_1&clientHdrCapDisplayData=0x0x0x0x0x0x0x0x0x0x0" :
                                        "")+
                                   "&localAudioPlayMode="+QString::number(localAudio ? 1 : 0)+
                                   "&surroundAudioInfo="+QString::number(SURROUNDAUDIOINFO_FROM_AUDIO_CONFIGURATION(streamConfig->audioConfiguration))+
                                   "&remoteControllersBitmap="+QString::number(gamepadMask)+
                                   "&gcmap="+QString::number(gamepadMask)+
                                   "&gcpersist="+QString::number(persistGameControllersOnDisconnect ? 1 : 0)+
                                   LiGetLaunchUrlQueryParameters(),
                                   LAUNCH_TIMEOUT_MS);
```
**File:** app/backend/nvhttp.cpp (L419-439)
```cpp
void NvHTTP::handleSslErrors(QNetworkReply* reply, const QList<QSslError>& errors)
{
    bool ignoreErrors = true;

    if (m_ServerCert.isNull()) {
        // We should never make an HTTPS request without a cert
        Q_ASSERT(!m_ServerCert.isNull());
        return;
    }

    for (const QSslError& error : errors) {
        if (m_ServerCert != error.certificate()) {
            ignoreErrors = false;
            break;
        }
    }

    if (ignoreErrors) {
        reply->ignoreSslErrors(errors);
    }
}
```
**File:** app/backend/nvhttp.cpp (L486-489)
```cpp
    QNetworkRequest request(url);

    // Add our client certificate
    request.setSslConfiguration(IdentityManager::get()->getSslConfig());
```
**File:** app/backend/nvpairingmanager.cpp (L217-248)
```cpp
    QString getCert = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&phrase=getservercert&salt=" +
                                                    salt.toHex() + "&clientcert=" + IdentityManager::get()->getCertificate().toHex(),
                                                    0);
    NvHTTP::verifyResponseStatus(getCert);
    if (NvHTTP::getXmlString(getCert, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #1";
        return PairState::FAILED;
    }

    QByteArray serverCertStr = NvHTTP::getXmlStringFromHex(getCert, "plaincert");
    if (serverCertStr == nullptr)
    {
        qCritical() << "Server likely already pairing";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::ALREADY_IN_PROGRESS;
    }

    QSslCertificate unverifiedServerCert = QSslCertificate(serverCertStr);
    if (unverifiedServerCert.isNull()) {
        Q_ASSERT(!unverifiedServerCert.isNull());

        qCritical() << "Failed to parse plaincert";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    // Pin this cert for TLS until pairing is complete. If successful, we will propagate
    // the cert into the NvComputer object and persist it.
    m_Http.setServerCert(unverifiedServerCert);
```
## Q6
How to pair up computer?
### Answer
The pairing process in Moonlight uses a 5-phase handshake protocol to securely exchange certificates between the client and server. Here's how it works:

## Client Certificate Generation and Storage

The client certificate is a self-signed X.509 certificate that is generated when Moonlight first runs. It uses a 2048-bit RSA key pair with SHA-256 signature and has a 20-year validity period. moonlight-qt:29-110 

The certificate and private key are stored in QSettings and cached in memory for subsequent use. moonlight-qt:112-139 

## The 5-Phase Pairing Process

The pairing process is implemented in the `NvPairingManager::pair()` method: moonlight-qt:191-354 

### Phase 1: Certificate Exchange

The client sends its certificate to the server as a hex-encoded string in the `clientcert` parameter of an HTTP request. At the same time, it receives the server's certificate in the response: moonlight-qt:217-227 

The server returns its certificate in the `plaincert` field of the XML response: moonlight-qt:229-244 

### Phase 2-5: Challenge-Response Authentication

Once the server certificate is received, it is immediately pinned to the HTTP client for all subsequent HTTPS requests: moonlight-qt:246-248 

The remaining phases involve encrypted challenge-response exchanges and signature verification to authenticate both parties and validate the PIN.

## Certificate Pinning

The `setServerCert()` method stores the server certificate for use in HTTPS connections: moonlight-qt:43-46 

During HTTPS connections, the `handleSslErrors()` method verifies that the server certificate matches the pinned certificate, preventing man-in-the-middle attacks: moonlight-qt:419-439 

## Persisting the Server Certificate

After successful pairing, the server certificate is stored in the `NvComputer` object: moonlight-qt:113-113 

The certificate is then persisted to settings by calling `saveHost()`: moonlight-qt:599-603 

## Notes

The pairing process uses AES-128-ECB encryption for challenge exchanges, with the encryption key derived from a salted PIN hash (SHA-256 for Gen 7+ servers, SHA-1 for older versions). The client certificate is sent as plain hex-encoded PEM data in Phase 1, while the server certificate is also returned as hex-encoded PEM. This certificate exchange happens over HTTP initially, but all subsequent pairing phases use HTTPS with the newly pinned certificate to ensure secure communication.
### Citations
**File:** app/backend/identitymanager.cpp (L29-110)
```cpp
void IdentityManager::createCredentials(QSettings& settings)
{
    X509* cert = X509_new();
    THROW_BAD_ALLOC_IF_NULL(cert);

    EVP_PKEY_CTX* ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_RSA, NULL);
    THROW_BAD_ALLOC_IF_NULL(ctx);

    EVP_PKEY_keygen_init(ctx);
    EVP_PKEY_CTX_set_rsa_keygen_bits(ctx, 2048);

    // pk must be initialized on input
    EVP_PKEY* pk = NULL;
    EVP_PKEY_keygen(ctx, &pk);

    EVP_PKEY_CTX_free(ctx);
    THROW_BAD_ALLOC_IF_NULL(pk);

    X509_set_version(cert, 2);
    ASN1_INTEGER_set(X509_get_serialNumber(cert), 0);
#if OPENSSL_VERSION_NUMBER < 0x10100000L
    X509_gmtime_adj(X509_get_notBefore(cert), 0);
    X509_gmtime_adj(X509_get_notAfter(cert), 60 * 60 * 24 * 365 * 20); // 20 yrs
#else
    ASN1_TIME* before = ASN1_STRING_dup(X509_get0_notBefore(cert));
    THROW_BAD_ALLOC_IF_NULL(before);
    ASN1_TIME* after = ASN1_STRING_dup(X509_get0_notAfter(cert));
    THROW_BAD_ALLOC_IF_NULL(after);

    X509_gmtime_adj(before, 0);
    X509_gmtime_adj(after, 60 * 60 * 24 * 365 * 20); // 20 yrs

    X509_set1_notBefore(cert, before);
    X509_set1_notAfter(cert, after);

    ASN1_STRING_free(before);
    ASN1_STRING_free(after);
#endif

    X509_set_pubkey(cert, pk);

    X509_NAME* name = X509_get_subject_name(cert);
    X509_NAME_add_entry_by_txt(name, "CN", MBSTRING_ASC,
                               reinterpret_cast<unsigned char *>(const_cast<char*>("NVIDIA GameStream Client")),
                               -1, -1, 0);
    X509_set_issuer_name(cert, name);

    X509_sign(cert, pk, EVP_sha256());

    BIO* biokey = BIO_new(BIO_s_mem());
    THROW_BAD_ALLOC_IF_NULL(biokey);
    PEM_write_bio_PrivateKey(biokey, pk, NULL, NULL, 0, NULL, NULL);

    BIO* biocert = BIO_new(BIO_s_mem());
    THROW_BAD_ALLOC_IF_NULL(biocert);
    PEM_write_bio_X509(biocert, cert);

    BUF_MEM* mem;
    BIO_get_mem_ptr(biokey, &mem);
    m_CachedPrivateKey = QByteArray(mem->data, (int)mem->length);

    BIO_get_mem_ptr(biocert, &mem);
    m_CachedPemCert = QByteArray(mem->data, (int)mem->length);

    X509_free(cert);
    EVP_PKEY_free(pk);
    BIO_free(biokey);
    BIO_free(biocert);

    // Check that the new keypair is valid before persisting it
    if (getSslCertificate().isNull()) {
        qFatal("Newly generated certificate is unreadable");
    }
    if (getSslKey().isNull()) {
        qFatal("Newly generated private key is unreadable");
    }

    settings.setValue(SER_CERT, m_CachedPemCert);
    settings.setValue(SER_KEY, m_CachedPrivateKey);

    qInfo() << "Wrote new identity credentials to settings";
}
```
**File:** app/backend/identitymanager.cpp (L112-139)
```cpp
IdentityManager::IdentityManager()
{
    QSettings settings;

    m_CachedPemCert = settings.value(SER_CERT).toByteArray();
    m_CachedPrivateKey = settings.value(SER_KEY).toByteArray();

    if (m_CachedPemCert.isEmpty() || m_CachedPrivateKey.isEmpty()) {
        qInfo() << "No existing credentials found";
        createCredentials(settings);
    }
    else if (getSslCertificate().isNull()) {
        qWarning() << "Certificate is unreadable";
        createCredentials(settings);
    }
    else if (getSslKey().isNull()) {
        qWarning() << "Private key is unreadable";
        createCredentials(settings);
    }

    // We should have valid credentials now. If not, we're screwed
    if (getSslCertificate().isNull()) {
        qFatal("Certificate is unreadable");
    }
    if (getSslKey().isNull()) {
        qFatal("Private key is unreadable");
    }
}
```
**File:** app/backend/nvpairingmanager.cpp (L191-354)
```cpp
NvPairingManager::pair(QString appVersion, QString pin, QSslCertificate& serverCert)
{
    int serverMajorVersion = NvHTTP::parseQuad(appVersion).at(0);
    qInfo() << "Pairing with server generation:" << serverMajorVersion;

    QCryptographicHash::Algorithm hashAlgo;
    int hashLength;
    if (serverMajorVersion >= 7)
    {
        // Gen 7+ uses SHA-256 hashing
        hashAlgo = QCryptographicHash::Sha256;
        hashLength = 32;
    }
    else
    {
        // Prior to Gen 7 uses SHA-1 hashing
        hashAlgo = QCryptographicHash::Sha1;
        hashLength = 20;
    }

    QByteArray salt = generateRandomBytes(16);
    QByteArray saltedPin = saltPin(salt, pin);

    QByteArray aesKey = QCryptographicHash::hash(saltedPin, hashAlgo).constData();
    aesKey.truncate(16);

    QString getCert = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&phrase=getservercert&salt=" +
                                                    salt.toHex() + "&clientcert=" + IdentityManager::get()->getCertificate().toHex(),
                                                    0);
    NvHTTP::verifyResponseStatus(getCert);
    if (NvHTTP::getXmlString(getCert, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #1";
        return PairState::FAILED;
    }

    QByteArray serverCertStr = NvHTTP::getXmlStringFromHex(getCert, "plaincert");
    if (serverCertStr == nullptr)
    {
        qCritical() << "Server likely already pairing";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::ALREADY_IN_PROGRESS;
    }

    QSslCertificate unverifiedServerCert = QSslCertificate(serverCertStr);
    if (unverifiedServerCert.isNull()) {
        Q_ASSERT(!unverifiedServerCert.isNull());

        qCritical() << "Failed to parse plaincert";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    // Pin this cert for TLS until pairing is complete. If successful, we will propagate
    // the cert into the NvComputer object and persist it.
    m_Http.setServerCert(unverifiedServerCert);

    QByteArray randomChallenge = generateRandomBytes(16);
    QByteArray encryptedChallenge = encrypt(randomChallenge, aesKey);
    QString challengeXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                         "pair",
                                                         "devicename=roth&updateState=1&clientchallenge=" +
                                                         encryptedChallenge.toHex(),
                                                         REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(challengeXml);
    if (NvHTTP::getXmlString(challengeXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #2";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray challengeResponseData = decrypt(m_Http.getXmlStringFromHex(challengeXml, "challengeresponse"), aesKey);
    QByteArray clientSecretData = generateRandomBytes(16);
    QByteArray challengeResponse;
    QByteArray serverResponse(challengeResponseData.data(), hashLength);

#if (OPENSSL_VERSION_NUMBER < 0x10002000L)
    ASN1_BIT_STRING *asnSignature = m_Cert->signature;
#elif (OPENSSL_VERSION_NUMBER < 0x10100000L)
    ASN1_BIT_STRING *asnSignature;
    X509_get0_signature(&asnSignature, NULL, m_Cert);
#else
    const ASN1_BIT_STRING *asnSignature;
    X509_get0_signature(&asnSignature, NULL, m_Cert);
#endif

    challengeResponse.append(challengeResponseData.data() + hashLength, 16);
    challengeResponse.append(reinterpret_cast<char*>(asnSignature->data), asnSignature->length);
    challengeResponse.append(clientSecretData);

    QByteArray paddedHash = QCryptographicHash::hash(challengeResponse, hashAlgo);
    paddedHash.resize(32);
    QByteArray encryptedChallengeResponseHash = encrypt(paddedHash, aesKey);
    QString respXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&serverchallengeresp=" +
                                                    encryptedChallengeResponseHash.toHex(),
                                                    REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(respXml);
    if (NvHTTP::getXmlString(respXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #3";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray pairingSecret = NvHTTP::getXmlStringFromHex(respXml, "pairingsecret");
    QByteArray serverSecret = pairingSecret.left(16);
    QByteArray serverSignature = pairingSecret.mid(16);

    if (!verifySignature(serverSecret,
                         serverSignature,
                         serverCertStr))
    {
        qCritical() << "MITM detected";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray expectedResponseData;
    expectedResponseData.append(randomChallenge);
    expectedResponseData.append(getSignatureFromPemCert(serverCertStr));
    expectedResponseData.append(serverSecret);
    if (QCryptographicHash::hash(expectedResponseData, hashAlgo) != serverResponse)
    {
        qCritical() << "Incorrect PIN";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::PIN_WRONG;
    }

    QByteArray clientPairingSecret;
    clientPairingSecret.append(clientSecretData);
    clientPairingSecret.append(signMessage(clientSecretData));

    QString secretRespXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                          "pair",
                                                          "devicename=roth&updateState=1&clientpairingsecret=" +
                                                          clientPairingSecret.toHex(),
                                                          REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(secretRespXml);
    if (NvHTTP::getXmlString(secretRespXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #4";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QString pairChallengeXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttps,
                                                             "pair",
                                                             "devicename=roth&updateState=1&phrase=pairchallenge",
                                                             REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(pairChallengeXml);
    if (NvHTTP::getXmlString(pairChallengeXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #5";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    serverCert = std::move(unverifiedServerCert);
    return PairState::PAIRED;
```
**File:** app/backend/nvhttp.cpp (L43-46)
```cpp
void NvHTTP::setServerCert(QSslCertificate serverCert)
{
    m_ServerCert = serverCert;
}
```
**File:** app/backend/nvhttp.cpp (L419-439)
```cpp
void NvHTTP::handleSslErrors(QNetworkReply* reply, const QList<QSslError>& errors)
{
    bool ignoreErrors = true;

    if (m_ServerCert.isNull()) {
        // We should never make an HTTPS request without a cert
        Q_ASSERT(!m_ServerCert.isNull());
        return;
    }

    for (const QSslError& error : errors) {
        if (m_ServerCert != error.certificate()) {
            ignoreErrors = false;
            break;
        }
    }

    if (ignoreErrors) {
        reply->ignoreSslErrors(errors);
    }
}
```
**File:** app/backend/nvcomputer.h (L113-113)
```text
    QSslCertificate serverCert;
```
**File:** app/backend/computermanager.cpp (L599-603)
```cpp
           case NvPairingManager::PairState::PAIRED:
               // Persist the newly pinned server certificate for this host
               m_ComputerManager->saveHost(m_Computer);

               emit pairingCompleted(m_Computer, nullptr);
```
## Q7
When the client has launched/started the game and begun streaming before disconnecting, how does the client recover the connection?
### Answer
You're asking about how Moonlight handles connection recovery when a streaming session disconnects after it has already started.

## Answer

When a streaming session disconnects, Moonlight determines whether to call `/launch` or `/resume` based on the `currentgame` value from the host's `/serverinfo` response. moonlight-qt:1586-1586 

### Resume vs Launch Decision

In `Session::startConnectionAsync()`, the code checks if `m_Computer->currentgame` is non-zero (indicating a game is already running on the host): moonlight-qt:1556-1557 

If the game is already running, it calls `NvHTTP::startApp()` with the `"resume"` parameter instead of `"launch"`: moonlight-qt:1586-1593 

```cpp
http.startApp(m_Computer->currentgame != 0 ? "resume" : "launch",
              m_Computer->isNvidiaServerSoftware,
              m_App.id, &m_StreamConfig,
              enableGameOptimizations,
              m_Preferences->playAudioOnHost,
              m_InputHandler->getAttachedGamepadMask(),
              !m_Preferences->multiController,
              rtspSessionUrl);
```

### How Resume Works

The `/resume` endpoint tells the host to reconnect to an existing game session rather than starting a new one.<cite /> This preserves the game state and allows the client to rejoin the same streaming session.<cite />

The same connection establishment process follows after calling `/resume` - the RTSP session URL is obtained from the response and passed to `LiStartConnection()` to establish the streaming connection. moonlight-qt:1678-1680 

### State Detection

The host's state is tracked through periodic `/serverinfo` polling, which updates the `currentgame` field in the `NvComputer` object.<cite /> When the state shows `SUNSHINE_SERVER_BUSY` (as in your earlier example) with a non-zero `currentgame` value, Moonlight knows a game is already running and will use resume instead of launch.<cite />

## Notes

The resume functionality allows seamless reconnection to an existing game session without restarting the game on the host. This is particularly useful for temporary network interruptions or when the client application crashes but the host game continues running. The same certificate authentication and connection establishment process is used for both launch and resume operations.

Wiki pages you might want to explore:
- [User Interface System (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2)
- [Streaming Core (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#4)
### Citations
**File:** app/streaming/session.cpp (L1556-1557)
```cpp
    Q_ASSERT(m_Computer->currentGameId == 0 ||
             m_Computer->currentGameId == m_App.id);
```
**File:** app/streaming/session.cpp (L1586-1593)
```cpp
        http.startApp(m_Computer->currentGameId != 0 ? "resume" : "launch",
                      m_Computer->isNvidiaServerSoftware,
                      m_App.id, &m_StreamConfig,
                      enableGameOptimizations,
                      m_Preferences->playAudioOnHost,
                      m_InputHandler->getAttachedGamepadMask(),
                      !m_Preferences->multiController,
                      rtspSessionUrl);
```
**File:** app/streaming/session.cpp (L1678-1680)
```cpp
    int err = LiStartConnection(&hostInfo, &m_StreamConfig, &k_ConnCallbacks,
                                &m_VideoCallbacks, &m_AudioCallbacks,
                                NULL, 0, NULL, 0);
```
## Q8
How does the client terminate the connection?
### Answer
You're asking about how Moonlight terminates a streaming connection when the user wants to disconnect.

## Answer

Moonlight provides multiple ways to terminate a streaming connection:

### User-Initiated Disconnection

Users can disconnect from an active streaming session using keyboard shortcuts or gamepad button combinations. The UI displays a tip showing these options: **Ctrl+Alt+Shift+Q** for keyboard or **Start+Select+L1+R1** for gamepad. moonlight-qt:167-168 

### Connection Termination Flow

When a connection terminates, the `Session::clConnectionTerminated()` callback is invoked with an error code. moonlight-qt:98-155  This callback:

1. **Performs port testing** to diagnose connectivity issues if the termination was unexpected moonlight-qt:100-101 

2. **Determines if termination was graceful** - If the error code is `ML_ERROR_GRACEFUL_TERMINATION`, no error dialog is shown moonlight-qt:105-106 

3. **Displays error messages** for unexpected terminations (network issues, video encoding errors, etc.) moonlight-qt:108-144 

4. **Pushes a quit event** to the SDL event loop to exit the streaming session moonlight-qt:150-154 

### UI Cleanup After Termination

After the session ends, the `StreamSegue::sessionFinished()` method handles cleanup: moonlight-qt:73-108 

1. **Re-enables gamepad navigation** for the UI moonlight-qt:79-80 

2. **Pops the stream view** from the navigation stack to return to the previous screen moonlight-qt:93-94 

3. **Shows the main window** again moonlight-qt:96-97 

4. **Displays any error dialogs** if the termination was unexpected moonlight-qt:103-106 

The session object is then garbage collected to free resources. moonlight-qt:110-116 

### Quitting Running Apps

Moonlight can also terminate a running game on the host without streaming it. The `ComputerManager::quitRunningApp()` method creates a `PendingQuitTask` that sends a quit request to the host server. moonlight-qt:675-682  This is used when users want to stop a game remotely without connecting to it.

## Notes

The termination process distinguishes between graceful disconnections (user-initiated) and unexpected terminations (network errors, encoding failures). For unexpected terminations, Moonlight performs network diagnostics and displays helpful error messages to guide troubleshooting. The same cleanup process applies whether the user disconnects manually or the connection fails unexpectedly.

Wiki pages you might want to explore:
- [User Interface System (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2)
- [PC Discovery View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.1)
### Citations
**File:** app/gui/StreamSegue.qml (L73-108)
```text
    function sessionFinished(portTestResult)
    {
        if (portTestResult !== 0 && portTestResult !== -1 && streamSegueErrorDialog.text) {
            streamSegueErrorDialog.text += "\n\n" + qsTr("This PC's Internet connection is blocking Moonlight. Streaming over the Internet may not work while connected to this network.")
        }

        // Re-enable GUI gamepad usage now
        SdlGamepadKeyNavigation.enable()

        if (quitAfter) {
            if (streamSegueErrorDialog.text) {
                // Quit when the error dialog is acknowledged
                streamSegueErrorDialog.quitAfter = quitAfter
                streamSegueErrorDialog.open()
            }
            else {
                // Quit immediately
                Qt.quit()
            }
        } else {
            // Exit this view
            stackView.pop()

            // Show the Qt window again after streaming
            window.visible = true

            // Display any launch errors. We do this after
            // the Qt UI is visible again to prevent losing
            // focus on the dialog which would impact gamepad
            // users.
            if (streamSegueErrorDialog.text) {
                streamSegueErrorDialog.quitAfter = quitAfter
                streamSegueErrorDialog.open()
            }
        }
    }
```
**File:** app/gui/StreamSegue.qml (L110-116)
```text
    function sessionReadyForDeletion()
    {
        // Garbage collect the Session object since it's pretty heavyweight
        // and keeps other libraries (like SDL_TTF) around until it is deleted.
        session = null
        gc()
    }
```
**File:** app/gui/StreamSegue.qml (L167-168)
```text
            hintText.text = qsTr("Tip:") + " " + qsTr("Press %1 to disconnect your session").arg(SdlGamepadKeyNavigation.getConnectedGamepads() > 0 ?
                                                  qsTr("Start+Select+L1+R1") : qsTr("Ctrl+Alt+Shift+Q"))
```
**File:** app/streaming/session.cpp (L98-155)
```cpp
void Session::clConnectionTerminated(int errorCode)
{
    unsigned int portFlags = LiGetPortFlagsFromTerminationErrorCode(errorCode);
    s_ActiveSession->m_PortTestResults = LiTestClientConnectivity(CONN_TEST_SERVER, 443, portFlags);

    // Display the termination dialog if this was not intended
    switch (errorCode) {
    case ML_ERROR_GRACEFUL_TERMINATION:
        break;

    case ML_ERROR_NO_VIDEO_TRAFFIC:
        s_ActiveSession->m_UnexpectedTermination = true;

        char ports[128];
        SDL_assert(portFlags != 0);
        LiStringifyPortFlags(portFlags, ", ", ports, sizeof(ports));
        emit s_ActiveSession->displayLaunchError(tr("No video received from host.") + "\n\n"+
                                                 tr("Check your firewall and port forwarding rules for port(s): %1").arg(ports));
        break;

    case ML_ERROR_NO_VIDEO_FRAME:
        s_ActiveSession->m_UnexpectedTermination = true;
        emit s_ActiveSession->displayLaunchError(tr("Your network connection isn't performing well. Reduce your video bitrate setting or try a faster connection."));
        break;

    case ML_ERROR_PROTECTED_CONTENT:
    case ML_ERROR_UNEXPECTED_EARLY_TERMINATION:
        s_ActiveSession->m_UnexpectedTermination = true;
        emit s_ActiveSession->displayLaunchError(tr("Something went wrong on your host PC when starting the stream.") + "\n\n" +
                                                 tr("Make sure you don't have any DRM-protected content open on your host PC. You can also try restarting your host PC."));
        break;

    case ML_ERROR_FRAME_CONVERSION:
        s_ActiveSession->m_UnexpectedTermination = true;
        emit s_ActiveSession->displayLaunchError(tr("The host PC reported a fatal video encoding error.") + "\n\n" +
                                                 tr("Try disabling HDR mode, changing the streaming resolution, or changing your host PC's display resolution."));
        break;

    default:
        s_ActiveSession->m_UnexpectedTermination = true;

        // We'll assume large errors are hex values
        bool hexError = qAbs(errorCode) > 1000;
        emit s_ActiveSession->displayLaunchError(tr("Connection terminated") + "\n\n" +
                                                 tr("Error code: %1").arg(errorCode, hexError ? 8 : 0, hexError ? 16 : 10, QChar('0')));
        break;
    }

    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION,
                 "Connection terminated: %d",
                 errorCode);

    // Push a quit event to the main loop
    SDL_Event event;
    event.type = SDL_QUIT;
    event.quit.timestamp = SDL_GetTicks();
    SDL_PushEvent(&event);
}
```
**File:** app/backend/computermanager.cpp (L675-682)
```cpp
void ComputerManager::quitRunningApp(NvComputer* computer)
{
    QWriteLocker lock(&computer->lock);
    computer->pendingQuit = true;

    PendingQuitTask* quit = new PendingQuitTask(this, computer);
    QThreadPool::globalInstance()->start(quit);
}
```
## Q9
Please list all the APIs used for the client and server interaction, including their purposes and required parameters, and list the APIs needed for the entire process from adding a computer to selecting one in the app list and starting a connection to ending the connection.
### Answer
Based on my analysis of the Moonlight codebase, here are all the client-server interaction APIs used throughout the entire process:

## 1. **Adding a Computer**

### Server Discovery - `serverinfo` API
**Purpose**: Discover and retrieve information about the host PC, including pairing status, current game, server version, and HTTPS port. moonlight-qt:124-187 

**Required Parameters**:
- `uniqueid`: Common UID for Moonlight clients (fixed: "0123456789ABCDEF")
- `uuid`: Random UUID for the request

**Protocol**: HTTP initially (before pairing), then HTTPS (after pairing)

### Pairing - 5-Phase Cryptographic Handshake

**Purpose**: Establish trust between client and host PC through certificate exchange and PIN verification. moonlight-qt:191-355 

**Phase 1 - Get Server Certificate**:
- Endpoint: `pair`
- Parameters:
  - `devicename=roth`
  - `updateState=1`
  - `phrase=getservercert`
  - `salt`: 16-byte random salt (hex)
  - `clientcert`: Client certificate (hex)

**Phase 2 - Client Challenge**:
- Endpoint: `pair`
- Parameters:
  - `devicename=roth`
  - `updateState=1`
  - `clientchallenge`: Encrypted 16-byte challenge (hex)

**Phase 3 - Server Challenge Response**:
- Endpoint: `pair`
- Parameters:
  - `devicename=roth`
  - `updateState=1`
  - `serverchallengeresp`: Encrypted challenge response hash (hex)

**Phase 4 - Client Pairing Secret**:
- Endpoint: `pair`
- Parameters:
  - `devicename=roth`
  - `updateState=1`
  - `clientpairingsecret`: Client secret + signature (hex)

**Phase 5 - Final Challenge (HTTPS)**:
- Endpoint: `pair`
- Parameters:
  - `devicename=roth`
  - `updateState=1`
  - `phrase=pairchallenge`

**Protocol**: HTTP for phases 1-4, HTTPS for phase 5

## 2. **Selecting an App**

### App List - `applist` API
**Purpose**: Retrieve the list of available applications on the host PC. moonlight-qt:288-328 

**Required Parameters**:
- `uniqueid`: "0123456789ABCDEF"
- `uuid`: Random UUID

**Protocol**: HTTPS (requires prior pairing)

**Response**: XML with app information including:
- `AppTitle`: Application name
- `ID`: Application ID
- `IsHdrSupported`: HDR capability
- `IsAppCollectorGame`: Whether it's an App Collector game

### Box Art - `getBoxArt` API
**Purpose**: Download application cover art/thumbnails. moonlight-qt:178-179 moonlight-qt:107-129 

**Required Parameters**:
- `appId`: Application ID

**Protocol**: HTTPS
**Response**: Image data (various formats, cached as PNG locally)

## 3. **Starting a Streaming Connection**

### Launch/Resume - `launch` or `resume` API
**Purpose**: Start a new streaming session or resume an existing one. moonlight-qt:190-236 moonlight-qt:1582-1600 

**Endpoint**: `launch` (new session) or `resume` (existing session)

**Required Parameters**:
- `uniqueid`: "0123456789ABCDEF"
- `uuid`: Random UUID
- `appid`: Application ID to launch
- `mode`: Resolution and FPS (format: `{width}x{height}x{fps}`)
- `additionalStates=1`: Enable additional states
- `sops`: Stream optimization settings (0 or 1)
- `rikey`: Remote input AES key (hex)
- `rikeyid`: Remote input key ID
- `hdrMode`: HDR mode flag (included if HDR supported)
- `clientHdrCapVersion`, `clientHdrCapSupportedFlagsInUint32`, `clientHdrCapMetaDataId`, `clientHdrCapDisplayData`: HDR capability parameters (if HDR mode)
- `localAudioPlayMode`: Play audio on host (0 or 1)
- `surroundAudioInfo`: Surround audio configuration
- `remoteControllersBitmap`: Gamepad mask
- `gcmap`: Gamepad controller map
- `gcpersist`: Persist game controllers on disconnect (0 or 1)
- Additional parameters from `LiGetLaunchUrlQueryParameters()`

**Protocol**: HTTPS

**Response**: XML containing `sessionUrl0` (RTSP session URL)

**Decision Logic**: The verb is determined based on whether a game is currently running: moonlight-qt:1586-1593 

## 4. **Ending a Streaming Connection**

### Quit App - `cancel` API
**Purpose**: Terminate the currently running application on the host PC. moonlight-qt:238-259 

**Required Parameters**:
- `uniqueid`: "0123456789ABCDEF"
- `uuid`: Random UUID

**Protocol**: HTTPS

**Timeout**: 30 seconds

**Note**: The quit operation is optional based on user preferences: moonlight-qt:1554-1558 

## Additional APIs

### Wake-on-LAN
**Purpose**: Wake up a sleeping/powered-off host PC. moonlight-qt:1-50 

**Protocol**: UDP magic packets sent to multiple addresses and ports (9, 47009, and dynamic ports 47998-48010)

### Unpair - `unpair` API
**Purpose**: Remove pairing relationship (used during pairing failures). moonlight-qt:232-234 

**Required Parameters**: Standard uniqueid and uuid

**Protocol**: HTTP

## Notes

- All HTTP/HTTPS requests use a common `uniqueid` of "0123456789ABCDEF" to allow Moonlight clients to manage each other's sessions
- Each request includes a random `uuid` parameter generated via `QUuid::createUuid()`
- Certificate pinning is implemented for HTTPS connections to prevent MITM attacks
- Timeouts vary by operation: 2s (fast-fail), 5s (normal), 30s (resume/quit), 120s (launch)
- The base URL format is `http(s)://{host}:{port}/{command}?{parameters}`
### Citations
**File:** app/backend/nvhttp.cpp (L124-187)
```cpp
NvHTTP::getServerInfo(NvLogLevel logLevel, bool fastFail)
{
    QString serverInfo;

    // Check if we have a pinned cert and HTTPS port for this host yet
    if (!m_ServerCert.isNull() && httpsPort() != 0)
    {
        try
        {
            // Always try HTTPS first, since it properly reports
            // pairing status (and a few other attributes).
            serverInfo = openConnectionToString(m_BaseUrlHttps,
                                                "serverinfo",
                                                nullptr,
                                                fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                                logLevel);
            // Throws if the request failed
            verifyResponseStatus(serverInfo);
        }
        catch (const GfeHttpResponseException& e)
        {
            if (e.getStatusCode() == 401)
            {
                // Certificate validation error, fallback to HTTP
                serverInfo = openConnectionToString(m_BaseUrlHttp,
                                                    "serverinfo",
                                                    nullptr,
                                                    fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                                    logLevel);
                verifyResponseStatus(serverInfo);
            }
            else
            {
                // Rethrow real errors
                throw e;
            }
        }
    }
    else
    {
        // Only use HTTP prior to pairing or fetching HTTPS port
        serverInfo = openConnectionToString(m_BaseUrlHttp,
                                            "serverinfo",
                                            nullptr,
                                            fastFail ? FAST_FAIL_TIMEOUT_MS : REQUEST_TIMEOUT_MS,
                                            logLevel);
        verifyResponseStatus(serverInfo);

        // Populate the HTTPS port
        uint16_t httpsPort = getXmlString(serverInfo, "HttpsPort").toUShort();
        if (httpsPort == 0) {
            httpsPort = DEFAULT_HTTPS_PORT;
        }
        setHttpsPort(httpsPort);

        // If we just needed to determine the HTTPS port, we'll try again over
        // HTTPS now that we have the port number
        if (!m_ServerCert.isNull()) {
            return getServerInfo(logLevel, fastFail);
        }
    }

    return serverInfo;
}
```
**File:** app/backend/nvhttp.cpp (L190-236)
```cpp
NvHTTP::startApp(QString verb,
                 bool isGfe,
                 int appId,
                 PSTREAM_CONFIGURATION streamConfig,
                 bool sops,
                 bool localAudio,
                 int gamepadMask,
                 bool persistGameControllersOnDisconnect,
                 QString& rtspSessionUrl)
{
    int riKeyId;

    memcpy(&riKeyId, streamConfig->remoteInputAesIv, sizeof(riKeyId));
    riKeyId = qFromBigEndian(riKeyId);

    QString response =
            openConnectionToString(m_BaseUrlHttps,
                                   verb,
                                   "appid="+QString::number(appId)+
                                   "&mode="+QString::number(streamConfig->width)+"x"+
                                   QString::number(streamConfig->height)+"x"+
                                   // Using an FPS value over 60 causes SOPS to default to 720p60,
                                   // so force it to 0 to ensure the correct resolution is set. We
                                   // used to use 60 here but that locked the frame rate to 60 FPS
                                   // on GFE 3.20.3. We don't need this hack for Sunshine.
                                   QString::number((streamConfig->fps > 60 && isGfe) ? 0 : streamConfig->fps)+
                                   "&additionalStates=1&sops="+QString::number(sops ? 1 : 0)+
                                   "&rikey="+QByteArray(streamConfig->remoteInputAesKey, sizeof(streamConfig->remoteInputAesKey)).toHex()+
                                   "&rikeyid="+QString::number(riKeyId)+
                                   ((streamConfig->supportedVideoFormats & VIDEO_FORMAT_MASK_10BIT) ?
                                       "&hdrMode=1&clientHdrCapVersion=0&clientHdrCapSupportedFlagsInUint32=0&clientHdrCapMetaDataId=NV_STATIC_METADATA_TYPE_1&clientHdrCapDisplayData=0x0x0x0x0x0x0x0x0x0x0" :
                                        "")+
                                   "&localAudioPlayMode="+QString::number(localAudio ? 1 : 0)+
                                   "&surroundAudioInfo="+QString::number(SURROUNDAUDIOINFO_FROM_AUDIO_CONFIGURATION(streamConfig->audioConfiguration))+
                                   "&remoteControllersBitmap="+QString::number(gamepadMask)+
                                   "&gcmap="+QString::number(gamepadMask)+
                                   "&gcpersist="+QString::number(persistGameControllersOnDisconnect ? 1 : 0)+
                                   LiGetLaunchUrlQueryParameters(),
                                   LAUNCH_TIMEOUT_MS);

    qInfo() << "Launch response:" << response;

    // Throws if the request failed
    verifyResponseStatus(response);

    rtspSessionUrl = getXmlString(response, "sessionUrl0");
}
```
**File:** app/backend/nvhttp.cpp (L238-259)
```cpp
void
NvHTTP::quitApp()
{
    QString response =
            openConnectionToString(m_BaseUrlHttps,
                                   "cancel",
                                   nullptr,
                                   QUIT_TIMEOUT_MS);

    qInfo() << "Quit response:" << response;

    // Throws if the request failed
    verifyResponseStatus(response);

    // Newer GFE versions will just return success even if quitting fails
    // if we're not the original requester.
    if (getCurrentGame(getServerInfo(NvHTTP::NVLL_ERROR)) != 0) {
        // Generate a synthetic GfeResponseException letting the caller know
        // that they can't kill someone else's stream.
        throw GfeHttpResponseException(599, "");
    }
}
```
**File:** app/backend/nvhttp.cpp (L288-328)
```cpp
QVector<NvApp>
NvHTTP::getAppList()
{
    QString appxml = openConnectionToString(m_BaseUrlHttps,
                                            "applist",
                                            nullptr,
                                            REQUEST_TIMEOUT_MS,
                                            NvLogLevel::NVLL_ERROR);
    verifyResponseStatus(appxml);

    QXmlStreamReader xmlReader(appxml);
    QVector<NvApp> apps;
    while (!xmlReader.atEnd()) {
        while (xmlReader.readNextStartElement()) {
            auto name = xmlReader.name();
            if (name == QString("App")) {
                // We must have a valid app before advancing to the next one
                if (!apps.isEmpty() && !apps.last().isInitialized()) {
                    qWarning() << "Invalid applist XML";
                    Q_ASSERT(false);
                    return QVector<NvApp>();
                }
                apps.append(NvApp());
            }
            else if (name == QString("AppTitle")) {
                apps.last().name = xmlReader.readElementText();
            }
            else if (name == QString("ID")) {
                apps.last().id = xmlReader.readElementText().toInt();
            }
            else if (name == QString("IsHdrSupported")) {
                apps.last().hdrSupported = xmlReader.readElementText() == "1";
            }
            else if (name == QString("IsAppCollectorGame")) {
                apps.last().isAppCollectorGame = xmlReader.readElementText() == "1";
            }
        }
    }

    return apps;
}
```
**File:** app/backend/nvpairingmanager.cpp (L191-355)
```cpp
NvPairingManager::pair(QString appVersion, QString pin, QSslCertificate& serverCert)
{
    int serverMajorVersion = NvHTTP::parseQuad(appVersion).at(0);
    qInfo() << "Pairing with server generation:" << serverMajorVersion;

    QCryptographicHash::Algorithm hashAlgo;
    int hashLength;
    if (serverMajorVersion >= 7)
    {
        // Gen 7+ uses SHA-256 hashing
        hashAlgo = QCryptographicHash::Sha256;
        hashLength = 32;
    }
    else
    {
        // Prior to Gen 7 uses SHA-1 hashing
        hashAlgo = QCryptographicHash::Sha1;
        hashLength = 20;
    }

    QByteArray salt = generateRandomBytes(16);
    QByteArray saltedPin = saltPin(salt, pin);

    QByteArray aesKey = QCryptographicHash::hash(saltedPin, hashAlgo).constData();
    aesKey.truncate(16);

    QString getCert = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&phrase=getservercert&salt=" +
                                                    salt.toHex() + "&clientcert=" + IdentityManager::get()->getCertificate().toHex(),
                                                    0);
    NvHTTP::verifyResponseStatus(getCert);
    if (NvHTTP::getXmlString(getCert, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #1";
        return PairState::FAILED;
    }

    QByteArray serverCertStr = NvHTTP::getXmlStringFromHex(getCert, "plaincert");
    if (serverCertStr == nullptr)
    {
        qCritical() << "Server likely already pairing";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::ALREADY_IN_PROGRESS;
    }

    QSslCertificate unverifiedServerCert = QSslCertificate(serverCertStr);
    if (unverifiedServerCert.isNull()) {
        Q_ASSERT(!unverifiedServerCert.isNull());

        qCritical() << "Failed to parse plaincert";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    // Pin this cert for TLS until pairing is complete. If successful, we will propagate
    // the cert into the NvComputer object and persist it.
    m_Http.setServerCert(unverifiedServerCert);

    QByteArray randomChallenge = generateRandomBytes(16);
    QByteArray encryptedChallenge = encrypt(randomChallenge, aesKey);
    QString challengeXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                         "pair",
                                                         "devicename=roth&updateState=1&clientchallenge=" +
                                                         encryptedChallenge.toHex(),
                                                         REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(challengeXml);
    if (NvHTTP::getXmlString(challengeXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #2";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray challengeResponseData = decrypt(m_Http.getXmlStringFromHex(challengeXml, "challengeresponse"), aesKey);
    QByteArray clientSecretData = generateRandomBytes(16);
    QByteArray challengeResponse;
    QByteArray serverResponse(challengeResponseData.data(), hashLength);

#if (OPENSSL_VERSION_NUMBER < 0x10002000L)
    ASN1_BIT_STRING *asnSignature = m_Cert->signature;
#elif (OPENSSL_VERSION_NUMBER < 0x10100000L)
    ASN1_BIT_STRING *asnSignature;
    X509_get0_signature(&asnSignature, NULL, m_Cert);
#else
    const ASN1_BIT_STRING *asnSignature;
    X509_get0_signature(&asnSignature, NULL, m_Cert);
#endif

    challengeResponse.append(challengeResponseData.data() + hashLength, 16);
    challengeResponse.append(reinterpret_cast<char*>(asnSignature->data), asnSignature->length);
    challengeResponse.append(clientSecretData);

    QByteArray paddedHash = QCryptographicHash::hash(challengeResponse, hashAlgo);
    paddedHash.resize(32);
    QByteArray encryptedChallengeResponseHash = encrypt(paddedHash, aesKey);
    QString respXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&serverchallengeresp=" +
                                                    encryptedChallengeResponseHash.toHex(),
                                                    REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(respXml);
    if (NvHTTP::getXmlString(respXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #3";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray pairingSecret = NvHTTP::getXmlStringFromHex(respXml, "pairingsecret");
    QByteArray serverSecret = pairingSecret.left(16);
    QByteArray serverSignature = pairingSecret.mid(16);

    if (!verifySignature(serverSecret,
                         serverSignature,
                         serverCertStr))
    {
        qCritical() << "MITM detected";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QByteArray expectedResponseData;
    expectedResponseData.append(randomChallenge);
    expectedResponseData.append(getSignatureFromPemCert(serverCertStr));
    expectedResponseData.append(serverSecret);
    if (QCryptographicHash::hash(expectedResponseData, hashAlgo) != serverResponse)
    {
        qCritical() << "Incorrect PIN";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::PIN_WRONG;
    }

    QByteArray clientPairingSecret;
    clientPairingSecret.append(clientSecretData);
    clientPairingSecret.append(signMessage(clientSecretData));

    QString secretRespXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                          "pair",
                                                          "devicename=roth&updateState=1&clientpairingsecret=" +
                                                          clientPairingSecret.toHex(),
                                                          REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(secretRespXml);
    if (NvHTTP::getXmlString(secretRespXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #4";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    QString pairChallengeXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttps,
                                                             "pair",
                                                             "devicename=roth&updateState=1&phrase=pairchallenge",
                                                             REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(pairChallengeXml);
    if (NvHTTP::getXmlString(pairChallengeXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #5";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }

    serverCert = std::move(unverifiedServerCert);
    return PairState::PAIRED;
}
```
**File:** app/backend/nvhttp.h (L178-179)
```text
    QImage
    getBoxArt(int appId);
```
**File:** app/backend/boxartmanager.cpp (L107-129)
```cpp
QUrl BoxArtManager::loadBoxArtFromNetwork(NvComputer* computer, int appId)
{
    NvHTTP http(computer);

    QString cachePath = getFilePathForBoxArt(computer, appId);
    QImage image;
    try {
        image = http.getBoxArt(appId);
    } catch (...) {}

    // Cache the box art on disk if it loaded
    if (!image.isNull()) {
        if (image.save(cachePath)) {
            return QUrl::fromLocalFile(cachePath);
        }
        else {
            // A failed save() may leave a zero byte file. Make sure that's removed.
            QFile(cachePath).remove();
        }
    }

    return QUrl();
}
```
**File:** app/streaming/session.cpp (L1554-1558)
```cpp
    // The UI should have ensured the old game was already quit
    // if we decide to stream a different game.
    Q_ASSERT(m_Computer->currentGameId == 0 ||
             m_Computer->currentGameId == m_App.id);

```
**File:** app/streaming/session.cpp (L1582-1600)
```cpp
    QString rtspSessionUrl;

    try {
        NvHTTP http(m_Computer);
        http.startApp(m_Computer->currentGameId != 0 ? "resume" : "launch",
                      m_Computer->isNvidiaServerSoftware,
                      m_App.id, &m_StreamConfig,
                      enableGameOptimizations,
                      m_Preferences->playAudioOnHost,
                      m_InputHandler->getAttachedGamepadMask(),
                      !m_Preferences->multiController,
                      rtspSessionUrl);
    } catch (const GfeHttpResponseException& e) {
        emit displayLaunchError(tr("Host returned error: %1").arg(e.toQString()));
        return false;
    } catch (const QtNetworkReplyException& e) {
        emit displayLaunchError(e.toQString());
        return false;
    }
```
**File:** app/backend/nvcomputer.cpp (L1-50)
```cpp
#include "nvcomputer.h"
#include "nvapp.h"
#include "settings/compatfetcher.h"

#include <QUdpSocket>
#include <QHostInfo>
#include <QNetworkInterface>
#include <QNetworkProxy>

#define SER_NAME "hostname"
#define SER_UUID "uuid"
#define SER_MAC "mac"
#define SER_LOCALADDR "localaddress"
#define SER_LOCALPORT "localport"
#define SER_REMOTEADDR "remoteaddress"
#define SER_REMOTEPORT "remoteport"
#define SER_MANUALADDR "manualaddress"
#define SER_MANUALPORT "manualport"
#define SER_IPV6ADDR "ipv6address"
#define SER_IPV6PORT "ipv6port"
#define SER_APPLIST "apps"
#define SER_SRVCERT "srvcert"
#define SER_CUSTOMNAME "customname"
#define SER_NVIDIASOFTWARE "nvidiasw"

NvComputer::NvComputer(QSettings& settings)
{
    this->name = settings.value(SER_NAME).toString();
    this->uuid = settings.value(SER_UUID).toString();
    this->hasCustomName = settings.value(SER_CUSTOMNAME).toBool();
    this->macAddress = settings.value(SER_MAC).toByteArray();
    this->localAddress = NvAddress(settings.value(SER_LOCALADDR).toString(),
                                   settings.value(SER_LOCALPORT, QVariant(DEFAULT_HTTP_PORT)).toUInt());
    this->remoteAddress = NvAddress(settings.value(SER_REMOTEADDR).toString(),
                                    settings.value(SER_REMOTEPORT, QVariant(DEFAULT_HTTP_PORT)).toUInt());
    this->ipv6Address = NvAddress(settings.value(SER_IPV6ADDR).toString(),
                                  settings.value(SER_IPV6PORT, QVariant(DEFAULT_HTTP_PORT)).toUInt());
    this->manualAddress = NvAddress(settings.value(SER_MANUALADDR).toString(),
                                    settings.value(SER_MANUALPORT, QVariant(DEFAULT_HTTP_PORT)).toUInt());
    this->serverCert = QSslCertificate(settings.value(SER_SRVCERT).toByteArray());
    this->isNvidiaServerSoftware = settings.value(SER_NVIDIASOFTWARE).toBool();

    int appCount = settings.beginReadArray(SER_APPLIST);
    this->appList.reserve(appCount);
    for (int i = 0; i < appCount; i++) {
        settings.setArrayIndex(i);

        NvApp app(settings);
        this->appList.append(app);
    }
```
## Q10
The server completes the pairing by inputting the PIN code displayed by the client. How does the client wait for the server's response to complete the pairing during the time the PIN code is generated and the user inputs the PIN on the server side?
### Answer
You're asking about how the Moonlight client waits for the server to complete pairing after displaying the PIN code to the user.

## Answer

The client doesn't actively poll or wait for the server's response during pairing. Instead, the pairing process is **synchronous and blocking** - the client sends requests sequentially through all 5 phases and waits for each response before proceeding to the next phase.

### Pairing Execution Flow

When the user clicks on an unpaired PC, the client generates a PIN and displays it in a dialog: moonlight-qt:239-246 

The pairing task runs in a background thread via `PendingPairingTask`: moonlight-qt:564-582 

### The Blocking Nature of Pairing

Inside `NvPairingManager::pair()`, each phase makes an HTTP/HTTPS request and **blocks waiting for the response** before proceeding: moonlight-qt:217-227 

The server validates the PIN during Phase 3 (server challenge response). If the user hasn't entered the PIN yet on the server side, the server simply doesn't respond or returns an error, causing the pairing to fail: moonlight-qt:287-298 

### PIN Validation

The PIN validation happens when the client sends the encrypted challenge response hash in Phase 3. The server decrypts this using the PIN-derived key and verifies it matches the expected value: moonlight-qt:313-322 

If the PIN is incorrect (user entered wrong PIN on server), the server returns a response that causes the client to detect `PIN_WRONG` state: moonlight-qt:585-586 

### UI Feedback

While pairing is in progress, the dialog remains open showing the PIN: moonlight-qt:302-310 

When pairing completes (successfully or with error), the `pairingCompleted` signal is emitted, which closes the dialog: moonlight-qt:47-58 

## Notes

The pairing process uses HTTP request timeouts (defined as `REQUEST_TIMEOUT_MS`) to prevent indefinite waiting. If the user takes too long to enter the PIN on the server, the HTTP request will timeout and pairing will fail. The client doesn't implement any retry logic or polling mechanism - it's a single synchronous attempt that either succeeds or fails based on the server's responses to the 5-phase handshake.

Wiki pages you might want to explore:
- [User Interface System (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2)
- [PC Discovery View (moonlight-stream/moonlight-qt)](/wiki/moonlight-stream/moonlight-qt#2.1)
### Citations
**File:** app/gui/PcView.qml (L47-58)
```text
    function pairingComplete(error)
    {
        // Close the PIN dialog
        pairDialog.close()

        // Display a failed dialog if we got an error
        if (error !== undefined) {
            errorDialog.text = error
            errorDialog.helpText = ""
            errorDialog.open()
        }
    }
```
**File:** app/gui/PcView.qml (L239-246)
```text
                    var pin = computerModel.generatePinString()

                    // Kick off pairing in the background
                    computerModel.pairComputer(index, pin)

                    // Display the pairing dialog
                    pairDialog.pin = pin
                    pairDialog.open()
```
**File:** app/gui/PcView.qml (L302-310)
```text
        // don't allow edits to the rest of the window while open
        property string pin : "0000"
        text:qsTr("Please enter %1 on your host PC. This dialog will close when pairing is completed.").arg(pin)+"\n\n"+
             qsTr("If your host PC is running Sunshine, navigate to the Sunshine web UI to enter the PIN.")
        standardButtons: Dialog.Cancel
        onRejected: {
            // FIXME: We should interrupt pairing here
        }
    }
```
**File:** app/backend/computermanager.cpp (L564-582)
```cpp
    PendingPairingTask(ComputerManager* computerManager, NvComputer* computer, QString pin)
        : m_ComputerManager(computerManager),
          m_Computer(computer),
          m_Pin(pin)
    {
        connect(this, &PendingPairingTask::pairingCompleted,
                computerManager, &ComputerManager::pairingCompleted);
    }

signals:
    void pairingCompleted(NvComputer* computer, QString error);

private:
    void run()
    {
        NvPairingManager pairingManager(m_Computer);

        try {
           NvPairingManager::PairState result = pairingManager.pair(m_Computer->appVersion, m_Pin, m_Computer->serverCert);
```
**File:** app/backend/computermanager.cpp (L585-586)
```cpp
           case NvPairingManager::PairState::PIN_WRONG:
               emit pairingCompleted(m_Computer, tr("The PIN from the PC didn't match. Please try again."));
```
**File:** app/backend/nvpairingmanager.cpp (L217-227)
```cpp
    QString getCert = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&phrase=getservercert&salt=" +
                                                    salt.toHex() + "&clientcert=" + IdentityManager::get()->getCertificate().toHex(),
                                                    0);
    NvHTTP::verifyResponseStatus(getCert);
    if (NvHTTP::getXmlString(getCert, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #1";
        return PairState::FAILED;
    }
```
**File:** app/backend/nvpairingmanager.cpp (L287-298)
```cpp
    QString respXml = m_Http.openConnectionToString(m_Http.m_BaseUrlHttp,
                                                    "pair",
                                                    "devicename=roth&updateState=1&serverchallengeresp=" +
                                                    encryptedChallengeResponseHash.toHex(),
                                                    REQUEST_TIMEOUT_MS);
    NvHTTP::verifyResponseStatus(respXml);
    if (NvHTTP::getXmlString(respXml, "paired") != "1")
    {
        qCritical() << "Failed pairing at stage #3";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::FAILED;
    }
```
**File:** app/backend/nvpairingmanager.cpp (L313-322)
```cpp
    QByteArray expectedResponseData;
    expectedResponseData.append(randomChallenge);
    expectedResponseData.append(getSignatureFromPemCert(serverCertStr));
    expectedResponseData.append(serverSecret);
    if (QCryptographicHash::hash(expectedResponseData, hashAlgo) != serverResponse)
    {
        qCritical() << "Incorrect PIN";
        m_Http.openConnectionToString(m_Http.m_BaseUrlHttp, "unpair", nullptr, REQUEST_TIMEOUT_MS);
        return PairState::PIN_WRONG;
    }
```